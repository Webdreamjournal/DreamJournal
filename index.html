<!-- 
Dream Journal - A privacy-focused dream tracking application
Copyright (C) 2024 Dream Journal Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Affero General Public License for more details.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dream Journal</title>
    <style>
        /* === DREAM JOURNAL OPTIMIZED CSS v1.26.1 === */
        /* HSL Theme System + Utility Classes - 90% reduction in theme CSS + inline style elimination */
        /* === OPTIMIZED HSL THEME SYSTEM === */
        
        :root {
            /* Static values that don't change between themes */
            --border-radius: 8px;
            --border-radius-lg: 12px;
            --border-radius-xl: 15px;
            --font-weight-medium: 500;
            --font-weight-semibold: 600;
            --transition: all 0.3s ease;
            
            /* === COLOR BASE SYSTEM (HSL) === */
            /* Core color families - hue & saturation never change */
            --primary-h: 238;    --primary-s: 84%;
            --success-h: 158;    --success-s: 64%;
            --error-h: 0;        --error-s: 84%;
            --warning-h: 32;     --warning-s: 95%;
            --info-h: 199;       --info-s: 89%;
            
            /* Neutral grays */
            --neutral-h: 222;    --neutral-s: 47%;
            --slate-h: 215;      --slate-s: 20%;
            --gray-h: 220;       --gray-s: 13%;
            
            /* === LIGHT THEME LIGHTNESS VALUES === */
            /* Backgrounds */
            --bg-primary-l: 100%;      --bg-secondary-l: 100%;
            --bg-elevated-l: 100%;     --bg-input-l: 100%;
            --bg-hover-l: 98%;         --bg-subtle-l: 95%;
            --bg-light-l: 98%;         --bg-disabled-l: 99%;
            --bg-selected-l: 97%;
            
            /* Text */
            --text-primary-l: 11%;     --text-secondary-l: 38%;
            --text-tertiary-l: 42%;    --text-muted-l: 64%;
            --text-inverse-l: 100%;    --text-disabled-l: 42%;
            
            /* Borders */
            --border-light-l: 95%;     --border-color-l: 88%;
            --border-dark-l: 82%;      --border-hover-l: 82%;
            
            /* Semantic colors - consistent lightness */
            --primary-l: 59%;          --primary-hover-l: 52%;
            --success-l: 30%;          --success-hover-l: 26%;
            --error-l: 51%;            --error-hover-l: 44%;
            --warning-l: 44%;          --info-l: 39%;
            --secondary-l: 46%;        --secondary-hover-l: 35%;
            
            /* Component specific */
            --shadow-opacity: 0.1;     --modal-backdrop-opacity: 0.9;
            --voice-bg-l: 97%;         --voice-border-l: 86%;       --voice-text-l: 39%;
            --tag-bg-l: 97%;           --tag-text-l: 39%;           --tag-border-l: 86%;
            --dream-sign-bg-l: 95%;    --dream-sign-text-l: 44%;    --dream-sign-border-l: 88%;
            --notification-error-l: 93%;   --notification-success-l: 89%;
            --notification-warning-l: 95%; --notification-info-l: 97%;
        }
        
        /* === UTILITY CLASS SYSTEM === */
        /* Layout & Structure */
        .card { background: var(--bg-secondary); border: 2px solid var(--border-color); }
        .card-elevated { background: var(--bg-elevated); border: 2px solid var(--border-color); }
        .card-lg { border-radius: var(--border-radius-xl); padding: 40px; }
        .card-md { border-radius: var(--border-radius-lg); padding: 20px; }
        .card-sm { border-radius: var(--border-radius); padding: 15px; }
        
        /* Flexbox utilities */
        .flex-center { display: flex; align-items: center; justify-content: center; }
        .flex-between { display: flex; align-items: center; justify-content: space-between; }
        .flex-col { display: flex; flex-direction: column; }
        .flex-wrap { flex-wrap: wrap; }
        
        /* Spacing system */
        .gap-xs { gap: 5px; } .gap-sm { gap: 8px; } .gap-md { gap: 15px; } .gap-lg { gap: 20px; }
        .p-sm { padding: 8px; } .p-md { padding: 15px; } .p-lg { padding: 20px; } .p-xl { padding: 40px; }
        .mb-sm { margin-bottom: 10px; } .mb-md { margin-bottom: 15px; } .mb-lg { margin-bottom: 20px; }
        .mt-sm { margin-top: 10px; } .mt-md { margin-top: 15px; } .mt-lg { margin-top: 20px; }
        
        /* Typography utilities */
        .text-center { text-align: center; } .text-left { text-align: left; }
        .text-sm { font-size: 0.9em; } .text-base { font-size: 1em; } .text-lg { font-size: 1.2em; } 
        .text-xl { font-size: 1.6em; } .text-2xl { font-size: 1.8em; } .text-4xl { font-size: 4em; }
        .font-normal { font-weight: normal; } .font-semibold { font-weight: var(--font-weight-semibold); }
        .text-primary { color: var(--text-primary); } .text-secondary { color: var(--text-secondary); }
        .text-warning { color: var(--warning-color); }
        .line-height-relaxed { line-height: 1.5; } .line-height-loose { line-height: 1.6; }
        
        /* Width utilities */
        .w-full { width: 100%; } .max-w-sm { max-width: 400px; }
        
        /* Message utilities */
        .message-base { padding: 15px; border-radius: var(--border-radius); margin-bottom: 20px; 
                        font-weight: var(--font-weight-semibold); text-align: center; }
        .message-success { background: var(--notification-success-bg); color: var(--success-color); }
        .message-error { background: var(--notification-error-bg); color: var(--error-color); }
        .message-warning { background: var(--notification-warning-bg); color: var(--warning-color); }
        .message-info { background: var(--notification-info-bg); color: var(--info-color); }
        
        /* Input utilities */
        .input-pin { padding: 15px; border: 2px solid var(--border-color); border-radius: var(--border-radius); 
                     font-size: 18px; text-align: center; letter-spacing: 3px; font-family: monospace; 
                     background: var(--bg-input); }
        
        /* Box shadow utilities */
        .shadow-lg { box-shadow: var(--shadow-lg); }
        
        /* === DARK THEME - ONLY LIGHTNESS OVERRIDES === */
        [data-theme='dark'] {
            /* Backgrounds - dark */
            --bg-primary-l: 5%;        --bg-secondary-l: 11%;
            --bg-elevated-l: 20%;      --bg-input-l: 11%;
            --bg-hover-l: 20%;         --bg-subtle-l: 28%;
            --bg-light-l: 11%;         --bg-disabled-l: 5%;
            --bg-selected-l: 20%;
            
            /* Text - light */
            --text-primary-l: 98%;     --text-secondary-l: 83%;
            --text-tertiary-l: 68%;    --text-muted-l: 52%;
            --text-inverse-l: 5%;      --text-disabled-l: 52%;
            
            /* Borders - lighter */
            --border-light-l: 20%;     --border-color-l: 28%;
            --border-dark-l: 52%;      --border-hover-l: 59%;
            
            /* Semantic colors - adjusted for dark backgrounds */
            --primary-l: 67%;          --primary-hover-l: 53%;
            --success-l: 70%;          --success-hover-l: 30%;
            --error-l: 72%;            --error-hover-l: 51%;
            --warning-l: 71%;          --info-l: 67%;
            --secondary-l: 68%;        --secondary-hover-l: 83%;
            
            /* Component adjustments */
            --shadow-opacity: 0.3;     --modal-backdrop-opacity: 0.95;
            --voice-bg-l: 20%;         --voice-border-l: 67%;       --voice-text-l: 74%;
            --tag-bg-l: 20%;           --tag-text-l: 74%;           --tag-border-l: 67%;
            --dream-sign-bg-l: 15%;    --dream-sign-text-l: 81%;    --dream-sign-border-l: 35%;
            --notification-error-l: 20%;   --notification-success-l: 15%;
            --notification-warning-l: 15%; --notification-info-l: 20%;
            
            /* Special dark theme hue adjustments */
            --warning-h: 45;  /* Warmer yellow in dark mode */
        }
        
        /* === GENERATED COLOR SYSTEM === */
        :root,
        [data-theme='light'],
        [data-theme='dark'] {
            /* Core Theme Colors */
            --primary-color: hsl(var(--primary-h), var(--primary-s), var(--primary-l));
            --primary-hover: hsl(var(--primary-h), var(--primary-s), var(--primary-hover-l));
            --secondary-color: hsl(var(--slate-h), var(--slate-s), var(--secondary-l));
            --secondary-hover: hsl(var(--slate-h), var(--slate-s), var(--secondary-hover-l));
            --success-color: hsl(var(--success-h), var(--success-s), var(--success-l));
            --success-hover: hsl(var(--success-h), var(--success-s), var(--success-hover-l));
            --error-color: hsl(var(--error-h), var(--error-s), var(--error-l));
            --error-hover: hsl(var(--error-h), var(--error-s), var(--error-hover-l));
            --warning-color: hsl(var(--warning-h), var(--warning-s), var(--warning-l));
            --warning-hover: hsl(var(--warning-h), var(--warning-s), var(--warning-l));
            --info-color: hsl(var(--info-h), var(--info-s), var(--info-l));
            --info-hover: hsl(var(--info-h), var(--info-s), var(--info-l));
            
            /* Background Hierarchy */
            --bg-primary: hsl(var(--neutral-h), var(--neutral-s), var(--bg-primary-l));
            --bg-secondary: hsl(var(--neutral-h), var(--neutral-s), var(--bg-secondary-l));
            --bg-elevated: hsl(var(--gray-h), var(--gray-s), var(--bg-elevated-l));
            --bg-input: hsl(var(--neutral-h), var(--neutral-s), var(--bg-input-l));
            --bg-hover: hsl(var(--gray-h), var(--gray-s), var(--bg-hover-l));
            --bg-subtle: hsl(var(--slate-h), var(--slate-s), var(--bg-subtle-l));
            --bg-light: hsl(var(--gray-h), var(--gray-s), var(--bg-light-l));
            --bg-disabled: hsl(var(--gray-h), var(--gray-s), var(--bg-disabled-l));
            --bg-selected: hsl(var(--info-h), var(--info-s), var(--bg-selected-l));
            
            /* Text Hierarchy */
            --text-primary: hsl(var(--neutral-h), var(--neutral-s), var(--text-primary-l));
            --text-secondary: hsl(var(--slate-h), var(--slate-s), var(--text-secondary-l));
            --text-tertiary: hsl(var(--gray-h), var(--gray-s), var(--text-tertiary-l));
            --text-muted: hsl(var(--gray-h), var(--gray-s), var(--text-muted-l));
            --text-inverse: hsl(var(--neutral-h), var(--neutral-s), var(--text-inverse-l));
            --text-disabled: hsl(var(--gray-h), var(--gray-s), var(--text-disabled-l));
            
            /* Border System */
            --border-light: hsl(var(--slate-h), var(--slate-s), var(--border-light-l));
            --border-color: hsl(var(--slate-h), var(--slate-s), var(--border-color-l));
            --border-dark: hsl(var(--slate-h), var(--slate-s), var(--border-dark-l));
            --border-hover: hsl(var(--primary-h), var(--primary-s), var(--border-hover-l));
            --border-focus: var(--primary-color);
            
            /* Shadow System */
            --shadow-color: rgba(0, 0, 0, var(--shadow-opacity));
            --shadow-color-light: rgba(0, 0, 0, calc(var(--shadow-opacity) * 0.5));
            --shadow-color-dark: rgba(0, 0, 0, calc(var(--shadow-opacity) * 1.5));
            
            /* Component Specific */
            --modal-backdrop: rgba(0, 0, 0, var(--modal-backdrop-opacity));
            --gradient-primary: linear-gradient(135deg, var(--primary-color), hsl(var(--primary-h), var(--primary-s), calc(var(--primary-l) - 10%)));
            --border-dashed: 2px dashed var(--border-dark);
            
            /* Voice Component Colors */
            --voice-bg-primary: hsl(var(--info-h), var(--info-s), var(--voice-bg-l));
            --voice-border: hsl(var(--info-h), var(--info-s), var(--voice-border-l));
            --voice-text: hsl(var(--info-h), var(--info-s), var(--voice-text-l));
            
            /* Tag & Component Colors */
            --tag-bg: hsl(var(--info-h), var(--info-s), var(--tag-bg-l));
            --tag-text: hsl(var(--info-h), var(--info-s), var(--tag-text-l));
            --tag-border: hsl(var(--info-h), var(--info-s), var(--tag-border-l));
            --dream-sign-bg: hsl(var(--warning-h), var(--warning-s), var(--dream-sign-bg-l));
            --dream-sign-text: hsl(var(--warning-h), var(--warning-s), var(--dream-sign-text-l));
            --dream-sign-border: hsl(var(--warning-h), var(--warning-s), var(--dream-sign-border-l));
            
            /* Interactive States */
            --input-focus-ring: hsla(var(--primary-h), var(--primary-s), var(--primary-l), 0.2);
            --selection-bg: var(--primary-color);
            --selection-text: var(--text-inverse);
            
            /* Notification Backgrounds */
            --notification-error-bg: hsl(var(--error-h), var(--error-s), var(--notification-error-l));
            --notification-success-bg: hsl(var(--success-h), var(--success-s), var(--notification-success-l));
            --notification-warning-bg: hsl(var(--warning-h), var(--warning-s), var(--notification-warning-l));
            --notification-info-bg: hsl(var(--info-h), var(--info-s), var(--notification-info-l));
        }
        
        /* Shadow definitions using the optimized theme system */
        :root,
        [data-theme='light'],
        [data-theme='dark'] {
            --shadow-sm: 0 1px 2px var(--shadow-color);
            --shadow-md: 0 4px 6px var(--shadow-color);
            --shadow-lg: 0 10px 25px var(--shadow-color);
            --shadow-xl: 0 20px 60px var(--shadow-color-dark);
        }
        
        /* Extra Small Mobile Screens */
        @media (max-width: 480px) {
            body {
                padding: 2px;
            }
            
            .container {
                border-radius: 0;
                margin: 0;
            }
            
            .header {
                padding: 15px 10px;
            }
            
            .main-content,
            .tab-panel:not(#journalTab) {
                padding: 10px;
            }
            
            .controls {
                padding: 10px;
            }
            
            .entry-form,
            .settings-section {
                padding: 15px 10px;
            }
            
            .stats-card {
                padding: 15px 10px;
            }
            
            .voice-tab-content {
                padding: 10px;
            }
            
            /* Extra small screens - compress tabs further */
            .app-tab {
                min-width: 50px;
                padding: 12px 6px;
                font-size: 11px;
            }
        }
        


        
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-subtle);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
            min-height: 100vh;
        }
        
        /* BASE STYLES & LAYOUT COMPONENTS */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* Smooth theme transitions for all elements */
        *,
        *::before,
        *::after {
            transition: background-color 0.3s ease, 
                       color 0.3s ease, 
                       border-color 0.3s ease, 
                       box-shadow 0.3s ease;
        }
        
        /* Preserve faster transitions for interactive elements */
        button,
        .btn,
        input,
        select,
        textarea {
            transition: background-color 0.3s ease, 
                       color 0.3s ease, 
                       border-color 0.3s ease, 
                       box-shadow 0.3s ease,
                       transform 0.2s ease;
        }

        .autocomplete-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-light);
            font-size: 14px;
            transition: background-color 0.2s;
        }
        .autocomplete-item:hover {
            background-color: var(--bg-hover);
        }
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        
        /* Loading States - Consolidated */
        .loading-state, .search-loading, .loading-dreams {
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            background: var(--bg-light);
            border-radius: var(--border-radius);
            margin: 10px 0;
        }
        
        .loading-state.large, .loading-dreams {
            padding: 40px;
            font-style: normal;
        }
        .loading-state.large div:first-child, .loading-dreams div:first-child {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: var(--bg-primary);
            border-radius: var(--border-radius-xl);
            box-shadow: var(--shadow-lg);
            overflow: hidden;
            width: 100%;
            box-sizing: border-box;
        }
        
        .search-loading {
            padding: 20px;
            text-align: center;
            color: #64748b;
            font-style: italic;
            background: #f8fafc;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .loading-dreams {
            padding: 40px;
            text-align: center;
            color: #64748b;
        }
        .loading-dreams div:first-child {
            font-size: 2em;
            margin-bottom: 10px;
        }
        .header {
            background: var(--gradient-primary);
            color: var(--text-inverse);
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }
        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }
        .controls {
            padding: 20px;
            background: var(--bg-light);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        .control-row-break {
            flex-basis: 100%;
            height: 0;
        }
        .search-filter-group {
            display: flex;
            gap: 10px;
            flex: 1;
            min-width: 500px;
        }
        .export-import-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .ai-export-control {
            margin-left: auto;
        }
        
        /* Hide file input completely */
        .file-input,
        input[type="file"].file-input,
        #importFile {
            display: none !important;
            visibility: hidden !important;
            position: absolute !important;
            left: -9999px !important;
        }
        .search-box {
            flex: 2;
            min-width: 150px;
            padding: 12px 15px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border-color 0.3s;
        }
        .filter-select {
            flex: 1;
            min-width: 90px;
            padding: 12px 15px;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 16px;
            background: var(--bg-input);
            color: var(--text-primary);
            cursor: pointer;
            transition: border-color 0.3s;
        }
        .filter-select:focus,
        .search-box:focus {
            outline: none;
            border-color: var(--border-focus);
        }
        /* Button System */
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: var(--border-radius);
            font-size: 14px;
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }
        
        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 6px;
        }
        
        /* Button Colors - Combined selectors */
        .btn-primary, .btn-secondary, .btn-success {
            color: white;
        }
        
        .btn-primary {
            background: var(--primary-color);
        }
        .btn-primary:hover {
            background: var(--primary-hover);
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background: var(--secondary-color);
        }
        .btn-secondary:hover {
            background: var(--secondary-hover);
        }
        
        /* Dark theme specific button hover fixes */
        [data-theme='dark'] .btn-secondary:hover {
            background: #64748b;
        }
        
        .btn-success {
            background: var(--success-color);
            color: var(--text-inverse);
        }
        .btn-success:hover {
            background: var(--success-hover);
            color: var(--text-inverse);
        }
        
        .btn-edit {
            background: var(--info-color);
            color: var(--text-inverse);
        }
        .btn-edit:hover {
            background: #0284c7;
        }
        
        .btn-delete {
            background: var(--error-color);
            color: var(--text-inverse);
        }
        .btn-delete:hover {
            background: var(--error-hover);
        }
        
        .btn-confirm-delete {
            background: var(--error-hover);
            color: var(--text-inverse);
            animation: pulse 0.5s ease-in-out;
        }
        .btn-confirm-delete:hover {
            background: #b91c1c;
        }
        
        .btn-lock {
            background: var(--text-tertiary);
            color: var(--text-inverse);
            padding: 8px 12px;
            font-size: 12px;
        }
        .btn-lock:hover {
            background: var(--text-secondary);
        }
        
        /* Loading States - Consolidated */
        .loading-state {
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            background: var(--bg-light);
            border-radius: var(--border-radius);
            margin: 10px 0;
        }
        
        .loading-state.large {
            padding: 40px;
            font-style: normal;
        }
        .loading-state.large div:first-child {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        /* Notification Messages - Consolidated */
        .notification-message {
            font-size: 14px;
            margin-top: 10px;
            padding: 10px;
            border-radius: var(--border-radius);
            display: none;
            font-weight: var(--font-weight-semibold);
        }
        .notification-message.error {
            color: var(--error-color);
            background: var(--notification-error-bg);
        }
        .notification-message.success {
            color: var(--success-color);
            background: var(--notification-success-bg);
        }
        .notification-message.info {
            color: var(--info-color);
            background: var(--notification-info-bg);
        }
        .notification-message.warning {
            color: var(--warning-color);
            background: var(--notification-warning-bg);
        }
        
        /* FORM COMPONENTS & INTERACTIVE ELEMENTS */
        
        .entry-form {
            background: var(--bg-light);
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 30px;
            border: 2px solid var(--border-color);
        }
        
        /* ==== Inline edit form style ==== */
        .inline-edit-form {
            padding: 8px 12px;
            margin: 0;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
        }
        
        /* Compact spacing for inline edit forms */
        .inline-edit-form .form-group {
            margin-bottom: 12px !important;
        }
        
        .inline-edit-form .form-group label {
            margin-bottom: 4px !important;
            font-size: 14px !important;
        }
        
        .inline-edit-form .form-control {
            padding: 8px 12px !important;
            font-size: 14px !important;
        }
        
        .inline-edit-form .lucid-checkbox {
            margin-bottom: 12px !important;
        }
        
        .inline-edit-form .edit-actions {
            margin-top: 12px;
        }
        .entry-form h3 {
            margin-bottom: 15px;
            color: var(--text-primary);
            font-size: 1.3em;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: var(--font-weight-semibold);
            color: var(--text-primary);
        }
        .form-control {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 16px;
            transition: border-color 0.3s;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
        }
        .form-control:focus {
            outline: none;
            border-color: var(--border-focus);
        }
        
        .form-control::placeholder,
        .search-box::placeholder {
            color: var(--text-tertiary);
            opacity: 1;
        }
        textarea.form-control {
            min-height: 120px;
            resize: vertical;
        }
        .lucid-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 20px;
        }
        .lucid-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #4f46e5;
        }
        .lucid-checkbox label {
            margin: 0;
            font-weight: var(--font-weight-semibold);
            color: var(--text-primary);
            cursor: pointer;
        }
        .dreams-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            margin-left: 20px;
            margin-right: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .dreams-section-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.3em;
        }
        .dreams-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .entries-section {
            margin-left: 20px;
            margin-right: 20px;
        }
        .entries-section h3 {
            margin-bottom: 20px;
            color: var(--text-primary);
            font-size: 1.3em;
        }
        .entry {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            padding: 20px;
            margin-bottom: 20px;
            transition: var(--transition);
        }
        .entry:hover {
            border-color: var(--border-hover);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.1);
        }
        /* Light Theme Lucid Dreams */
        :root .entry.lucid,
        [data-theme='light'] .entry.lucid {
            border-color: var(--success-color);
            background: linear-gradient(135deg, #f0fdf4, var(--bg-secondary));
            position: relative;
        }
        
        /* Dark Theme Lucid Dreams - More prominent override */
        [data-theme='dark'] .entry.lucid {
            border-color: var(--success-color) !important;
            background: linear-gradient(135deg, #0f2e1a, var(--bg-secondary)) !important;
            position: relative;
        }
        
        .entry.lucid::before {
            content: "âœ¨ LUCID";
            position: absolute;
            top: -10px;
            right: 20px;
            background: var(--success-color);
            color: var(--text-inverse);
            padding: 4px 12px;
            border-radius: var(--border-radius-lg);
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.5px;
        }
        
        /* Light Theme Lucid Hover */
        :root .entry.lucid:hover,
        [data-theme='light'] .entry.lucid:hover {
            border-color: var(--success-hover);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
        }
        
        /* Dark Theme Lucid Hover - More prominent */
        [data-theme='dark'] .entry.lucid:hover {
            border-color: var(--success-hover) !important;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3) !important;
            background: linear-gradient(135deg, #1a3d28, var(--bg-secondary)) !important;
        }
        .entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .entry-title {
            font-size: 1.2em;
            font-weight: var(--font-weight-semibold);
            color: var(--text-primary);
            flex: 1;
        }
        .entry-meta {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .entry-date {
            color: var(--text-secondary);
            font-size: 0.9em;
            font-weight: var(--font-weight-medium);
        }
        .entry-actions {
            display: flex;
            gap: 5px;
        }
        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 6px;
        }
        .btn-edit {
            background: #0ea5e9;
            color: white;
        }
        .btn-edit:hover {
            background: #0284c7;
        }
        .btn-delete {
            background: #ef4444;
            color: white;
        }
        .btn-delete:hover {
            background: #dc2626;
        }
        .btn-confirm-delete {
            background: #dc2626;
            color: white;
            animation: pulse 0.5s ease-in-out;
        }
        .btn-confirm-delete:hover {
            background: #b91c1c;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .delete-pending {
            background: var(--notification-warning-bg);
            border-color: var(--warning-color) !important;
        }
        .edit-mode .entry-title-input,
        .edit-mode .entry-content-input {
            width: 100%;
            margin-bottom: 10px;
        }
        .edit-mode .entry-title-input {
            font-size: 1.2em;
            font-weight: 600;
            /* Match main form input styling */
            padding: 12px 15px !important;
            border: 2px solid var(--border-color) !important;
            border-radius: var(--border-radius) !important;
            background: var(--bg-input) !important;
            color: var(--text-primary) !important;
        }
        /* Edit mode should match main form spacing exactly */
        .edit-mode .form-group {
            margin-bottom: 20px !important;
        }
        .edit-mode .form-group label {
            display: block !important;
            margin-bottom: 8px !important;
            font-weight: var(--font-weight-semibold) !important;
            color: var(--text-primary) !important;
            font-size: inherit !important;
        }
        .edit-mode .form-control {
            width: 100% !important;
            padding: 12px 15px !important;
            border: 2px solid var(--border-color) !important;
            border-radius: var(--border-radius) !important;
            font-size: 16px !important;
            transition: border-color 0.3s !important;
            font-family: inherit !important;
            background: var(--bg-input) !important;
            color: var(--text-primary) !important;
        }
        .edit-mode .form-control:focus {
            outline: none !important;
            border-color: var(--border-focus) !important;
        }
        .edit-mode .lucid-checkbox {
            display: flex !important;
            align-items: center !important;
            gap: 8px !important;
            margin-bottom: 20px !important;
        }
        .edit-mode textarea.form-control {
            min-height: 120px !important;
            resize: vertical !important;
        }
        .edit-mode .entry-content-input {
            margin-bottom: 10px !important;
        }
        .edit-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .entry-content {
            color: var(--text-primary);
            line-height: 1.7;
            white-space: pre-wrap;
        }
        .no-entries {
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            padding: 40px;
            background: var(--bg-light);
            border-radius: var(--border-radius-lg);
            border: var(--border-dashed);
        }
        /* Pagination System */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding: 30px 20px;
            margin-top: 20px;
            border-top: 1px solid var(--border-color);
            background: var(--bg-light);
        }
        
        .pagination-info {
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: var(--font-weight-medium);
        }
        
        .pagination-btn, .page-btn {
            border: 2px solid var(--border-color);
            background: var(--bg-secondary);
            border-radius: 6px;
            font-size: 14px;
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: var(--transition);
            color: var(--text-primary);
        }
        
        .pagination-btn {
            padding: 8px 16px;
        }
        
        .page-btn {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .pagination-btn:hover:not(:disabled), .page-btn:hover {
            border-color: var(--border-focus);
            color: var(--primary-color);
        }
        
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .page-btn.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: var(--text-inverse);
        }
        
        .page-numbers {
            display: flex;
            gap: 5px;
        }
        
        .page-ellipsis {
            color: var(--text-secondary);
            font-weight: var(--font-weight-semibold);
            padding: 0 5px;
        }
        
        /* SPECIALIZED COMPONENTS (VOICE, SECURITY, MODALS) */
        
        /* Voice Recording & Tabs */
        .voice-tabs-container {
            background: var(--voice-bg-primary);
            border: 2px solid var(--voice-border);
            border-radius: var(--border-radius-lg);
            margin-bottom: 20px;
            margin-left: 20px;
            margin-right: 20px;
            overflow: hidden;
        }
        
        .voice-tabs {
            display: flex;
            border-bottom: 2px solid var(--voice-border);
            background: var(--bg-secondary);
        }
        
        .voice-tab {
            flex: 1;
            padding: 15px 20px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: var(--transition);
            border-bottom: 3px solid transparent;
        }
        
        .voice-tab:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .voice-tab.active {
            background: var(--voice-bg-primary);
            color: var(--voice-text);
            border-bottom-color: var(--voice-text);
        }
        
        .voice-tab-content {
            padding: 20px;
        }
        
        .voice-tab-panel {
            display: block;
        }
        
        .voice-tab-panel:not(.active) {
            display: none;
        }
        
        .voice-recording-section {
            background: var(--voice-bg-primary);
            border: 2px solid var(--voice-border);
            border-radius: var(--border-radius-lg);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .voice-recording-section h3 {
            color: var(--voice-text);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .voice-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .record-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 140px;
            justify-content: center;
        }
        
        .record-btn.ready {
            background: var(--success-color);
            color: white;
        }
        .record-btn.ready:hover {
            background: var(--success-hover);
            transform: translateY(-2px);
        }
        
        .record-btn.recording {
            background: var(--error-color);
            color: white;
            animation: pulse-record 1.5s ease-in-out infinite;
        }
        
        .record-btn.disabled {
            background: #9ca3af;
            color: #6b7280;
            cursor: not-allowed;
        }
        
        .recording-timer {
            font-family: monospace;
            font-size: 18px;
            font-weight: var(--font-weight-semibold);
            color: var(--error-color);
            background: var(--notification-error-bg);
            padding: 8px 16px;
            border-radius: var(--border-radius);
            border: 2px solid var(--error-color);
        }
        
        .voice-status {
            font-size: 14px;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: var(--font-weight-semibold);
        }
        .voice-status.info {
            background: #dbeafe;
            color: #1d4ed8;
        }
        .voice-status.warning {
            background: #fef3c7;
            color: var(--warning-color);
        }
        .voice-status.error {
            background: #fee2e2;
            color: var(--error-color);
        }
        
        /* Voice Notes */
        .voice-notes-section {
            margin-top: 30px;
            padding: 25px;
            background: var(--bg-light);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
        }
        
        .voice-notes-section h3 {
            color: var(--text-primary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .voice-note {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            transition: var(--transition);
        }
        
        .voice-note:hover {
            border-color: var(--border-hover);
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.1);
        }
        
        .voice-note.delete-pending {
            background: #fef3c7;
            border-color: #f59e0b !important;
        }
        
        .voice-note-info {
            flex: 1;
            min-width: 200px;
        }
        
        .voice-note-title {
            font-weight: var(--font-weight-semibold);
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        
        .voice-note-meta {
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        .voice-note-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            min-width: 300px;
        }
        
        .voice-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .voice-btn.play {
            background: #0ea5e9;
            color: white;
        }
        .voice-btn.play:hover {
            background: #0284c7;
        }
        
        .voice-btn.pause {
            background: #f59e0b;
            color: white;
        }
        .voice-btn.pause:hover {
            background: var(--warning-color);
        }
        
        .voice-btn.transcribe {
            background: #7c3aed;
            color: white;
        }
        .voice-btn.transcribe:hover {
            background: #6d28d9;
        }
        .voice-btn.transcribe:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        
        .voice-btn.download {
            background: var(--success-color);
            color: white;
        }
        .voice-btn.download:hover {
            background: var(--success-hover);
        }
        
        .voice-btn.delete {
            background: var(--error-color);
            color: white;
        }
        .voice-btn.delete:hover {
            background: var(--error-hover);
        }
        
        .voice-progress-container {
            flex: 1;
            min-width: 200px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0 15px;
        }
        
        .voice-progress-bar {
            flex: 1;
            height: 6px;
            background: var(--border-color);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            transition: height 0.2s;
        }
        .voice-progress-bar:hover {
            height: 8px;
        }
        
        .voice-progress-fill {
            height: 100%;
            background: var(--primary-color);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .voice-time-display {
            font-family: monospace;
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 80px;
            text-align: center;
        }
        
        .voice-full-warning {
            background: #fee2e2;
            color: var(--error-color);
            padding: 12px;
            border-radius: var(--border-radius);
            border: 2px solid #fecaca;
            margin-bottom: 15px;
            font-weight: var(--font-weight-semibold);
            text-align: center;
        }
        
        .no-voice-notes {
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            padding: 30px;
            background: var(--bg-light);
            border: var(--border-dashed);
            border-radius: var(--border-radius);
        }
        .pin-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--modal-backdrop);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .pin-container {
            background: var(--bg-elevated);
            padding: 40px;
            border-radius: var(--border-radius-xl);
            box-shadow: var(--shadow-xl);
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        .pin-container h2 {
            color: var(--text-primary);
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        .pin-input {
            width: 100%;
            padding: 15px;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 18px;
            text-align: center;
            letter-spacing: 3px;
            margin-bottom: 20px;
            font-family: monospace;
            background: var(--bg-input);
        }
        .pin-input:focus {
            outline: none;
            border-color: var(--border-focus);
        }
        .pin-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .pin-setup-link {
            color: var(--primary-color);
            text-decoration: underline;
            cursor: pointer;
            font-size: 14px;
            margin-top: 15px;
            display: block;
        }
        .notification-message {
            font-size: 14px;
            margin-top: 10px;
            padding: 10px;
            border-radius: var(--border-radius);
            display: none;
            font-weight: var(--font-weight-semibold);
        }
        .notification-message.error {
            color: var(--error-color);
            background: var(--notification-error-bg);
        }
        .notification-message.success {
            color: var(--success-color);
            background: var(--notification-success-bg);
        }
        .notification-message.info {
            color: var(--info-color);
            background: var(--notification-info-bg);
        }
        .notification-message.warning {
            color: var(--warning-color);
            background: var(--notification-warning-bg);
        }
        
        /* Main App Tabs System */
        .app-tabs {
            display: flex;
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--border-color);
            padding: 0;
            margin: 0;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .app-tabs::-webkit-scrollbar {
            display: none;
        }
        
        .app-tab {
            flex: 1;
            min-width: 80px;
            padding: 16px 12px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-weight: var(--font-weight-semibold);
            font-size: 14px;
            cursor: pointer;
            transition: var(--transition);
            border-bottom: 3px solid transparent;
            white-space: nowrap;
        }
        
        .app-tab:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .app-tab.active {
            background: var(--bg-primary);
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        
        .tab-content-container {
            background: var(--bg-primary);
            min-height: 400px;
            overflow-x: hidden;
        }
        
        .tab-panel {
            display: none;
            width: 100%;
            min-height: 200px;
            background: var(--bg-primary);
            border: 2px solid transparent;
            overflow-x: hidden;
            box-sizing: border-box;
        }
        
        .tab-panel.active {
            display: block;
            border-color: var(--primary-color);
        }
        
        .tab-panel:not(#journalTab) {
            padding: 20px;
        }
        
        /* Stats Tab Styling - Theme-aware */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            padding: 0;
            width: 100%;
            box-sizing: border-box;
        }
        
        .stats-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            padding: 20px;
            text-align: center;
            transition: var(--transition);
            margin-bottom: 15px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .stats-card:hover {
            border-color: var(--border-hover);
            box-shadow: var(--shadow-md);
        }
        
        /* Dark theme fixes for Goals/Advice content boxes */
        [data-theme='dark'] .stats-card {
            background: var(--bg-secondary) !important;
            border-color: var(--border-color) !important;
        }
        
        /* Fix light backgrounds in dynamically created content */
        [data-theme='dark'] div[style*="background: linear-gradient(135deg, #f0f9ff"] {
            background: linear-gradient(135deg, var(--bg-elevated), var(--bg-secondary)) !important;
        }
        
        [data-theme='dark'] div[style*="background: #f8fafc"],
        [data-theme='dark'] div[style*="background: var(--bg-light)"] {
            background: var(--bg-elevated) !important;
        }
        
        [data-theme='dark'] div[style*="background: #f0f9ff"] {
            background: var(--bg-elevated) !important;
        }
        
        [data-theme='dark'] div[style*="background: linear-gradient(135deg, #f0f9ff"] {
            background: linear-gradient(135deg, var(--bg-elevated), var(--bg-secondary)) !important;
        }
        
        .stats-number {
            font-size: 2.5em;
            font-weight: var(--font-weight-semibold);
            color: var(--primary-color);
            margin-bottom: 10px;
        }
        
        .stats-label {
            color: var(--text-secondary);
            font-weight: var(--font-weight-medium);
            margin-bottom: 5px;
        }
        
        .stats-detail {
            color: var(--text-tertiary);
            font-size: 14px;
        }
        
        /* Settings Tab Styling */
        .settings-section {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            padding: 25px;
            margin-bottom: 20px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .settings-section h3 {
            color: var(--text-primary);
            margin-bottom: 15px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .settings-grid {
            padding: 0;
            width: 100%;
            box-sizing: border-box;
        }
        
        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid var(--border-light);
        }
        
        .settings-row:last-child {
            border-bottom: none;
        }
        
        .settings-label {
            flex: 1;
            color: var(--text-primary);
            font-weight: var(--font-weight-medium);
        }
        
        .settings-description {
            color: var(--text-secondary);
            font-size: 14px;
            margin-top: 4px;
        }
        
        .settings-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        /* Mobile Tab Optimizations */
        @media (max-width: 768px) {
            .app-tab {
                min-width: 100px;
                padding: 14px 16px;
                font-size: 14px;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
                padding: 0;
                gap: 15px;
            }
            
            .settings-grid {
                padding: 0;
            }
            
            .settings-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .settings-controls {
                width: 100%;
                justify-content: flex-start;
            }
        }
        
        /* Utility classes for common spacing */
        .text-center { text-align: center; }
        .font-weight-600 { font-weight: 600; }
        .border-radius-8 { border-radius: 8px; }
        .margin-bottom-20 { margin-bottom: 20px; }
        .padding-15 { padding: 15px; }
        .meta-item { display: inline; }
        .tag, .dream-sign {
            display: inline-block;
            padding: 3px 8px;
            margin: 2px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: lowercase;
        }
        .tag {
            background: var(--tag-bg);
            color: var(--tag-text);
            border: 1px solid var(--tag-border);
        }
        .dream-sign {
            background: var(--dream-sign-bg);
            color: var(--dream-sign-text);
            border: 1px solid var(--dream-sign-border);
        }
        .dream-sign::before {
            content: "âš¡ ";
            font-size: 10px;
        }
        .entry-tags {
            margin-top: 8px;
            line-height: 1.4;
        }
        .entry-tags .tag-section {
            display: inline-block;
            margin-right: 12px;
        }
        .entry-tags .tag-label {
            font-size: 11px;
            color: #64748b;
            font-weight: 600;
            margin-right: 4px;
        }
        .tag-input-group {
            position: relative;
        }
        .tag-autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-elevated);
            border: 2px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 var(--border-radius) var(--border-radius);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: var(--shadow-md);
        }
        .autocomplete-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-light);
            font-size: 14px;
            transition: background-color 0.2s;
        }
        .autocomplete-item:hover {
            background-color: var(--bg-hover);
        }
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        .timer-warning {
            background: var(--error-color);
            color: var(--text-inverse);
            padding: 15px 20px;
            text-align: center;
            font-weight: var(--font-weight-semibold);
            font-size: 16px;
            display: none;
            position: relative;
        }
        .timer-warning.active {
            display: block;
        }
        .timer-warning button {
            background: var(--text-inverse);
            color: var(--error-color);
            border: none;
            padding: 5px 15px;
            border-radius: 5px;
            margin-left: 15px;
            cursor: pointer;
            font-weight: var(--font-weight-semibold);
        }
        .timer-warning button:hover {
            background: var(--notification-error-bg);
        }
        .migration-notice {
            background: var(--notification-info-bg);
            color: var(--info-color);
            padding: 15px;
            border-radius: var(--border-radius);
            margin: 20px;
            font-weight: var(--font-weight-semibold);
            text-align: center;
            display: none;
        }
        .voice-recording-section {
            background: var(--voice-bg-primary);
            border: 2px solid var(--voice-border);
            border-radius: var(--border-radius-lg);
            padding: 20px;
            margin-bottom: 20px;
        }
        .voice-recording-section h3 {
            color: var(--voice-text);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .voice-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .record-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 140px;
            justify-content: center;
        }
        .record-btn.ready {
            background: var(--success-color);
            color: var(--text-inverse);
        }
        .record-btn.ready:hover {
            background: var(--success-hover);
            transform: translateY(-2px);
        }
        .record-btn.recording {
            background: var(--error-color);
            color: var(--text-inverse);
            animation: pulse-record 1.5s ease-in-out infinite;
        }
        .record-btn.disabled {
            background: var(--text-muted);
            color: var(--text-tertiary);
            cursor: not-allowed;
        }
        @keyframes pulse-record {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .recording-timer {
            font-family: monospace;
            font-size: 18px;
            font-weight: var(--font-weight-semibold);
            color: var(--error-color);
            background: var(--notification-error-bg);
            padding: 8px 16px;
            border-radius: var(--border-radius);
            border: 2px solid var(--error-color);
        }
        .voice-status {
            font-size: 14px;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: 600;
        }
        .voice-status.info {
            background: var(--notification-info-bg);
            color: var(--info-color);
        }
        .voice-status.warning {
            background: var(--notification-warning-bg);
            color: var(--warning-color);
        }
        
        /* Force dark theme colors for voice status warning */
        [data-theme='dark'] .voice-status.warning {
            background: #78350f !important;
            color: #fde047 !important;
            border: 1px solid #a16207 !important;
        }
        
        /* Target voice status within voice recording section specifically */
        [data-theme='dark'] .voice-recording-section .voice-status.warning,
        [data-theme='dark'] .voice-tab-content .voice-status.warning {
            background: #78350f !important;
            color: #fde047 !important;
            border: 1px solid #a16207 !important;
        }
        
        /* Catch-all for any voice status warning in dark theme */
        [data-theme='dark'] *[class*="voice-status"][class*="warning"],
        [data-theme='dark'] div[class*="voice-status"][class*="warning"] {
            background: #78350f !important;
            color: #fde047 !important;
            border: 1px solid #a16207 !important;
        }
        [data-theme='dark'] body #voiceStatus.voice-status.warning,
        [data-theme='dark'] html body #voiceStatus.voice-status.warning {
            background: #78350f !important;
            color: #fde047 !important;
            border: 1px solid #a16207 !important;
        }
        .voice-status.error {
            background: var(--notification-error-bg);
            color: var(--error-color);
        }
        .voice-notes-section {
            margin-top: 30px;
            padding: 25px;
            background: var(--bg-light);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
        }
        .voice-notes-section h3 {
            color: var(--text-primary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .voice-note {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        @media (max-width: 768px) {
            .voice-note {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            .voice-note-controls {
                min-width: auto;
                justify-content: center;
            }
            .voice-progress-container {
                min-width: auto;
                margin: 0 5px;
            }
            
            /* Voice Tabs Mobile */
            .voice-tab {
                padding: 12px 16px;
                font-size: 14px;
            }
            
            .voice-tab-content {
                padding: 15px;
            }
        }
        .voice-note:hover {
            border-color: #c7d2fe;
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.1);
        }
        .voice-note-info {
            flex: 1;
            min-width: 200px;
        }
        .voice-note-title {
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 4px;
        }
        .voice-note-meta {
            color: #64748b;
            font-size: 14px;
        }
        .voice-note-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            min-width: 300px;
        }
        .voice-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .voice-btn.play {
            background: var(--info-color);
            color: var(--text-inverse);
        }
        .voice-btn.play:hover {
            background: #0284c7;
        }
        .voice-btn.pause {
            background: var(--warning-color);
            color: var(--text-inverse);
        }
        .voice-btn.pause:hover {
            background: #d97706;
        }
        .voice-btn.transcribe {
            background: #7c3aed;
            color: var(--text-inverse);
        }
        .voice-btn.transcribe:hover {
            background: #6d28d9;
        }
        .voice-btn.transcribe:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
        }
        .voice-btn.download {
            background: var(--success-color);
            color: var(--text-inverse);
        }
        .voice-btn.download:hover {
            background: var(--success-hover);
        }
        .voice-btn.delete {
            background: var(--error-color);
            color: var(--text-inverse);
        }
        .voice-btn.delete:hover {
            background: var(--error-hover);
        }
        .voice-progress-container {
            flex: 1;
            min-width: 200px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0 15px;
        }
        .voice-progress-bar {
            flex: 1;
            height: 6px;
            background: var(--border-color);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            transition: height 0.2s;
        }
        .voice-progress-bar:hover {
            height: 8px;
        }
        .voice-progress-fill {
            height: 100%;
            background: var(--primary-color);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }
        .voice-time-display {
            font-family: monospace;
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 80px;
            text-align: center;
        }
        .voice-full-warning {
            background: var(--notification-error-bg);
            color: var(--error-color);
            padding: 12px;
            border-radius: var(--border-radius);
            border: 2px solid var(--error-color);
            margin-bottom: 15px;
            font-weight: var(--font-weight-semibold);
            text-align: center;
        }
        .no-voice-notes {
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            padding: 30px;
            background: var(--bg-light);
            border: var(--border-dashed);
            border-radius: var(--border-radius);
        }
        
        /* RESPONSIVE DESIGN & MOBILE OPTIMIZATION */
        
        /* Mobile Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 20px;
            }
            .header h1 {
                font-size: 2em;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-row-break {
                display: none;
            }
            
            .search-filter-group {
                flex-direction: column;
                min-width: auto;
                gap: 10px;
            }
            
            .search-box, .filter-select {
                min-width: auto;
                flex: none;
            }
            
            .main-content {
                padding: 15px;
                overflow-x: hidden;
                max-width: 100%;
                box-sizing: border-box;
            }
            
            .tab-panel:not(#journalTab) {
                padding: 15px;
            }
            
            .entry-form {
                padding: 15px;
                margin-bottom: 20px;
            }
            
            /* Mobile Form Control Fixes */
            .form-control {
                padding: 10px 12px;
                font-size: 16px;
                width: 100%;
                box-sizing: border-box;
                max-width: 100%;
            }
            
            .form-group {
                margin-bottom: 15px;
            }
            
            .form-group label {
                font-size: 14px;
                margin-bottom: 6px;
            }
            
            .lucid-checkbox {
                margin-bottom: 15px;
            }
            
            textarea.form-control {
                min-height: 100px;
                resize: vertical;
            }
            
            .entry {
                padding: 15px;
            }
            
            .entry-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .entry-meta {
                width: 100%;
                justify-content: space-between;
                align-items: center;
            }
            
            .entry-actions {
                flex-shrink: 0;
            }
            
            .pagination {
                flex-direction: column;
                gap: 15px;
            }
            
            .page-numbers {
                order: -1;
            }
            
            .pagination-btn {
                min-width: 100px;
            }
            
            .security-controls {
                margin-left: 0;
                margin-top: 10px;
                justify-content: center;
            }
            
            .voice-note {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            
            .voice-note-controls {
                min-width: auto;
                justify-content: center;
            }
            
            .voice-progress-container {
                min-width: auto;
                margin: 0 5px;
            }
        }
        
        /* Footer Styles */
        footer {
            background: var(--bg-light);
            border-top: 1px solid var(--border-color);
            padding: 20px;
            margin-top: 40px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        footer div {
            max-width: 800px;
            margin: 0 auto;
        }
        
        footer p {
            margin-bottom: 10px;
        }
        
        footer p:last-child {
            margin: 0;
            font-size: 12px;
            opacity: 0.8;
        }


    </style>
</head>
<body>
    <!-- MAIN APPLICATION STRUCTURE -->
    
    <div class="container">
        <div class="timer-warning" id="timerWarning">
            âš ï¸ <strong>PIN RESET TIMER ACTIVE</strong> - Someone has initiated a PIN reset!
            <span id="timerWarningTime"></span>
            <button data-action="cancel-timer">Cancel Timer</button>
        </div>
        
        <div id="migrationNotice" class="migration-notice">
            ðŸ“¦ Migrating your dreams to improved storage...
        </div>
        
        <div class="header">
            <h1>ðŸŒ™ Dream Journal</h1>
            <p>Capture your dreams and discover patterns for lucid dreaming</p>
        </div>
        
        <!-- Main App Tabs Navigation -->
        <div class="app-tabs">
            <button class="app-tab active" data-action="switch-app-tab" data-tab="journal">
                ðŸ“ Journal
            </button>
            <button class="app-tab" data-action="switch-app-tab" data-tab="goals">
                ðŸŽ¯ Goals
            </button>
            <button class="app-tab" data-action="switch-app-tab" data-tab="stats">
                ðŸ“Š Stats
            </button>
            <button class="app-tab" data-action="switch-app-tab" data-tab="advice">
                ðŸ’¡ Advice
            </button>
            <button class="app-tab" data-action="switch-app-tab" data-tab="settings">
                âš™ï¸ Settings
            </button>
            <button class="app-tab" data-action="switch-app-tab" data-tab="lock" style="display: none;">
                ðŸ”’ Locked
            </button>
        </div>
        
        <!-- Tab Content Container -->
        <div class="tab-content-container">
            <!-- Journal Tab (All existing functionality) -->
            <div id="journalTab" class="tab-panel active">
                <div class="controls">
            <div class="search-filter-group">
                <input type="text" id="searchBox" class="search-box" placeholder="Search dreams by title, content, emotions, tags, or dream signs...">
                <select id="filterSelect" class="filter-select">
                    <option value="all">All Dreams</option>
                    <option value="lucid">Lucid Dreams</option>
                    <option value="non-lucid">Non-Lucid Dreams</option>
                </select>
                <select id="sortSelect" class="filter-select">
                    <option value="newest">Newest First</option>
                    <option value="oldest">Oldest First</option>
                    <option value="lucid-first">Lucid First</option>
                    <option value="longest">Longest First</option>
                </select>
                <select id="limitSelect" class="filter-select">
                    <option value="5">Show 5</option>
                    <option value="10">Show 10</option>
                    <option value="20">Show 20</option>
                    <option value="50">Show 50</option>
                    <option value="endless" selected>Endless</option>
                    <option value="all">Show All</option>
                </select>
            </div>
            <div class="control-row-break"></div>
            <div class="export-import-controls">
                <button data-action="export-dreams" class="btn btn-secondary">Export Dreams</button>
                <button data-action="import-dreams" class="btn btn-secondary">Import Dreams</button>
                <div class="encryption-option" style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="encryptionEnabled" style="width: 16px; height: 16px; accent-color: #4f46e5;">
                    <label for="encryptionEnabled" style="font-size: 14px; font-weight: 600; color: #374151; cursor: pointer;">ðŸ” Password Protected</label>
                </div>
            </div>
            <input type="file" id="importFile" class="file-input" accept=".txt,.enc">
        </div>
        <div class="main-content">
            <div class="entry-form" id="dreamFormFull">
                <h3 data-action="toggle-dream-form" style="cursor: pointer; user-select: none;">
                    ðŸŒ™ Record Your Dream 
                    <span style="font-size: 0.6em; color: var(--text-secondary); font-weight: normal;">(Click to collapse)</span>
                </h3>
                <div class="form-group">
                    <label for="dreamDate">Dream Date & Time</label>
                    <input type="datetime-local" id="dreamDate" class="form-control">
                </div>
                <div class="form-group">
                    <label for="dreamTitle">Dream Title (optional)</label>
                    <input type="text" id="dreamTitle" class="form-control" placeholder="Give your dream a memorable title...">
                </div>
                <div class="form-group">
                    <label for="dreamEmotions">Emotions Experienced</label>
                    <input type="text" id="dreamEmotions" class="form-control" placeholder="e.g., happy, anxious, excited, confused (separate with commas)">
                    <small style="color: var(--text-secondary); font-size: 0.9em; margin-top: 5px; display: block;">
                        Common emotions: happy, sad, anxious, excited, confused, peaceful, scared, angry, joyful, curious
                    </small>
                </div>
                <div class="form-group">
                    <label for="dreamTags">Tags & Themes</label>
                    <div class="tag-input-group">
                        <input type="text" id="dreamTags" class="form-control" placeholder="e.g., family, flying, school, animals (separate with commas)">
                    </div>
                    <small style="color: var(--text-secondary); font-size: 0.9em; margin-top: 5px; display: block;">
                        Tag your dream with themes, people, places, objects, or activities for easy searching
                    </small>
                </div>
                <div class="form-group">
                    <label for="dreamSigns">âš¡ Dream Signs (Lucidity Triggers)</label>
                    <div class="tag-input-group">
                        <input type="text" id="dreamSigns" class="form-control" placeholder="e.g., flying, text-changing, deceased-alive (separate with commas)">
                    </div>
                    <small style="color: var(--warning-color); font-size: 0.9em; margin-top: 5px; display: block;">
                        Elements that could trigger lucidity - track these to improve dream awareness!
                    </small>
                </div>
                <div class="lucid-checkbox">
                    <input type="checkbox" id="isLucid">
                    <label for="isLucid">This was a lucid dream âœ¨</label>
                </div>
                <div class="form-group">
                    <label for="dreamContent">Dream Description</label>
                    <textarea id="dreamContent" class="form-control" placeholder="Describe your dream in as much detail as you can remember..." required></textarea>
                </div>
                <button data-action="save-dream" class="btn btn-primary">Save Dream</button>
            </div>
            
            <!-- Collapsed Form State -->
            <div class="entry-form" id="dreamFormCollapsed" style="display: none;">
                <h3 data-action="toggle-dream-form" style="cursor: pointer; user-select: none;">
                    ðŸ“ Record Your Dream 
                    <span style="font-size: 0.6em; color: var(--text-secondary); font-weight: normal;">(Click to expand)</span>
                </h3>
            </div>
            
            <div class="voice-tabs-container">
                <div class="voice-tabs">
                    <button class="voice-tab active" data-action="switch-voice-tab" data-tab="record">
                        ðŸŽ¤ Record
                    </button>
                    <button class="voice-tab" data-action="switch-voice-tab" data-tab="stored">
                        ðŸŽµ Stored Notes
                    </button>
                </div>
                
                <div class="voice-tab-content">
                    <!-- Record Tab -->
                    <div id="voiceTabRecord" class="voice-tab-panel active">
                        <div class="voice-controls">
                            <button id="recordBtn" data-action="toggle-recording" class="record-btn ready">
                                <span id="recordIcon">ðŸŽ¤</span>
                                <span id="recordText">Start Recording</span>
                            </button>
                            <div id="recordingTimer" class="recording-timer" style="display: none;">0:00</div>
                            <div id="voiceStatus" class="voice-status info">Checking browser capabilities for voice features...</div>
                        </div>
                    </div>
                    
                    <!-- Stored Notes Tab -->
                    <div id="voiceTabStored" class="voice-tab-panel" style="display: none;">
                        <div id="voiceNotesContainer"></div>
                    </div>
                </div>
            </div>
            <div class="dreams-section-header">
                <h3>Your Dreams</h3>
                <div class="dreams-controls">
                    <button data-action="export-ai" class="btn btn-success">Export for AI Analysis</button>
                    <button data-action="toggle-lock" id="lockBtn" class="btn btn-lock" title="Set up a PIN to secure your dreams, then lock the journal">ðŸ”’ Setup & Lock</button>
                </div>
            </div>
            <div class="entries-section">
                <div id="entriesContainer"></div>
                <div id="paginationContainer"></div>
            </div>
        </div>
    </div>
    
    <!-- Footer -->
    <footer style="background: var(--bg-light); border-top: 1px solid var(--border-color); padding: 20px; margin-top: 40px; text-align: center; color: var(--text-secondary); font-size: 14px;">
        <div style="max-width: 800px; margin: 0 auto;">
            <p style="margin-bottom: 10px;">
                <strong>Disclaimer:</strong> This application is for entertainment and personal journaling purposes only. 
                It is not intended to provide medical, psychological, or therapeutic advice. 
                If you have concerns about your sleep, dreams, or mental health, please consult a qualified healthcare professional.
            </p>
            <p style="margin-bottom: 10px; font-size: 12px;">
                Licensed under <a href="https://www.gnu.org/licenses/agpl-3.0.html" target="_blank" style="color: var(--primary-color);">AGPL v3.0</a> | <a href="https://github.com/Webdreamjournal/DreamJournal" target="_blank" style="color: var(--primary-color);">Source Code</a>
            </p>
            <p style="margin: 0; font-size: 12px; opacity: 0.8;">
                Dream Journal v1.26.1 | Not a substitute for professional medical advice
            </p>
        </div>
    </footer>

    <!-- PIN Protection Overlay -->
    <div id="pinOverlay" class="pin-overlay" style="display: none;">
        <div class="pin-container">
            <h2 id="pinTitle">ðŸ”’ Enter PIN</h2>
            <p id="pinMessage">Your dreams are protected. Enter your PIN to access them.</p>
            <input type="password" id="pinInput" class="pin-input" placeholder="Enter PIN" maxlength="6">
            <div class="pin-buttons">
                <button data-action="verify-pin" class="btn btn-primary" id="pinMainBtn">Unlock</button>
                <button data-action="hide-pin-overlay" class="btn btn-secondary" id="cancelPinBtn">Cancel</button>
            </div>
            <div id="pinFeedback" class="notification-message error"></div>
            <div id="pinSuccess" class="notification-message success"></div>
            <div id="pinInfo" class="notification-message info"></div>
            <span data-action="show-pin-setup" class="pin-setup-link" id="pinSetupLink">Setup new PIN</span>
            <span data-action="show-remove-pin" class="pin-setup-link" id="removePinLink" style="display: none;">Remove PIN protection</span>
            <span data-action="show-forgot-pin" class="pin-setup-link" id="forgotPinLink" style="display: none;">Forgot PIN?</span>
        </div>
    </div>

    <script>
        // APPLICATION CONSTANTS & CONFIGURATION
        // Application Constants - Single Source of Truth
        const CONSTANTS = {
            // Voice Recording Limits
            VOICE_STORAGE_LIMIT: 5,
            
            // Security & PIN Constants
            PIN_RESET_HOURS: 72,
            PIN_MIN_LENGTH: 4,
            PIN_MAX_LENGTH: 6,
            PASSWORD_MIN_LENGTH: 4,
            FAILED_PIN_ATTEMPT_LIMIT: 3,
            
            // Cryptography Constants
            CRYPTO_SALT_SIZE: 16,
            CRYPTO_IV_SIZE: 12,
            CRYPTO_PBKDF2_ITERATIONS: 100000,
            CRYPTO_KEY_LENGTH: 256,
            
            // Performance & Debouncing
            DEBOUNCE_SEARCH_MS: 300,
            DEBOUNCE_FILTER_MS: 150,
            DEBOUNCE_SCROLL_MS: 100,
            ENDLESS_SCROLL_THRESHOLD_PX: 500,
            ENDLESS_SCROLL_INCREMENT: 5,
            
            // Data Limits
            MAX_TAGS_PER_DREAM: 20,
            MAX_TAG_LENGTH: 50,
            AI_ANALYSIS_RECENT_LIMIT: 15,
            AI_ANALYSIS_TOTAL_LIMIT: 20,
            AI_ANALYSIS_THRESHOLD: 50,
            LARGE_DATASET_THRESHOLD: 50,
            
            // UI & Autocomplete
            AUTOCOMPLETE_MIN_CHARS: 2,
            AUTOCOMPLETE_MAX_RESULTS: 8,
            DOM_TRAVERSAL_LEVELS: 3,
            TEXT_TRUNCATE_LENGTH: 50,
            
            // Pagination Constants
            PAGINATION_MAX_VISIBLE_PAGES: 7,
            PAGINATION_CURRENT_PAGE_PROXIMITY: 4,
            PAGINATION_ELLIPSIS_THRESHOLD: 3,
            
            // File Size Constants
            BYTES_PER_KB: 1024,
            BYTES_PER_MB: 1048576, // 1024 * 1024
            
            // Database Constants
            DB_VERSION: 2,
            DATETIME_LOCAL_SLICE_LENGTH: 16,
            
            // UI Timing & Durations (milliseconds)
            MESSAGE_DURATION_SHORT: 3000,
            MESSAGE_DURATION_MEDIUM: 5000,
            MESSAGE_DURATION_LONG: 7000,
            MESSAGE_DURATION_EXTENDED: 10000,
            CLEANUP_DELAY_MS: 3000,
            FOCUS_DELAY_MS: 100,
            
            // File & Storage
            BACKUP_UPDATE_DELAY_MS: 100,
            DOWNLOAD_CLEANUP_DELAY_MS: 3000
        };
        
        // GLOBAL VARIABLES & STATE MANAGEMENT (WITH MUTEX PROTECTION)
        
        // Voice recording variables
        let mediaRecorder = null;
        let audioChunks = [];
        let recordingStartTime = null;
        let recordingTimer = null;
        let currentPlayingAudio = null;
        
        // Speech recognition variables
        let speechRecognition = null;
        let recognitionResults = '';
        let isTranscribing = false;
        
        // Performance optimization: Debouncing utilities
        let searchDebounceTimer = null;
        let filterDebounceTimer = null;
        
        // Mutex/Semaphore system for preventing race conditions
        const asyncMutex = {
            displayDreams: { locked: false, queue: [] },
            saveDreams: { locked: false, queue: [] },
            voiceOperations: { locked: false, queue: [] },
            deleteOperations: { locked: false, queue: [] }
        };
        
        // Generic mutex implementation
        async function withMutex(mutexName, operation) {
            const mutex = asyncMutex[mutexName];
            if (!mutex) {
                console.error(`Unknown mutex: ${mutexName}`);
                return operation();
            }
            
            return new Promise((resolve, reject) => {
                const executeOperation = async () => {
                    if (mutex.locked) {
                        mutex.queue.push({ operation, resolve, reject });
                        return;
                    }
                    
                    mutex.locked = true;
                    try {
                        const result = await operation();
                        resolve(result);
                    } catch (error) {
                        reject(error);
                    } finally {
                        mutex.locked = false;
                        
                        // Process next item in queue
                        if (mutex.queue.length > 0) {
                            const next = mutex.queue.shift();
                            setTimeout(() => executeOperation.call(next), 0);
                        }
                    }
                };
                
                executeOperation();
            });
        }
        
        // Endless scroll variables (with proper state management)
        const endlessScrollState = {
            enabled: false,
            loaded: 0,
            loading: false,
            lastScrollTime: 0
        };
        
        let scrollDebounceTimer = null;
        
        // DOM Helper Functions (defined early to be available everywhere)
        
        // Create action button with consistent data attributes
        function createActionButton(action, id, text, className = 'btn', extraAttrs = {}) {
            const attrs = Object.entries(extraAttrs)
                .map(([key, value]) => `${key}="${escapeAttr(value)}"`)
                .join(' ');
            
            const idAttr = id ? `data-${action.includes('dream') ? 'dream' : 'voice-note'}-id="${escapeAttr(id)}"` : '';
            
            return `<button data-action="${action}" ${idAttr} class="${className}" ${attrs}>${text}</button>`;
        }
        
        // Create inline message with consistent styling
        function createInlineMessage(type, text, options = {}) {
            const {
                container = null,
                position = 'top', // 'top' or 'bottom'
                autoHide = true,
                duration = type === 'success' ? 3000 : 5000,
                className = ''
            } = options;
            
            const colors = {
                success: { bg: 'var(--notification-success-bg)', color: 'var(--success-color)' },
                error: { bg: 'var(--notification-error-bg)', color: 'var(--error-color)' },
                warning: { bg: 'var(--notification-warning-bg)', color: 'var(--warning-color)' },
                info: { bg: 'var(--notification-info-bg)', color: 'var(--info-color)' }
            };
            
            const style = colors[type] || colors.info;
            
            const msg = document.createElement('div');
            msg.className = `inline-message ${className}`;
            msg.style.cssText = `
                background: ${style.bg};
                color: ${style.color};
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
                font-weight: 600;
                text-align: center;
            `;
            msg.textContent = text;
            
            if (container) {
                if (position === 'top') {
                    container.insertBefore(msg, container.firstChild);
                } else {
                    container.appendChild(msg);
                }
                
                if (autoHide) {
                    setTimeout(() => {
                        if (msg && msg.parentNode) {
                            msg.remove();
                        }
                    }, duration);
                }
            }
            
            return msg;
        }
        
        // Create meta information display
        function createMetaDisplay(items) {
            return items
                .filter(item => item && item.value)
                .map(item => {
                    if (item.label) {
                        return `<span class="meta-item">${escapeHtml(item.label)}: ${escapeHtml(item.value)}</span>`;
                    } else {
                        return `<span class="meta-item">${escapeHtml(item.value)}</span>`;
                    }
                })
                .join(' â€¢ ');
        }
        
        // HTML escape function to prevent XSS
        function escapeHtml(text) {
            if (text == null) return '';
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }

        // HTML escape for attributes (quotes and special chars)
        function escapeAttr(text) {
            if (text == null) return '';
            return String(text).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        }
        
        // IndexedDB setup
        const DB_NAME = 'DreamJournal';
        const DB_VERSION = CONSTANTS.DB_VERSION; // Increment for voice notes support
        const STORE_NAME = 'dreams';
        const VOICE_STORE_NAME = 'voiceNotes';
        let db = null;
        let storageType = 'memory'; // Track which storage is being used
        
        // In-memory fallback for when storage isn't available
        let memoryStorage = [];
        let memoryVoiceNotes = [];
        let currentPage = 1;
        let deleteTimeouts = {}; // Track delete confirmation timeouts
        let voiceDeleteTimeouts = {}; // Track voice note delete confirmation timeouts
        let isUnlocked = false; // PIN protection state
        let failedPinAttempts = 0; // Track failed PIN attempts
        let isDreamFormCollapsed = false; // Track form collapse state
        let activeVoiceTab = 'record'; // Track active voice tab
        let activeAppTab = 'journal'; // Track active main app tab (journal, goals, stats, advice, settings)
        let isAppLocked = false; // Track if entire app is locked
        let preLockActiveTab = 'journal'; // Remember which tab was active before locking
        
        // THEME MANAGEMENT SYSTEM
        
        // Get current theme from storage or default to dark
        function getCurrentTheme() {
            if (isLocalStorageAvailable()) {
                return localStorage.getItem('dreamJournalTheme') || 'dark';
            }
            return 'dark';
        }
        
        // Store theme preference
        function storeTheme(theme) {
            if (isLocalStorageAvailable()) {
                try {
                    localStorage.setItem('dreamJournalTheme', theme);
                } catch (error) {
                    console.warn('Failed to store theme preference:', error);
                }
            }
        }
        
        // Apply theme to document
        function applyTheme(theme) {
            if (!theme || !['light', 'dark'].includes(theme)) {
                theme = 'dark';
            }
            
            document.documentElement.setAttribute('data-theme', theme);
            
            // Update theme select if it exists
            const themeSelect = document.getElementById('themeSelect');
            if (themeSelect) {
                themeSelect.value = theme;
            }
            
            storeTheme(theme);
        }
        
        // Switch theme
        function switchTheme(newTheme) {
            if (!newTheme || !['light', 'dark'].includes(newTheme)) {
                return;
            }
            
            applyTheme(newTheme);
            
            // Update any visible theme selects
            const themeSelects = document.querySelectorAll('#themeSelect');
            themeSelects.forEach(select => {
                if (select.value !== newTheme) {
                    select.value = newTheme;
                }
            });
            
            // Show feedback specifically in the Appearance settings section
            const appearanceSection = document.querySelector('.settings-section h3');
            let targetContainer = null;
            
            if (appearanceSection && appearanceSection.textContent.includes('Appearance')) {
                targetContainer = appearanceSection.parentElement;
            }
            
            // Fallback to active tab if appearance section not found
            if (!targetContainer) {
                targetContainer = document.querySelector('.tab-panel.active');
            }
            
            if (targetContainer) {
                // Remove any existing theme messages first
                const existingMsg = targetContainer.querySelector('.theme-feedback-message');
                if (existingMsg) {
                    existingMsg.remove();
                }
                
                // Create the message element directly for precise placement
                const msgDiv = document.createElement('div');
                msgDiv.className = 'theme-feedback-message';
                msgDiv.style.cssText = `
                    background: var(--notification-success-bg);
                    color: var(--success-color);
                    padding: 10px 15px;
                    border-radius: var(--border-radius);
                    margin: 10px 0;
                    font-weight: var(--font-weight-semibold);
                    text-align: center;
                    font-size: 14px;
                `;
                msgDiv.textContent = `Switched to ${newTheme} theme!`;
                
                // Insert after the settings description
                const settingsRow = targetContainer.querySelector('.settings-row');
                if (settingsRow) {
                    settingsRow.parentNode.insertBefore(msgDiv, settingsRow.nextSibling);
                } else {
                    // Fallback to beginning of section
                    const h3 = targetContainer.querySelector('h3');
                    if (h3) {
                        h3.parentNode.insertBefore(msgDiv, h3.nextSibling);
                    } else {
                        targetContainer.appendChild(msgDiv);
                    }
                }
                
                // Auto-remove after delay
                setTimeout(() => {
                    if (msgDiv && msgDiv.parentNode) {
                        msgDiv.remove();
                    }
                }, 2000);
            }
        }
        
        // Initialize theme on page load
        function initializeTheme() {
            const savedTheme = getCurrentTheme();
            applyTheme(savedTheme);
        }
        
        // CENTRALIZED ACTION SYSTEM & EVENT DELEGATION
        
        // Extract action context from clicked element
        function extractActionContext(target) {
            let actionElement = target;
            let action = actionElement.dataset.action;
            
            // Find element with data-action (traverse up to 3 levels)
            if (!action) {
                for (let i = 0; i < CONSTANTS.DOM_TRAVERSAL_LEVELS && actionElement.parentElement; i++) {
                    actionElement = actionElement.parentElement;
                    action = actionElement.dataset.action;
                    if (action) {
                        break;
                    }
                }
            }
            
            if (!action) {
                return null;
            }
            
            // Extract all possible data attributes
            return {
                action,
                element: actionElement,
                dreamId: actionElement.dataset.dreamId,
                voiceNoteId: actionElement.dataset.voiceNoteId,
                page: actionElement.dataset.page,
                type: actionElement.dataset.type,
                originalTarget: target
            };
        }
        
        // Comprehensive action map - maps all current actions to their handlers
        const ACTION_MAP = {
            // Main container actions
            'export-dreams': () => exportEntries(),
            'import-dreams': () => document.getElementById('importFile').click(),
            'export-ai': () => exportForAIAnalysis(),
            'toggle-lock': () => toggleLock(), // Always visible, handles PIN setup if needed
            'setup-pin': () => showPinSetup(),
            'process-pin-setup': () => setupPin(),
            'save-dream': () => saveDream(),
            'toggle-recording': () => toggleRecording(),
            'toggle-dream-form': () => toggleDreamForm(),
            'switch-voice-tab': (ctx) => switchVoiceTab(ctx.element.dataset.tab),
            'switch-app-tab': (ctx) => switchAppTab(ctx.element.dataset.tab),
            'switch-theme': (ctx) => switchTheme(ctx.element.value),
            'show-pin-overlay': () => showPinOverlay(),
            'create-from-transcription': (ctx) => createDreamFromTranscription(ctx.voiceNoteId),
            'cancel-timer': () => cancelResetTimer(),
            
            // Password dialog actions (CRITICAL BUG FIX #1)
            'confirm-export-password': () => confirmExportPassword(),
            'cancel-export-password': () => cancelExportPassword(),
            'confirm-import-password': () => confirmImportPassword(),
            'cancel-import-password': () => cancelImportPassword(),
            
            // Voice container actions
            'play-voice': (ctx) => playVoiceNote(ctx.voiceNoteId),
            'pause-voice': (ctx) => pauseVoiceNote(ctx.voiceNoteId),
            'transcribe-voice': (ctx) => transcribeVoiceNote(ctx.voiceNoteId),
            'download-voice': (ctx) => downloadVoiceNote(ctx.voiceNoteId),
            'delete-voice': (ctx) => deleteVoiceNote(ctx.voiceNoteId),
            'confirm-delete-voice': (ctx) => confirmDeleteVoiceNote(ctx.voiceNoteId),
            'seek-audio': (ctx) => seekAudio(ctx.voiceNoteId, ctx.event),
            
            // Entries container actions
            'edit-dream': (ctx) => editDream(ctx.dreamId),
            'delete-dream': (ctx) => deleteDream(ctx.dreamId),
            'confirm-delete': (ctx) => confirmDelete(ctx.dreamId),
            'save-edit': (ctx) => saveDreamEdit(ctx.dreamId),
            'cancel-edit': (ctx) => cancelDreamEdit(ctx.dreamId),
            
            // Pagination actions
            'go-to-page': (ctx) => goToPage(parseInt(ctx.page)),
            
            // Document-level actions (PIN overlay, password dialogs, etc.)
            'verify-pin': () => verifyPin(),
            'hide-pin-overlay': () => hidePinOverlay(),
            'confirm-password': () => confirmPassword(),
            'cancel-password': () => cancelPassword(),
            'show-pin-setup': () => showPinSetup(),
            'show-remove-pin': () => showRemovePin(),
            'show-forgot-pin': () => showForgotPin(),
            'confirm-remove-pin': () => confirmRemovePin(),
            'complete-pin-removal': () => completePinRemoval(),
            'start-title-recovery': () => startTitleRecovery(),
            'verify-dream-titles': () => verifyDreamTitles(),
            'start-timer-recovery': () => startTimerRecovery(),
            'confirm-start-timer': () => confirmStartTimer(),
            'confirm-cancel-timer': () => confirmCancelTimer(),
            'restore-warning-banner': () => restoreWarningBanner(),
            'complete-recovery': () => completeRecovery(),
            'complete-pin-setup': () => completePinSetup(),
            'setup-new-pin': () => setupNewPin(),
            'confirm-new-pin': () => confirmNewPin(),
            
            // Lock screen actions
            'verify-lock-screen-pin': () => verifyLockScreenPin(),
            'show-lock-screen-forgot-pin': () => showLockScreenForgotPin(),
            'start-lock-screen-title-recovery': () => startLockScreenTitleRecovery(),
            'start-lock-screen-timer-recovery': () => startLockScreenTimerRecovery(),
            'return-to-lock-screen': () => returnToLockScreen(),
            'verify-lock-screen-dream-titles': () => verifyLockScreenDreamTitles(),
            'confirm-lock-screen-timer': () => confirmLockScreenTimer()
        };
        
        // Switch main app tabs
        function switchAppTab(tabName) {
            if (!tabName || !['journal', 'goals', 'stats', 'advice', 'settings', 'lock'].includes(tabName)) return;
            
            // Handle lock screen transitions
            if (tabName === 'lock') {
                // Switching TO lock screen
                if (!isAppLocked) {
                    preLockActiveTab = activeAppTab; // Remember current tab
                    isAppLocked = true;
                    hideAllTabButtons();
                }
            } else {
                // Switching FROM lock screen to another tab
                if (isAppLocked) {
                    isAppLocked = false;
                    showAllTabButtons();
                }
            }
            
            // Update the lock tab button visibility based on app state
            const lockTabButton = document.querySelector('.app-tab[data-tab="lock"]');
            if (lockTabButton) {
                if (tabName === 'lock') {
                    // Show lock tab button when on lock screen
                    lockTabButton.style.display = 'block';
                } else {
                    // Hide lock tab button when not on lock screen (users should use lock button instead)
                    lockTabButton.style.display = 'none';
                }
            }
            
            // CRITICAL FIX: Ensure tab container exists with robust fallback
            let tabContainer = document.querySelector('.tab-content-container');
            if (!tabContainer) {
                console.warn('Tab container not found during switchAppTab, attempting to create it');
                
                const containerDiv = document.querySelector('.container');
                const appTabs = document.querySelector('.app-tabs');
                
                if (containerDiv && appTabs) {
                    tabContainer = document.createElement('div');
                    tabContainer.className = 'tab-content-container';
                    tabContainer.style.cssText = `
                        background: var(--bg-primary);
                        min-height: 400px;
                        overflow-x: hidden;
                    `;
                    
                    appTabs.parentNode.insertBefore(tabContainer, appTabs.nextSibling);
                    console.log('Tab container created during switchAppTab');
                } else {
                    console.error('Cannot create tab container - missing DOM elements');
                    return;
                }
            }
            
            // Ensure all tab panels exist
            const requiredTabs = ['journalTab', 'goalsTab', 'statsTab', 'adviceTab', 'settingsTab', 'lockTab'];
            requiredTabs.forEach(tabId => {
                if (!document.getElementById(tabId)) {
                    const tabPanel = document.createElement('div');
                    tabPanel.id = tabId;
                    tabPanel.className = 'tab-panel';
                    
                    if (tabId === 'goalsTab') {
                        tabPanel.innerHTML = `
                            <div class="settings-section">
                                <h3>ðŸŽ¯ Lucid Dreaming Goals</h3>
                                <div class="stats-grid" style="grid-template-columns: 1fr;">
                                    <div class="stats-card" style="text-align: left; background: linear-gradient(135deg, #f0f9ff, var(--bg-secondary));">
                                        <h4 style="color: var(--primary-color); margin-bottom: 15px;">ðŸŒŸ Current Goal: Achieve 3 Lucid Dreams This Month</h4>
                                        <div style="background: var(--bg-light); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                                <span style="font-weight: 600;">Progress:</span>
                                                <span style="color: var(--success-color); font-weight: 600;">2 / 3 Lucid Dreams</span>
                                            </div>
                                            <div style="background: var(--border-color); height: 8px; border-radius: 4px; overflow: hidden;">
                                                <div style="background: var(--success-color); height: 100%; width: 67%; transition: width 0.3s;"></div>
                                            </div>
                                        </div>
                                        <p style="color: var(--text-secondary); margin-bottom: 15px;">You're doing great! Just one more lucid dream to reach your monthly goal.</p>
                                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                            <button class="btn btn-primary btn-small">Update Goal</button>
                                            <button class="btn btn-secondary btn-small">Set New Goal</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="settings-section">
                                <h3>ðŸ“ˆ Goal Categories</h3>
                                <div class="stats-grid">
                                    <div class="stats-card">
                                        <div style="font-size: 2em; margin-bottom: 10px;">ðŸ§ </div>
                                        <div class="stats-label">Dream Recall</div>
                                        <div class="stats-detail">Remember 1 dream daily</div>
                                        <div style="color: var(--success-color); font-weight: 600; margin-top: 10px;">âœ… On Track</div>
                                    </div>
                                    <div class="stats-card">
                                        <div style="font-size: 2em; margin-bottom: 10px;">âœ¨</div>
                                        <div class="stats-label">Lucidity</div>
                                        <div class="stats-detail">3 lucid dreams/month</div>
                                        <div style="color: var(--warning-color); font-weight: 600; margin-top: 10px;">â³ In Progress</div>
                                    </div>
                                    <div class="stats-card">
                                        <div style="font-size: 2em; margin-bottom: 10px;">ðŸ“</div>
                                        <div class="stats-label">Journal Habit</div>
                                        <div class="stats-detail">Write daily for 30 days</div>
                                        <div style="color: var(--primary-color); font-weight: 600; margin-top: 10px;">ðŸ”¥ Day 23/30</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="settings-section">
                                <h3>ðŸŽª Suggested Goals</h3>
                                <div style="display: grid; gap: 15px;">
                                    <div style="background: var(--bg-light); padding: 15px; border-radius: 8px; border-left: 4px solid var(--primary-color);">
                                        <h4 style="margin-bottom: 8px;">ðŸŒ™ Master Reality Checks</h4>
                                        <p style="color: var(--text-secondary); font-size: 14px;">Perform 10 reality checks daily for increased dream awareness</p>
                                    </div>
                                    <div style="background: var(--bg-light); padding: 15px; border-radius: 8px; border-left: 4px solid var(--success-color);">
                                        <h4 style="margin-bottom: 8px;">ðŸŽ­ Practice Dream Control</h4>
                                        <p style="color: var(--text-secondary); font-size: 14px;">Learn to control dream elements like flying or changing scenery</p>
                                    </div>
                                    <div style="background: var(--bg-light); padding: 15px; border-radius: 8px; border-left: 4px solid var(--warning-color);">
                                        <h4 style="margin-bottom: 8px;">ðŸ” Identify Personal Dream Signs</h4>
                                        <p style="color: var(--text-secondary); font-size: 14px;">Track recurring elements that could trigger lucidity</p>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (tabId === 'statsTab') {
                        tabPanel.innerHTML = `
                            <div class="stats-grid">
                                <div class="stats-card">
                                    <div class="stats-number">47</div>
                                    <div class="stats-label">Total Dreams</div>
                                    <div class="stats-detail">Recorded since you started</div>
                                </div>
                                <div class="stats-card">
                                    <div class="stats-number">12</div>
                                    <div class="stats-label">Lucid Dreams</div>
                                    <div class="stats-detail">25.5% of all dreams</div>
                                </div>
                                <div class="stats-card">
                                    <div class="stats-number">8</div>
                                    <div class="stats-label">Voice Notes</div>
                                    <div class="stats-detail">3/5 storage slots used</div>
                                </div>
                            </div>
                        `;
                    } else if (tabId === 'adviceTab') {
                        tabPanel.innerHTML = `
                            <div class="settings-section">
                                <h3>ðŸ’¡ Dream Enhancement Tips</h3>
                                <div style="display: grid; gap: 20px;">
                                    <div style="background: var(--bg-elevated); padding: 20px; border-radius: 12px; border: 2px solid var(--border-color);">
                                        <h4 style="color: var(--primary-color); margin-bottom: 15px;">ðŸŒŸ Today's Tip: Reality Checks</h4>
                                        <p style="margin-bottom: 15px;">Perform reality checks throughout the day by looking at your hands, checking clocks, or reading text twice. This habit will carry into your dreams and trigger lucidity!</p>
                                        <div style="background: var(--bg-light); padding: 12px; border-radius: 6px; font-size: 14px; color: var(--text-secondary);">
                                            ðŸ’¡ <strong>Pro Tip:</strong> Set hourly phone reminders to do reality checks until it becomes automatic.
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="settings-section">
                                <h3>ðŸ“š Lucid Dreaming Techniques</h3>
                                <div class="stats-grid">
                                    <div class="stats-card" style="text-align: left;">
                                        <h4 style="color: var(--success-color); margin-bottom: 10px;">ðŸ”„ MILD Technique</h4>
                                        <p style="font-size: 14px; color: var(--text-secondary); line-height: 1.5;">
                                            <strong>Mnemonic Induction:</strong> As you fall asleep, repeat "Next time I'm dreaming, I'll remember I'm dreaming" while visualizing becoming lucid.
                                        </p>
                                    </div>
                                    <div class="stats-card" style="text-align: left;">
                                        <h4 style="color: var(--warning-color); margin-bottom: 10px;">â° WBTB Method</h4>
                                        <p style="font-size: 14px; color: var(--text-secondary); line-height: 1.5;">
                                            <strong>Wake-Back-to-Bed:</strong> Wake up 4-6 hours after sleep, stay awake for 20-30 minutes thinking about lucid dreaming, then return to sleep.
                                        </p>
                                    </div>
                                    <div class="stats-card" style="text-align: left;">
                                        <h4 style="color: var(--info-color); margin-bottom: 10px;">âœ‹ Reality Checks</h4>
                                        <p style="font-size: 14px; color: var(--text-secondary); line-height: 1.5;">
                                            <strong>Daily Habit:</strong> Check your hands, read text twice, or look at digital clocks. In dreams, these often appear distorted.
                                        </p>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="settings-section">
                                <h3>ðŸ§˜ Sleep Optimization</h3>
                                <div style="display: grid; gap: 15px;">
                                    <div style="background: var(--bg-light); padding: 15px; border-radius: 8px; display: flex; align-items: center; gap: 15px;">
                                        <div style="font-size: 2em;">ðŸ›ï¸</div>
                                        <div>
                                            <h4 style="margin-bottom: 5px;">Sleep Schedule</h4>
                                            <p style="color: var(--text-secondary); font-size: 14px; margin: 0;">Maintain consistent sleep and wake times to improve REM sleep quality and dream recall.</p>
                                        </div>
                                    </div>
                                    <div style="background: var(--bg-light); padding: 15px; border-radius: 8px; display: flex; align-items: center; gap: 15px;">
                                        <div style="font-size: 2em;">ðŸ“±</div>
                                        <div>
                                            <h4 style="margin-bottom: 5px;">Screen Time</h4>
                                            <p style="color: var(--text-secondary); font-size: 14px; margin: 0;">Avoid screens 1 hour before bed. Blue light can disrupt melatonin production and dream intensity.</p>
                                        </div>
                                    </div>
                                    <div style="background: var(--bg-light); padding: 15px; border-radius: 8px; display: flex; align-items: center; gap: 15px;">
                                        <div style="font-size: 2em;">ðŸƒ</div>
                                        <div>
                                            <h4 style="margin-bottom: 5px;">Dream Herbs</h4>
                                            <p style="color: var(--text-secondary); font-size: 14px; margin: 0;">Consider natural supplements like mugwort or galantamine (research first and consult healthcare providers).</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="settings-section">
                                <h3>âš ï¸ Important Reminders</h3>
                                <div style="background: var(--bg-elevated); border: 2px solid var(--border-dark); padding: 15px; border-radius: 8px;">
                                    <p style="color: var(--text-secondary); margin: 0; font-weight: 600;">
                                        ðŸ”¬ <strong>Scientific Approach:</strong> Lucid dreaming techniques work best with consistency and patience. Results typically take 2-4 weeks of regular practice.
                                    </p>
                                </div>
                            </div>
                            
                            <div class="settings-section">
                                <div style="background: var(--bg-subtle); border: 2px solid var(--border-color); padding: 20px; border-radius: 8px; text-align: center;">
                                    <p style="color: var(--text-primary); margin: 0; font-size: 14px; line-height: 1.6;">
                                        <strong>Disclaimer:</strong> This application is for entertainment and personal journaling purposes only. 
                                        It is not intended to provide medical, psychological, or therapeutic advice. 
                                        If you have concerns about your sleep, dreams, or mental health, please consult a qualified healthcare professional.
                                    </p>
                                </div>
                            </div>
                        `;
                    } else if (tabId === 'settingsTab') {
                        // Get current theme to set correct option as selected
                        const currentTheme = getCurrentTheme();
                        const lightSelected = currentTheme === 'light' ? 'selected' : '';
                        const darkSelected = currentTheme === 'dark' ? 'selected' : '';
                        
                        tabPanel.innerHTML = `
                            <div class="settings-section">
                                <h3>ðŸŽ¨ Appearance</h3>
                                <div class="settings-row">
                                    <div>
                                        <div class="settings-label">Theme</div>
                                        <div class="settings-description">Choose your preferred color theme</div>
                                    </div>
                                    <div class="settings-controls">
                                        <select id="themeSelect" class="filter-select" style="min-width: 120px;">
                                            <option value="light" ${lightSelected}>ðŸŒž Light</option>
                                            <option value="dark" ${darkSelected}>ðŸŒ™ Dark</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-section">
                                <h3>ðŸ” Security</h3>
                                <div class="settings-row">
                                    <div>
                                        <div class="settings-label">PIN Protection</div>
                                        <div class="settings-description">Secure your dreams with a PIN code</div>
                                    </div>
                                    <div class="settings-controls">
                                        <button data-action="setup-pin" id="setupPinBtnSettings" class="btn btn-secondary">âš™ï¸ Setup PIN</button>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (tabId === 'lockTab') {
                        // Check if there's an active timer to show instructional text
                        const resetTime = getResetTime();
                        let timerInstructions = '';
                        
                        if (resetTime) {
                            const remainingTime = resetTime - Date.now();
                            if (remainingTime > 0) {
                                const hours = Math.ceil(remainingTime / (1000 * 60 * 60));
                                const days = Math.ceil(hours / 24);
                                
                                let timeDisplay = '';
                                if (days > 1) {
                                    timeDisplay = `${days} days`;
                                } else if (hours > 1) {
                                    timeDisplay = `${hours} hours`;
                                } else {
                                    timeDisplay = 'Less than 1 hour';
                                }
                                
                                timerInstructions = `
                                    <div class="message-base message-info mb-md text-sm">
                                        â° Recovery timer active (${timeDisplay} remaining)<br>
                                        <span class="text-sm font-normal">Press "Forgot PIN?" again when timer expires to unlock</span>
                                    </div>
                                `;
                            }
                        }
                        
                        tabPanel.innerHTML = `
                            <div class="flex-center" style="min-height: 400px;">
                                <div class="card-elevated card-lg text-center max-w-sm w-full shadow-lg">
                                    <div class="text-4xl mb-lg">ðŸ”’</div>
                                    <h2 class="text-primary mb-md text-xl">Journal Locked</h2>
                                    <p class="text-secondary mb-lg line-height-relaxed">
                                        Your dream journal is protected with a PIN. Enter your PIN to access your dreams and all app features.
                                    </p>
                                    ${timerInstructions}
                                    <input type="password" id="lockScreenPinInput" placeholder="Enter PIN" maxlength="6" class="input-pin w-full mb-lg">
                                    <div class="flex-center gap-sm flex-wrap">
                                        <button data-action="verify-lock-screen-pin" class="btn btn-primary">ðŸ”“ Unlock Journal</button>
                                        <button data-action="show-lock-screen-forgot-pin" class="btn btn-secondary">Forgot PIN?</button>
                                    </div>
                                    <div id="lockScreenFeedback" class="mt-md p-sm" style="border-radius: var(--border-radius); display: none;"></div>
                                </div>
                            </div>
                        `;
                    }
                    
                    tabContainer.appendChild(tabPanel);
                }
            });
            
            // Update tab panels
            const tabs = document.querySelectorAll('.tab-panel');
            
            tabs.forEach(tab => {
                const expectedId = tabName + 'Tab';
                if (tab.id === expectedId) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });
            
            // Update tab buttons
            const tabButtons = document.querySelectorAll('.app-tab');
            tabButtons.forEach(button => {
                const buttonTab = button.dataset.tab;
                if (buttonTab === tabName) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
            
            // Show/hide footer based on active tab
            const footer = document.querySelector('footer');
            if (footer) {
                if (tabName === 'journal' && !isAppLocked) {
                    footer.style.display = 'block';
                } else {
                    footer.style.display = 'none';
                }
            }
            
            activeAppTab = tabName;
            
            // Auto-focus PIN input on lock screen
            if (tabName === 'lock') {
                setTimeout(() => {
                    const lockScreenPinInput = document.getElementById('lockScreenPinInput');
                    if (lockScreenPinInput) {
                        lockScreenPinInput.focus();
                    }
                }, CONSTANTS.FOCUS_DELAY_MS);
            }
            
            // Update security controls when switching to journal tab (for consistency)
            if (tabName === 'journal') {
                updateSecurityControls();
            }
            
            // ALWAYS update settings when switching to settings tab (whether new or existing)
            if (tabName === 'settings') {
                setTimeout(() => {
                    updateSecurityControls();
                    
                    // Always update theme select - this fixes the tab switching issue
                    const themeSelect = document.getElementById('themeSelect');
                    if (themeSelect) {
                        const currentTheme = getCurrentTheme();
                        
                        // Update the select value
                        themeSelect.value = currentTheme;
                        
                        // Also update the selected attribute in the DOM
                        themeSelect.querySelectorAll('option').forEach(option => {
                            if (option.value === currentTheme) {
                                option.selected = true;
                                option.setAttribute('selected', 'selected');
                            } else {
                                option.selected = false;
                                option.removeAttribute('selected');
                            }
                        });
                        
                        // Add event listener if not already added
                        if (!themeSelect.hasAttribute('data-listener-added')) {
                            themeSelect.addEventListener('change', function() {
                                switchTheme(this.value);
                            });
                            themeSelect.setAttribute('data-listener-added', 'true');
                        }
                    }
                }, CONSTANTS.FOCUS_DELAY_MS);
            }
        }
        
        // Hide all tab buttons (when locked)
        function hideAllTabButtons() {
            const tabButtons = document.querySelectorAll('.app-tab');
            tabButtons.forEach(button => {
                if (button.dataset.tab !== 'lock') {
                    button.style.display = 'none';
                }
            });
            console.log('Hid all tab buttons except lock tab');
        }
        
        // Show all tab buttons (when unlocked)
        function showAllTabButtons() {
            const tabButtons = document.querySelectorAll('.app-tab');
            tabButtons.forEach(button => {
                if (button.dataset.tab !== 'lock') {
                    button.style.display = 'block';
                }
            });
            console.log('Showed all tab buttons');
        }
        
        // Update stats display
        async function updateStatsDisplay() {
            try {
                const dreams = await loadDreams();
                const voiceNotes = await loadVoiceNotes();
                
                // Basic counts
                const totalDreams = dreams.length;
                const lucidDreams = dreams.filter(d => d.isLucid).length;
                const lucidPercentage = totalDreams > 0 ? ((lucidDreams / totalDreams) * 100).toFixed(1) : 0;
                
                // Recent dreams (last 7 days)
                const weekAgo = new Date();
                weekAgo.setDate(weekAgo.getDate() - 7);
                const recentDreams = dreams.filter(d => new Date(d.timestamp) > weekAgo).length;
                
                // Most common emotion
                const emotions = dreams
                    .map(d => d.emotions)
                    .filter(e => e && e.trim())
                    .flatMap(e => e.split(',').map(em => em.trim().toLowerCase()));
                
                const emotionCounts = {};
                emotions.forEach(emotion => {
                    emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                });
                
                const topEmotion = Object.keys(emotionCounts).length > 0 ? 
                    Object.entries(emotionCounts).sort((a, b) => b[1] - a[1])[0] : null;
                
                // Most common tag
                const tags = dreams
                    .flatMap(d => Array.isArray(d.tags) ? d.tags : [])
                    .filter(t => t && t.trim());
                
                const tagCounts = {};
                tags.forEach(tag => {
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                });
                
                const topTag = Object.keys(tagCounts).length > 0 ? 
                    Object.entries(tagCounts).sort((a, b) => b[1] - a[1])[0] : null;
                
                // Update display elements
                const totalElement = document.getElementById('totalDreamsCount');
                const lucidElement = document.getElementById('lucidDreamsCount');
                const lucidPercentageElement = document.getElementById('lucidPercentage');
                const voiceElement = document.getElementById('voiceNotesCount');
                const voiceDetailElement = document.getElementById('voiceNotesDetail');
                const recentElement = document.getElementById('recentDreamsCount');
                const topEmotionElement = document.getElementById('topEmotionDisplay');
                const topEmotionDetailElement = document.getElementById('topEmotionDetail');
                const topTagElement = document.getElementById('topTagDisplay');
                const topTagDetailElement = document.getElementById('topTagDetail');
                
                if (totalElement) totalElement.textContent = totalDreams;
                if (lucidElement) lucidElement.textContent = lucidDreams;
                if (lucidPercentageElement) lucidPercentageElement.textContent = `${lucidPercentage}% of all dreams`;
                if (voiceElement) voiceElement.textContent = voiceNotes.length;
                if (voiceDetailElement) {
                    const voiceLimit = CONSTANTS.VOICE_STORAGE_LIMIT;
                    voiceDetailElement.textContent = `${voiceNotes.length}/${voiceLimit} storage slots used`;
                }
                if (recentElement) recentElement.textContent = recentDreams;
                
                if (topEmotionElement && topEmotionDetailElement) {
                    if (topEmotion) {
                        topEmotionElement.textContent = topEmotion[0];
                        topEmotionDetailElement.textContent = `Appears in ${topEmotion[1]} dreams`;
                    } else {
                        topEmotionElement.textContent = 'ðŸ˜´';
                        topEmotionDetailElement.textContent = 'No emotions recorded yet';
                    }
                }
                
                if (topTagElement && topTagDetailElement) {
                    if (topTag) {
                        topTagElement.textContent = `#${topTag[0]}`;
                        topTagDetailElement.textContent = `Used in ${topTag[1]} dreams`;
                    } else {
                        topTagElement.textContent = '#dreams';
                        topTagDetailElement.textContent = 'No tags recorded yet';
                    }
                }
                
            } catch (error) {
                console.error('Error updating stats display:', error);
            }
        }
        
        // Sync settings display
        function syncSettingsDisplay() {
            // Sync PIN buttons
            const setupBtnSettings = document.getElementById('setupPinBtnSettings');
            const lockBtnSettings = document.getElementById('lockBtnSettings');
            
            if (setupBtnSettings && lockBtnSettings) {
                if (isPinSetup()) {
                    if (isUnlocked) {
                        lockBtnSettings.style.display = 'inline-block';
                        lockBtnSettings.textContent = 'ðŸ”’ Lock';
                        setupBtnSettings.textContent = 'âš™ï¸ Change PIN';
                    } else {
                        lockBtnSettings.style.display = 'none';
                        setupBtnSettings.textContent = 'âš™ï¸ Change PIN';
                    }
                } else {
                    lockBtnSettings.style.display = 'none';
                    setupBtnSettings.textContent = 'âš™ï¸ Setup PIN';
                }
            }
            
            // Sync encryption checkbox
            const encryptionOriginal = document.getElementById('encryptionEnabled');
            const encryptionSettings = document.getElementById('encryptionEnabledSettings');
            
            if (encryptionOriginal && encryptionSettings) {
                encryptionSettings.checked = encryptionOriginal.checked;
                
                // Add sync event listeners
                encryptionSettings.addEventListener('change', function() {
                    encryptionOriginal.checked = this.checked;
                });
                
                encryptionOriginal.addEventListener('change', function() {
                    encryptionSettings.checked = this.checked;
                });
            }
            
            // Sync theme select - enhanced
            const themeSelect = document.getElementById('themeSelect');
            if (themeSelect) {
                const currentTheme = getCurrentTheme();
                themeSelect.value = currentTheme;
                
                // Double-check the value was set correctly
                if (themeSelect.value !== currentTheme) {
                    console.log('Theme select sync issue, forcing update');
                    setTimeout(() => {
                        const themeSelectDelayed = document.getElementById('themeSelect');
                        if (themeSelectDelayed) {
                            themeSelectDelayed.value = currentTheme;
                        }
                    }, 50);
                }
            }
            
            // Update storage info
            const storageTypeElement = document.getElementById('storageTypeDisplay');
            const storageStatusElement = document.getElementById('storageStatusDisplay');
            
            if (storageTypeElement && storageStatusElement) {
                switch (storageType) {
                    case 'indexeddb':
                        storageTypeElement.textContent = 'Data stored in IndexedDB (recommended)';
                        storageStatusElement.textContent = 'ðŸ’¾ IndexedDB';
                        storageStatusElement.style.color = 'var(--success-color)';
                        break;
                    case 'localstorage':
                        storageTypeElement.textContent = 'Data stored in localStorage';
                        storageStatusElement.textContent = 'ðŸ“± LocalStorage';
                        storageStatusElement.style.color = 'var(--info-color)';
                        break;
                    case 'memory':
                        storageTypeElement.textContent = 'Data stored temporarily in memory only';
                        storageStatusElement.textContent = 'âš ï¸ Memory Only';
                        storageStatusElement.style.color = 'var(--warning-color)';
                        break;
                    default:
                        storageTypeElement.textContent = 'Storage type unknown';
                        storageStatusElement.textContent = 'â“ Unknown';
                        storageStatusElement.style.color = 'var(--text-secondary)';
                }
            }
            
            // Update browser compatibility info
            updateBrowserCompatibilityDisplay();
        }
        
        // Update browser compatibility display in settings
        function updateBrowserCompatibilityDisplay() {
            const voiceCapabilities = getVoiceCapabilities();
            
            // Voice Recording Status
            const voiceRecordingCompatibility = document.getElementById('voiceRecordingCompatibility');
            const voiceRecordingStatus = document.getElementById('voiceRecordingStatus');
            
            if (voiceRecordingCompatibility && voiceRecordingStatus) {
                if (voiceCapabilities.canRecord) {
                    voiceRecordingCompatibility.textContent = 'Your browser supports voice recording';
                    voiceRecordingStatus.textContent = 'âœ… Supported';
                    voiceRecordingStatus.style.color = 'var(--success-color)';
                } else {
                    if (voiceCapabilities.browser.isSafariMobile) {
                        voiceRecordingCompatibility.textContent = 'Safari iOS has limited MediaRecorder support';
                    } else {
                        voiceRecordingCompatibility.textContent = 'Voice recording not supported in this browser';
                    }
                    voiceRecordingStatus.textContent = 'âŒ Not Supported';
                    voiceRecordingStatus.style.color = 'var(--error-color)';
                }
            }
            
            // Transcription Status
            const transcriptionCompatibility = document.getElementById('transcriptionCompatibility');
            const transcriptionStatus = document.getElementById('transcriptionStatus');
            
            if (transcriptionCompatibility && transcriptionStatus) {
                if (voiceCapabilities.canTranscribe) {
                    transcriptionCompatibility.textContent = 'Your browser supports speech transcription';
                    transcriptionStatus.textContent = 'âœ… Supported';
                    transcriptionStatus.style.color = 'var(--success-color)';
                } else {
                    if (voiceCapabilities.browser.isFirefox) {
                        transcriptionCompatibility.textContent = 'Firefox does not support Speech Recognition API';
                    } else if (voiceCapabilities.browser.isSafari) {
                        transcriptionCompatibility.textContent = 'Safari does not support Speech Recognition API';
                    } else {
                        transcriptionCompatibility.textContent = 'Speech Recognition API not available in this browser';
                    }
                    transcriptionStatus.textContent = 'âŒ Not Supported';
                    transcriptionStatus.style.color = 'var(--error-color)';
                }
            }
        }
        
        // Switch voice notes tabs
        function switchVoiceTab(tabName) {
            if (!tabName || (tabName !== 'record' && tabName !== 'stored')) return;
            
            // Update tab buttons
            const tabs = document.querySelectorAll('.voice-tab');
            tabs.forEach(tab => {
                const tabId = tab.dataset.tab;
                if (tabId === tabName) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });
            
            // Update tab panels
            const recordPanel = document.getElementById('voiceTabRecord');
            const storedPanel = document.getElementById('voiceTabStored');
            
            if (recordPanel && storedPanel) {
                if (tabName === 'record') {
                    recordPanel.classList.add('active');
                    recordPanel.style.display = 'block';
                    storedPanel.classList.remove('active');
                    storedPanel.style.display = 'none';
                } else {
                    recordPanel.classList.remove('active');
                    recordPanel.style.display = 'none';
                    storedPanel.classList.add('active');
                    storedPanel.style.display = 'block';
                }
                
                activeVoiceTab = tabName;
            }
        }
        
        // Toggle dream form visibility (collapse/expand)
        function toggleDreamForm() {
            const fullForm = document.getElementById('dreamFormFull');
            const collapsedForm = document.getElementById('dreamFormCollapsed');
            
            if (!fullForm || !collapsedForm) return; // Safety check
            
            if (isDreamFormCollapsed) {
                // Expand: show full form, hide collapsed
                fullForm.style.display = 'block';
                collapsedForm.style.display = 'none';
                isDreamFormCollapsed = false;
            } else {
                // Collapse: hide full form, show collapsed
                fullForm.style.display = 'none';
                collapsedForm.style.display = 'block';
                isDreamFormCollapsed = true;
            }
        }
        function routeAction(context, event = null) {
            const handler = ACTION_MAP[context.action];
            if (handler) {
                try {
                    // Special case: seek-audio needs the event object
                    if (context.action === 'seek-audio') {
                        context.event = event;
                    }
                    
                    // Handle both sync and async functions
                    const result = handler(context);
                    if (result && typeof result.catch === 'function') {
                        // This is a Promise, handle errors
                        result.catch(error => {
                            console.error(`Error executing async action '${context.action}':`, error);
                        });
                    }
                } catch (error) {
                    console.error(`Error executing action '${context.action}':`, error);
                }
            } else {
                console.error(`No handler found for action: ${context.action}`);
            }
        }
        
        // Unified click handler for all containers
        function handleUnifiedClick(event) {
            const context = extractActionContext(event.target);
            if (context) {
                routeAction(context, event);
            }
        }
        // Event Delegation System (Unified)
        function setupEventDelegation() {
            // Unified click handler for all containers and document
            document.addEventListener('click', handleUnifiedClick);
            
            // Unified change handler for select elements and other form controls
            document.addEventListener('change', handleUnifiedChange);
            
            // File input change event (not a click action)
            const importFileInput = document.getElementById('importFile');
            if (importFileInput) {
                importFileInput.addEventListener('change', importEntries);
            }
        }
        
        // Handle change events for form elements with data-action
        function handleUnifiedChange(event) {
            const context = extractActionContext(event.target);
            if (context) {
                routeAction(context, event);
            }
        }
        
        function setupEndlessScroll() {
            // Remove existing scroll listener to prevent duplicates
            removeEndlessScroll();
            
            // Add scroll listener with debouncing
            window.addEventListener('scroll', handleEndlessScroll);
        }
        
        function removeEndlessScroll() {
            window.removeEventListener('scroll', handleEndlessScroll);
        }
        
        function handleEndlessScroll() {
            if (scrollDebounceTimer) {
                clearTimeout(scrollDebounceTimer);
            }
            
            scrollDebounceTimer = setTimeout(async () => {
                if (!endlessScrollState.enabled || endlessScrollState.loading) return;
                
                // Throttle scroll events
                const now = Date.now();
                if (now - endlessScrollState.lastScrollTime < CONSTANTS.DEBOUNCE_SCROLL_MS) return;
                endlessScrollState.lastScrollTime = now;
                
                // Check if user scrolled near bottom
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const windowHeight = window.innerHeight;
                const documentHeight = document.documentElement.scrollHeight;
                
                if (scrollTop + windowHeight >= documentHeight - CONSTANTS.ENDLESS_SCROLL_THRESHOLD_PX) {
                    endlessScrollState.loading = true;
                    
                    try {
                        // Load more dreams
                        const totalDreams = await getFilteredDreamsCount();
                        if (endlessScrollState.loaded < totalDreams) {
                            endlessScrollState.loaded += CONSTANTS.ENDLESS_SCROLL_INCREMENT;
                            await withMutex('displayDreams', () => displayDreamsInternal());
                        }
                    } finally {
                        endlessScrollState.loading = false;
                    }
                }
            }, CONSTANTS.DEBOUNCE_SCROLL_MS);
        }
        
        // UTILITY FUNCTIONS & DOM HELPERS
        function handleMainContainerClick(event) {
            const target = event.target;
            
            // Find the element with data-action (could be the clicked element or a parent)
            let actionElement = target;
            let action = actionElement.dataset.action;
            
            // If clicked element doesn't have data-action, check parents up to 3 levels
            if (!action) {
                for (let i = 0; i < CONSTANTS.DOM_TRAVERSAL_LEVELS && actionElement.parentElement; i++) {
                    actionElement = actionElement.parentElement;
                    action = actionElement.dataset.action;
                    if (action) break;
                }
            }
            
            if (!action) return;
            
            switch (action) {
                case 'export-dreams':
                    exportEntries();
                    break;
                case 'import-dreams':
                    document.getElementById('importFile').click();
                    break;
                case 'export-ai':
                    exportForAIAnalysis();
                    break;
                case 'toggle-lock':
                    toggleLock();
                    break;
                case 'setup-pin':
                    showPinSetup();
                    break;
                case 'save-dream':
                    saveDream();
                    break;
                case 'toggle-recording':
                    toggleRecording();
                    break;
                case 'show-pin-overlay':
                    showPinOverlay();
                    break;
                case 'create-from-transcription':
                    const voiceNoteId = actionElement.dataset.voiceNoteId;
                    if (voiceNoteId) createDreamFromTranscription(voiceNoteId);
                    break;
                case 'cancel-timer':
                    cancelResetTimer();
                    break;
                default:
                    // Unhandled action - silently ignore
            }
        }
        
        // Handle voice container clicks
        function handleVoiceContainerClick(event) {
            const target = event.target;
            
            // Find the element with data-action (could be the clicked element or a parent)
            let actionElement = target;
            let action = actionElement.dataset.action;
            
            if (!action) {
                for (let i = 0; i < CONSTANTS.DOM_TRAVERSAL_LEVELS && actionElement.parentElement; i++) {
                    actionElement = actionElement.parentElement;
                    action = actionElement.dataset.action;
                    if (action) break;
                }
            }
            
            const voiceNoteId = actionElement.dataset.voiceNoteId;
            
            if (!action || !voiceNoteId) return;
            
            switch (action) {
                case 'play-voice':
                    playVoiceNote(voiceNoteId);
                    break;
                case 'pause-voice':
                    pauseVoiceNote(voiceNoteId);
                    break;
                case 'transcribe-voice':
                    transcribeVoiceNote(voiceNoteId);
                    break;
                case 'download-voice':
                    downloadVoiceNote(voiceNoteId);
                    break;
                case 'delete-voice':
                    deleteVoiceNote(voiceNoteId);
                    break;
                case 'seek-audio':
                    seekAudio(voiceNoteId, event);
                    break;
            }
        }
        
        // Handle entries container clicks
        function handleEntriesContainerClick(event) {
            const target = event.target;
            
            // Find the element with data-action (could be the clicked element or a parent)
            let actionElement = target;
            let action = actionElement.dataset.action;
            
            if (!action) {
                for (let i = 0; i < CONSTANTS.DOM_TRAVERSAL_LEVELS && actionElement.parentElement; i++) {
                    actionElement = actionElement.parentElement;
                    action = actionElement.dataset.action;
                    if (action) break;
                }
            }
            
            const dreamId = actionElement.dataset.dreamId;
            
            if (!action) return;
            
            switch (action) {
                case 'edit-dream':
                    if (dreamId) editDream(dreamId);
                    break;
                case 'delete-dream':
                    if (dreamId) deleteDream(dreamId);
                    break;
                case 'confirm-delete':
                    if (dreamId) confirmDelete(dreamId);
                    break;
                case 'save-edit':
                    if (dreamId) saveDreamEdit(dreamId);
                    break;
                case 'cancel-edit':
                    if (dreamId) cancelDreamEdit(dreamId);
                    break;
            }
        }
        
        // Handle pagination clicks
        function handlePaginationClick(event) {
            const target = event.target;
            
            // Find the element with data-action (could be the clicked element or a parent)
            let actionElement = target;
            let action = actionElement.dataset.action;
            
            if (!action) {
                for (let i = 0; i < CONSTANTS.DOM_TRAVERSAL_LEVELS && actionElement.parentElement; i++) {
                    actionElement = actionElement.parentElement;
                    action = actionElement.dataset.action;
                    if (action) break;
                }
            }
            
            if (!action) return;
            
            switch (action) {
                case 'go-to-page':
                    const page = actionElement.dataset.page;
                    if (page) goToPage(parseInt(page));
                    break;
            }
        }
        
        // Handle document-level clicks (for PIN overlay and other global actions)
        function handleDocumentClick(event) {
            const target = event.target;
            
            // Find the element with data-action (could be the clicked element or a parent)
            let actionElement = target;
            let action = actionElement.dataset.action;
            
            if (!action) {
                for (let i = 0; i < CONSTANTS.DOM_TRAVERSAL_LEVELS && actionElement.parentElement; i++) {
                    actionElement = actionElement.parentElement;
                    action = actionElement.dataset.action;
                    if (action) break;
                }
            }
            
            if (!action) return;
            
            switch (action) {
                case 'verify-pin':
                    verifyPin();
                    break;
                case 'hide-pin-overlay':
                    hidePinOverlay();
                    break;
                case 'setup-pin':
                    setupPin();
                    break;
                case 'confirm-password':
                    confirmPassword();
                    break;
                case 'cancel-password':
                    cancelPassword();
                    break;
                case 'show-pin-setup':
                    showPinSetup();
                    break;
                case 'show-remove-pin':
                    showRemovePin();
                    break;
                case 'show-forgot-pin':
                    showForgotPin();
                    break;
                case 'confirm-remove-pin':
                    confirmRemovePin();
                    break;
                case 'complete-pin-removal':
                    completePinRemoval();
                    break;
                case 'start-title-recovery':
                    startTitleRecovery();
                    break;
                case 'verify-dream-titles':
                    verifyDreamTitles();
                    break;
                case 'start-timer-recovery':
                    startTimerRecovery();
                    break;
                case 'confirm-start-timer':
                    confirmStartTimer();
                    break;
                case 'confirm-cancel-timer':
                    confirmCancelTimer();
                    break;
                case 'restore-warning-banner':
                    restoreWarningBanner();
                    break;
                case 'complete-recovery':
                    completeRecovery();
                    break;
                case 'complete-pin-setup':
                    completePinSetup();
                    break;
                case 'setup-new-pin':
                    setupNewPin();
                    break;
                case 'confirm-new-pin':
                    confirmNewPin();
                    break;
            }
        }
        
        function setupEndlessScroll() {
            // Remove existing scroll listener to prevent duplicates
            removeEndlessScroll();
            
            // Add scroll listener with debouncing
            window.addEventListener('scroll', handleEndlessScroll);
        }
        
        function removeEndlessScroll() {
            window.removeEventListener('scroll', handleEndlessScroll);
        }
        
        function handleEndlessScroll() {
            if (scrollDebounceTimer) {
                clearTimeout(scrollDebounceTimer);
            }
            
            scrollDebounceTimer = setTimeout(async () => {
                if (!endlessScrollState.enabled || endlessScrollState.loading) return;
                
                // Throttle scroll events
                const now = Date.now();
                if (now - endlessScrollState.lastScrollTime < CONSTANTS.DEBOUNCE_SCROLL_MS) return;
                endlessScrollState.lastScrollTime = now;
                
                // Check if user scrolled near bottom
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const windowHeight = window.innerHeight;
                const documentHeight = document.documentElement.scrollHeight;
                
                if (scrollTop + windowHeight >= documentHeight - CONSTANTS.ENDLESS_SCROLL_THRESHOLD_PX) {
                    endlessScrollState.loading = true;
                    
                    try {
                        // Load more dreams
                        const totalDreams = await getFilteredDreamsCount();
                        if (endlessScrollState.loaded < totalDreams) {
                            endlessScrollState.loaded += CONSTANTS.ENDLESS_SCROLL_INCREMENT;
                            await withMutex('displayDreams', () => displayDreamsInternal());
                        }
                    } finally {
                        endlessScrollState.loading = false;
                    }
                }
            }, CONSTANTS.DEBOUNCE_SCROLL_MS);
        }
        
        // Generate a random salt
        function generateSalt() {
            return crypto.getRandomValues(new Uint8Array(16));
        }
        
        // Generate a random IV
        function generateIV() {
            return crypto.getRandomValues(new Uint8Array(12));
        }
        
        // Derive key from password using PBKDF2
        async function deriveKey(password, salt) {
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                { name: 'PBKDF2' },
                false,
                ['deriveBits', 'deriveKey']
            );
            
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        }
        
        // Encrypt data with password
        async function encryptData(data, password) {
            try {
                const encoder = new TextEncoder();
                const salt = generateSalt();
                const iv = generateIV();
                const key = await deriveKey(password, salt);
                
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encoder.encode(data)
                );
                
                // Combine salt, iv, and encrypted data
                const result = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
                result.set(salt, 0);
                result.set(iv, salt.length);
                result.set(new Uint8Array(encrypted), salt.length + iv.length);
                
                return result;
            } catch (error) {
                console.error('Encryption error:', error);
                throw new Error('Failed to encrypt data');
            }
        }
        
        // Decrypt data with password
        async function decryptData(encryptedData, password) {
            try {
                const salt = encryptedData.slice(0, 16);
                const iv = encryptedData.slice(16, 28);
                const encrypted = encryptedData.slice(28);
                
                const key = await deriveKey(password, salt);
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encrypted
                );
                
                const decoder = new TextDecoder();
                return decoder.decode(decrypted);
            } catch (error) {
                console.error('Decryption error:', error);
                throw new Error('Failed to decrypt data - incorrect password or corrupted file');
            }
        }

        // Password Dialog Functions for Export/Import (defined early to avoid reference errors)
        
        // Show password input dialog for export (Updated for Event Delegation)
        function showExportPasswordDialog() {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'pin-overlay';
                overlay.innerHTML = `
                    <div class="pin-container">
                        <h2>ðŸ” Set Export Password</h2>
                        <p>Choose a password to encrypt your dream export. This password is not stored - remember it for importing!</p>
                        <input type="password" id="exportPassword" class="pin-input" placeholder="Enter password" maxlength="50">
                        <input type="password" id="exportPasswordConfirm" class="pin-input" placeholder="Confirm password" maxlength="50" style="margin-top: 10px;">
                        <div class="pin-buttons">
                            <button data-action="confirm-export-password" class="btn btn-primary">Encrypt & Export</button>
                            <button data-action="cancel-export-password" class="btn btn-secondary">Cancel</button>
                        </div>
                        <div id="exportPasswordError" class="notification-message error"></div>
                    </div>
                `;
                
                document.body.appendChild(overlay);
                
                // Store resolve function globally for button handlers
                window.exportPasswordResolve = resolve;
                
                setTimeout(() => {
                    document.getElementById('exportPassword').focus();
                }, 100);
                
                // Handle Enter key
                overlay.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        confirmExportPassword();
                    }
                });
            });
        }
        
        // Confirm export password
        function confirmExportPassword() {
            const password = document.getElementById('exportPassword').value;
            const confirm = document.getElementById('exportPasswordConfirm').value;
            const errorDiv = document.getElementById('exportPasswordError');
            
            if (!password || password.length < 4) {
                errorDiv.textContent = 'Password must be at least 4 characters long';
                errorDiv.style.display = 'block';
                return;
            }
            
            if (password !== confirm) {
                errorDiv.textContent = 'Passwords do not match';
                errorDiv.style.display = 'block';
                return;
            }
            
            // Remove overlay and resolve with password
            const overlay = document.querySelector('.pin-overlay');
            if (overlay) overlay.remove();
            
            if (window.exportPasswordResolve) {
                window.exportPasswordResolve(password);
                delete window.exportPasswordResolve;
            }
        }
        
        // Cancel export password
        function cancelExportPassword() {
            const overlay = document.querySelector('.pin-overlay');
            if (overlay) overlay.remove();
            
            if (window.exportPasswordResolve) {
                window.exportPasswordResolve(null);
                delete window.exportPasswordResolve;
            }
        }
        
        // Show password input dialog for import (Updated for Event Delegation)
        function showImportPasswordDialog() {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'pin-overlay';
                overlay.innerHTML = `
                    <div class="pin-container">
                        <h2>ðŸ”“ Enter Import Password</h2>
                        <p>Enter the password used to encrypt this dream export file.</p>
                        <input type="password" id="importPassword" class="pin-input" placeholder="Enter password" maxlength="50">
                        <div class="pin-buttons">
                            <button data-action="confirm-import-password" class="btn btn-primary">Decrypt & Import</button>
                            <button data-action="cancel-import-password" class="btn btn-secondary">Cancel</button>
                        </div>
                        <div id="importPasswordError" class="notification-message error"></div>
                    </div>
                `;
                
                document.body.appendChild(overlay);
                
                // Store resolve function globally for button handlers
                window.importPasswordResolve = resolve;
                
                setTimeout(() => {
                    document.getElementById('importPassword').focus();
                }, 100);
                
                // Handle Enter key
                overlay.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        confirmImportPassword();
                    }
                });
            });
        }
        
        // Confirm import password
        function confirmImportPassword() {
            const password = document.getElementById('importPassword').value;
            const errorDiv = document.getElementById('importPasswordError');
            
            if (!password) {
                errorDiv.textContent = 'Please enter the password';
                errorDiv.style.display = 'block';
                return;
            }
            
            // Remove overlay and resolve with password
            const overlay = document.querySelector('.pin-overlay');
            if (overlay) overlay.remove();
            
            if (window.importPasswordResolve) {
                window.importPasswordResolve(password);
                delete window.importPasswordResolve;
            }
        }
        
        // Cancel import password
        function cancelImportPassword() {
            const overlay = document.querySelector('.pin-overlay');
            if (overlay) overlay.remove();
            
            if (window.importPasswordResolve) {
                window.importPasswordResolve(null);
                delete window.importPasswordResolve;
            }
        }

        // VOICE RECORDING & TRANSCRIPTION SYSTEM
        
        // Create dream entry from transcribed voice note
        // Create dream entry from transcribed voice note
        // Transcribe voice note (create dream entry if transcription exists)
        async function transcribeVoiceNote(voiceNoteId) {
            try {
                const voiceNotes = await loadVoiceNotes();
                const voiceNote = voiceNotes.find(n => n.id === voiceNoteId);
                
                if (!voiceNote) {
                    updateVoiceStatus('Voice note not found', 'error');
                    return;
                }
                
                if (voiceNote.transcription && voiceNote.transcription.trim()) {
                    // Transcription already exists, create dream entry
                    await createDreamFromTranscription(voiceNoteId);
                } else {
                    // No transcription available
                    updateVoiceStatus('No transcription available. Transcription happens during recording when supported.', 'error');
                    
                    // Show helpful message
                    const container = document.querySelector('.main-content');
                    if (container) {
                        const msg = document.createElement('div');
                        msg.style.cssText = `
                            background: var(--notification-warning-bg);
                            color: var(--warning-color);
                            padding: 15px;
                            border-radius: var(--border-radius);
                            margin-bottom: 20px;
                            font-weight: var(--font-weight-semibold);
                            text-align: center;
                        `;
                        msg.innerHTML = `
                            <strong>Transcription Tip:</strong> For automatic transcription, speak clearly during recording. 
                            <br>Transcription works best with clear speech in quiet environments.
                        `;
                        container.insertBefore(msg, container.firstChild);
                        
                        setTimeout(() => {
                            if (msg.parentNode) {
                                msg.remove();
                            }
                        }, 7000);
                    }
                }
                
            } catch (error) {
                console.error('Error transcribing voice note:', error);
                updateVoiceStatus('Failed to process transcription', 'error');
            }
        }
        async function createDreamFromTranscription(voiceNoteId) {
            try {
                const voiceNotes = await loadVoiceNotes();
                const voiceNote = voiceNotes.find(n => n.id === voiceNoteId);
                
                if (!voiceNote || !voiceNote.transcription) {
                    updateVoiceStatus('No transcription available for this voice note', 'error');
                    return;
                }
                
                // Set the current date/time as the dream date
                const now = new Date();
                const dreamDateInput = document.getElementById('dreamDate');
                if (dreamDateInput) {
                    dreamDateInput.value = now.toISOString().slice(0, 16);
                }
                
                // Clear other form fields
                const titleInput = document.getElementById('dreamTitle');
                const emotionsInput = document.getElementById('dreamEmotions');
                const tagsInput = document.getElementById('dreamTags');
                const dreamSignsInput = document.getElementById('dreamSigns');
                const lucidCheckbox = document.getElementById('isLucid');
                const contentInput = document.getElementById('dreamContent');
                
                if (titleInput) titleInput.value = '';
                if (emotionsInput) emotionsInput.value = '';
                if (tagsInput) tagsInput.value = '';
                if (dreamSignsInput) dreamSignsInput.value = '';
                if (lucidCheckbox) lucidCheckbox.checked = false;
                
                // Populate with transcribed text
                if (contentInput) {
                    contentInput.value = voiceNote.transcription;
                    contentInput.focus();
                    contentInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                
                // Show success message
                const container = document.querySelector('.main-content');
                if (container) {
                    createInlineMessage('info', 'Dream entry created from transcription! Review and edit as needed, then save.', {
                        container: container,
                        position: 'top',
                        duration: 5000
                    });
                }
                
            } catch (error) {
                console.error('Error creating dream from transcription:', error);
                updateVoiceStatus('Failed to create dream entry', 'error');
            }
        }

        // Transcribe voice note (create dream entry if transcription exists)
        async function transcribeVoiceNote(voiceNoteId) {
            try {
                const voiceNotes = await loadVoiceNotes();
                const voiceNote = voiceNotes.find(n => n.id === voiceNoteId);
                
                if (!voiceNote) {
                    updateVoiceStatus('Voice note not found', 'error');
                    return;
                }
                
                if (voiceNote.transcription && voiceNote.transcription.trim()) {
                    // Transcription already exists, create dream entry
                    await createDreamFromTranscription(voiceNoteId);
                } else {
                    // No transcription available
                    updateVoiceStatus('No transcription available. Transcription happens during recording when supported.', 'error');
                    
                    // Show helpful message
                    const container = document.querySelector('.main-content');
                    if (container) {
                        const msg = document.createElement('div');
                        msg.style.cssText = `
                            background: var(--notification-warning-bg);
                            color: var(--warning-color);
                            padding: 15px;
                            border-radius: var(--border-radius);
                            margin-bottom: 20px;
                            font-weight: var(--font-weight-semibold);
                            text-align: center;
                        `;
                        msg.innerHTML = `
                            <strong>Transcription Tip:</strong> For automatic transcription, speak clearly during recording. 
                            <br>Transcription works best with clear speech in quiet environments.
                        `;
                        container.insertBefore(msg, container.firstChild);
                        
                        setTimeout(() => {
                            if (msg.parentNode) {
                                msg.remove();
                            }
                        }, 7000);
                    }
                }
                
            } catch (error) {
                console.error('Error transcribing voice note:', error);
                updateVoiceStatus('Failed to process transcription', 'error');
            }
        }
        
        // DREAM DISPLAY & MANAGEMENT FUNCTIONS
        
        // Break down the large displayDreams function into smaller helper functions
        
        // Filter dreams based on search and filter criteria
        function filterDreams(dreams, searchTerm, filterType) {
            if (!Array.isArray(dreams)) return [];
            
            return dreams.filter(dream => {
                if (!dream || typeof dream !== 'object') return false;
                
                try {
                    const title = (dream.title || '').toString().toLowerCase();
                    const content = (dream.content || '').toString().toLowerCase();
                    const emotions = (dream.emotions || '').toString().toLowerCase();
                    const tags = Array.isArray(dream.tags) ? dream.tags.join(' ').toLowerCase() : '';
                    const dreamSigns = Array.isArray(dream.dreamSigns) ? dream.dreamSigns.join(' ').toLowerCase() : '';
                    
                    const matchesSearch = !searchTerm || 
                        title.includes(searchTerm) ||
                        content.includes(searchTerm) ||
                        emotions.includes(searchTerm) ||
                        tags.includes(searchTerm) ||
                        dreamSigns.includes(searchTerm);
                    
                    const matchesFilter = filterType === 'all' || 
                        (filterType === 'lucid' && Boolean(dream.isLucid)) ||
                        (filterType === 'non-lucid' && !Boolean(dream.isLucid));
                    
                    return matchesSearch && matchesFilter;
                } catch (error) {
                    console.error('Error filtering dream:', error);
                    return false;
                }
            });
        }
        
        // Sort dreams based on sort criteria
        function sortDreams(dreams, sortType) {
            if (!Array.isArray(dreams) || dreams.length === 0) return dreams;
            
            try {
                return [...dreams].sort((a, b) => {
                    if (!a || !b) return 0;
                    
                    try {
                        switch (sortType) {
                            case 'oldest':
                                const dateA = new Date(a.timestamp || 0);
                                const dateB = new Date(b.timestamp || 0);
                                if (isNaN(dateA.getTime())) return 1;
                                if (isNaN(dateB.getTime())) return -1;
                                return dateA - dateB;
                            
                            case 'lucid-first':
                                const aLucid = Boolean(a.isLucid);
                                const bLucid = Boolean(b.isLucid);
                                if (aLucid && !bLucid) return -1;
                                if (!aLucid && bLucid) return 1;
                                const dateA2 = new Date(a.timestamp || 0);
                                const dateB2 = new Date(b.timestamp || 0);
                                if (isNaN(dateA2.getTime())) return 1;
                                if (isNaN(dateB2.getTime())) return -1;
                                return dateB2 - dateA2;
                            
                            case 'longest':
                                const contentA = (a.content || '').toString();
                                const contentB = (b.content || '').toString();
                                return contentB.length - contentA.length;
                            
                            case 'newest':
                            default:
                                const dateA3 = new Date(a.timestamp || 0);
                                const dateB3 = new Date(b.timestamp || 0);
                                if (isNaN(dateA3.getTime())) return 1;
                                if (isNaN(dateB3.getTime())) return -1;
                                return dateB3 - dateA3;
                        }
                    } catch (innerError) {
                        console.error('Error in sort comparison:', innerError);
                        return 0;
                    }
                });
            } catch (error) {
                console.error('Sorting error:', error);
                return dreams; // Return unsorted if sorting fails
            }
        }
        
        // Calculate pagination safely
        function calculatePagination(filteredDreams, limitValue) {
            if (!Array.isArray(filteredDreams)) {
                return { paginatedDreams: [], totalPages: 1, totalDreams: 0, itemsPerPage: 1 };
            }
            
            const totalDreams = Math.max(0, filteredDreams.length);
            let itemsPerPage, totalPages, paginatedDreams;
            
            try {
                if (limitValue === 'endless') {
                    endlessScrollState.enabled = true;
                    if (!endlessScrollState.loading) {
                        endlessScrollState.loaded = Math.max(CONSTANTS.ENDLESS_SCROLL_INCREMENT, endlessScrollState.loaded || CONSTANTS.ENDLESS_SCROLL_INCREMENT);
                        setupEndlessScroll();
                    }
                    const safeLoaded = Math.min(endlessScrollState.loaded, totalDreams);
                    paginatedDreams = filteredDreams.slice(0, safeLoaded);
                    totalPages = 1;
                    itemsPerPage = safeLoaded;
                } else if (limitValue === 'all') {
                    endlessScrollState.enabled = false;
                    removeEndlessScroll();
                    itemsPerPage = Math.max(1, totalDreams);
                    totalPages = 1;
                    currentPage = 1;
                    paginatedDreams = filteredDreams;
                } else {
                    endlessScrollState.enabled = false;
                    removeEndlessScroll();
                    itemsPerPage = Math.max(1, Math.min(parseInt(limitValue) || 10, 1000)); // Cap at 1000 for safety
                    totalPages = Math.max(1, Math.ceil(totalDreams / itemsPerPage));
                    
                    // Validate and fix current page with safety bounds
                    currentPage = Math.max(1, Math.min(currentPage, totalPages));
                    
                    const startIndex = Math.max(0, (currentPage - 1) * itemsPerPage);
                    const endIndex = Math.min(startIndex + itemsPerPage, totalDreams);
                    paginatedDreams = filteredDreams.slice(startIndex, endIndex);
                }
                
                return { paginatedDreams, totalPages, totalDreams, itemsPerPage };
            } catch (error) {
                console.error('Error calculating pagination:', error);
                return { 
                    paginatedDreams: filteredDreams.slice(0, 10), 
                    totalPages: 1, 
                    totalDreams: filteredDreams.length, 
                    itemsPerPage: 10 
                };
            }
        }
        
        // Render dream HTML safely
        function renderDreamHTML(dream) {
            if (!dream || typeof dream !== 'object' || !dream.id) return '';
            
            try {
                const safeTitle = escapeHtml((dream.title || 'Untitled Dream').toString());
                const safeContent = escapeHtml((dream.content || '').toString());
                const safeDateString = escapeHtml((dream.dateString || 'Unknown Date').toString());
                const safeEmotions = escapeHtml((dream.emotions || '').toString());
                const isLucid = Boolean(dream.isLucid);
                
                // Format emotions for display
                const emotionsDisplay = safeEmotions ? 
                    `<div class="entry-emotions" style="margin-top: 8px; color: #64748b; font-size: 0.9em;">
                        <span style="font-weight: 600;">Emotions:</span> ${safeEmotions}
                    </div>` : '';
                
                // Format tags and dream signs for display
                const tags = Array.isArray(dream.tags) ? dream.tags : [];
                const dreamSigns = Array.isArray(dream.dreamSigns) ? dream.dreamSigns : [];
                
                let tagsDisplay = '';
                if (tags.length > 0 || dreamSigns.length > 0) {
                    tagsDisplay = '<div class="entry-tags">';
                    
                    if (tags.length > 0) {
                        tagsDisplay += `<div class="tag-section">
                            <span class="tag-label">Tags:</span>
                            ${formatTagsForDisplay(tags)}
                        </div>`;
                    }
                    
                    if (dreamSigns.length > 0) {
                        tagsDisplay += `<div class="tag-section">
                            <span class="tag-label">Dream Signs:</span>
                            ${formatDreamSignsForDisplay(dreamSigns)}
                        </div>`;
                    }
                    
                    tagsDisplay += '</div>';
                }
                
                const safeDreamId = escapeAttr(dream.id.toString());
                
                // Create action buttons using helper
                const actionButtons = `<div class="entry-actions">
                    ${createActionButton('edit-dream', safeDreamId, 'Edit', 'btn btn-edit btn-small')}
                    ${createActionButton('delete-dream', safeDreamId, 'Delete', 'btn btn-delete btn-small')}
                </div>`;
                
                return `
                    <div class="entry ${isLucid ? 'lucid' : ''}" id="entry-${safeDreamId}">
                        <div class="entry-header">
                            <div class="entry-title" id="title-${safeDreamId}">${safeTitle}</div>
                            <div class="entry-meta">
                                <div class="entry-date">${safeDateString}</div>
                                ${actionButtons}
                            </div>
                        </div>
                        ${emotionsDisplay}
                        ${tagsDisplay}
                        <div class="entry-content" id="content-${safeDreamId}">${safeContent}</div>
                    </div>
                `;
            } catch (error) {
                console.error('Error rendering dream HTML:', error);
                return `<div class="entry error">Error displaying dream</div>`;
            }
        }
        
        // Helper function to render pagination HTML
        function renderPaginationHTML(limitValue, totalPages, totalDreams, paginatedDreams) {
            const paginationContainer = document.getElementById('paginationContainer');
            if (!paginationContainer) return;
            
            if (endlessScrollState.enabled) {
                const remainingDreams = totalDreams - endlessScrollState.loaded;
                if (remainingDreams > 0) {
                    paginationContainer.innerHTML = `
                        <div class="pagination-info" style="text-align: center; padding: 20px; color: #64748b;">
                            Showing ${endlessScrollState.loaded} of ${totalDreams} dreams
                            <br><span style="font-size: 14px;">Scroll down to load ${Math.min(5, remainingDreams)} more...</span>
                        </div>
                    `;
                } else {
                    paginationContainer.innerHTML = `
                        <div class="pagination-info" style="text-align: center; padding: 20px; color: #64748b;">
                            All ${totalDreams} dreams loaded
                        </div>
                    `;
                }
            } else if (limitValue !== 'all' && totalPages > 1) {
                paginationContainer.innerHTML = renderPagination(currentPage, totalPages, totalDreams, paginatedDreams.length);
            } else {
                paginationContainer.innerHTML = '';
            }
        }

                
        // TAGS & AUTOCOMPLETE SYSTEM

        // Predefined tags database for autocomplete
        const commonTags = [
            // People
            'family', 'friends', 'strangers', 'children', 'elderly', 'celebrities', 'deceased-relatives',
            // Places
            'home', 'school', 'work', 'nature', 'city', 'ocean', 'mountains', 'forest', 'space', 'underground',
            // Objects
            'animals', 'vehicles', 'technology', 'weapons', 'books', 'mirrors', 'doors', 'stairs', 'bridges',
            // Activities
            'flying', 'running', 'swimming', 'dancing', 'singing', 'fighting', 'escaping', 'searching', 'traveling',
            // Themes
            'adventure', 'romance', 'horror', 'fantasy', 'sci-fi', 'mystery', 'spiritual', 'nostalgic', 'surreal'
        ];

        // Dream signs database - specific elements that commonly trigger lucidity
        const commonDreamSigns = [
            // Reality Check Triggers
            'flying', 'impossible-architecture', 'text-changing', 'clocks-wrong', 'hands-distorted', 'light-switches-broken',
            // Impossible Events
            'teleportation', 'shapeshifting', 'breathing-underwater', 'floating-objects', 'gravity-defying',
            // Dead People/Past
            'deceased-alive', 'childhood-home', 'past-relationships', 'extinct-animals', 'historical-figures',
            // Distorted Reality
            'mirror-reflections-wrong', 'phone-not-working', 'doors-lead-nowhere', 'infinite-rooms', 'size-changes',
            // Recurring Personal Signs
            'teeth-falling-out', 'being-chased', 'cant-run-fast', 'naked-in-public', 'late-for-exam', 'lost-vehicle'
        ];

        // HTML escape function to prevent XSS
        function escapeHtml(text) {
            if (text == null) return '';
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }

        // HTML escape for attributes (quotes and special chars)
        function escapeAttr(text) {
            if (text == null) return '';
            return String(text).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        }

        // Debounced search function for performance
        function debouncedSearch(delay = CONSTANTS.DEBOUNCE_SEARCH_MS) {
            if (searchDebounceTimer) {
                clearTimeout(searchDebounceTimer);
            }
            
            // Show loading state immediately for responsive feedback
            showSearchLoading();
            
            searchDebounceTimer = setTimeout(async () => {
                await resetToPageOne();
                hideSearchLoading();
            }, delay);
        }

        // Debounced filter function for performance  
        function debouncedFilter(delay = CONSTANTS.DEBOUNCE_FILTER_MS) {
            if (filterDebounceTimer) {
                clearTimeout(filterDebounceTimer);
            }
            
            showSearchLoading();
            
            filterDebounceTimer = setTimeout(async () => {
                await resetToPageOne();
                hideSearchLoading();
            }, delay);
        }

        // Show loading indicator for search/filter operations
        function showSearchLoading() {
            const container = document.getElementById('entriesContainer');
            if (container && !asyncMutex.displayDreams.locked) {
                const existingLoader = container.querySelector('.loading-state');
                if (!existingLoader) {
                    const loader = document.createElement('div');
                    loader.className = 'loading-state';
                    loader.innerHTML = 'ðŸ” Searching dreams...';
                    container.appendChild(loader);
                }
            }
        }

        // Hide loading indicator
        function hideSearchLoading() {
            const container = document.getElementById('entriesContainer');
            if (container) {
                const loader = container.querySelector('.loading-state');
                if (loader) {
                    loader.remove();
                }
            }
        }

        // Tag management functions
        // Tag management functions
        function parseTagsFromInput(input) {
            if (!input || typeof input !== 'string') return [];
            
            try {
                return input.split(',')
                    .map(tag => tag.trim().toLowerCase())
                    .filter(tag => tag.length > 0 && tag.length <= CONSTANTS.MAX_TAG_LENGTH) // Add max length validation
                    .filter((tag, index, array) => array.indexOf(tag) === index) // Remove duplicates
                    .slice(0, CONSTANTS.MAX_TAGS_PER_DREAM); // Limit to max tags
            } catch (error) {
                console.error('Error parsing tags:', error);
                return [];
            }
        }

        function formatTagsForDisplay(tags) {
            if (!Array.isArray(tags) || tags.length === 0) return '';
            return tags.map(tag => 
                `<span class="tag">${escapeHtml(tag)}</span>`
            ).join('');
        }

        function formatDreamSignsForDisplay(dreamSigns) {
            if (!Array.isArray(dreamSigns) || dreamSigns.length === 0) return '';
            return dreamSigns.map(sign => 
                `<span class="dream-sign">${escapeHtml(sign)}</span>`
            ).join('');
        }

        // Setup tag autocomplete for form inputs
        function setupTagAutocomplete(inputId, suggestions) {
            const input = document.getElementById(inputId);
            if (!input || !Array.isArray(suggestions)) return;

            // Create autocomplete dropdown
            const dropdown = document.createElement('div');
            dropdown.className = 'tag-autocomplete-dropdown';
            dropdown.style.cssText = `
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: var(--bg-elevated);
                border: 2px solid var(--border-color);
                border-top: none;
                border-radius: 0 0 var(--border-radius) var(--border-radius);
                max-height: 200px;
                overflow-y: auto;
                z-index: 1000;
                display: none;
                box-shadow: var(--shadow-md);
            `;

            // Position container relatively
            if (input.parentElement) {
                input.parentElement.style.position = 'relative';
                input.parentElement.appendChild(dropdown);
            }

            input.addEventListener('input', function() {
                const value = this.value.toLowerCase();
                const lastComma = value.lastIndexOf(',');
                const currentTag = lastComma >= 0 ? value.substring(lastComma + 1).trim() : value.trim();

                if (currentTag.length < CONSTANTS.AUTOCOMPLETE_MIN_CHARS) {
                    dropdown.style.display = 'none';
                    return;
                }

                const matches = suggestions.filter(suggestion => 
                    suggestion.toLowerCase().includes(currentTag) &&
                    !value.includes(suggestion)
                ).slice(0, CONSTANTS.AUTOCOMPLETE_MAX_RESULTS);

                if (matches.length === 0) {
                    dropdown.style.display = 'none';
                    return;
                }

                dropdown.innerHTML = matches.map(match => 
                    `<div class="autocomplete-item" style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #f1f5f9; font-size: 14px;" data-tag="${escapeAttr(match)}">
                        ${escapeHtml(match)}
                    </div>`
                ).join('');

                dropdown.style.display = 'block';

                // Add click handlers
                dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
                    item.addEventListener('click', function() {
                        const tag = this.dataset.tag;
                        if (tag) {
                            const currentValue = input.value;
                            const lastComma = currentValue.lastIndexOf(',');
                            
                            if (lastComma >= 0) {
                                input.value = currentValue.substring(0, lastComma + 1) + ' ' + tag + ', ';
                            } else {
                                input.value = tag + ', ';
                            }
                            
                            dropdown.style.display = 'none';
                            input.focus();
                        }
                    });

                    item.addEventListener('mouseenter', function() {
                        this.style.backgroundColor = 'var(--bg-hover)';
                    });

                    item.addEventListener('mouseleave', function() {
                        this.style.backgroundColor = 'var(--bg-elevated)';
                    });
                });
            });

            // Hide dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!input.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.style.display = 'none';
                }
            });
        }

        // DATA STORAGE & PERSISTENCE LAYER
        
        // Initialize IndexedDB with better upgrade handling
        async function initDB() {
            return new Promise((resolve, reject) => {
                try {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    
                    request.onerror = () => {
                        console.error('IndexedDB error:', request.error);
                        resolve(null); // Resolve with null to allow fallback
                    };
                    
                    request.onsuccess = () => {
                        db = request.result;
                        storageType = 'indexeddb';
                        resolve(db);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const database = event.target.result;
                        const oldVersion = event.oldVersion;
                        
                        if (oldVersion < 1) {
                            // Initial database setup
                            const objectStore = database.createObjectStore(STORE_NAME, { keyPath: 'id' });
                            
                            // Create indexes for common queries
                            objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                            objectStore.createIndex('isLucid', 'isLucid', { unique: false });
                            objectStore.createIndex('title', 'title', { unique: false });
                        }
                        
                        if (oldVersion < 2) {
                            // Add voice notes store
                            const voiceStore = database.createObjectStore(VOICE_STORE_NAME, { keyPath: 'id' });
                            voiceStore.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                        
                        // Future migrations can be added here
                        // if (oldVersion < 3) { ... }
                    };
                } catch (error) {
                    console.error('Failed to open IndexedDB:', error);
                    resolve(null);
                }
            });
        }
        
        // Generate unique ID with better collision resistance
        function generateUniqueId() {
            return `${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
        }

        // Check if localStorage is available
        function isLocalStorageAvailable() {
            try {
                const test = '__localStorage_test__';
                localStorage.setItem(test, test);
                localStorage.removeItem(test);
                return true;
            } catch (e) {
                return false;
            }
        }

        // Check if IndexedDB is available and working
        function isIndexedDBAvailable() {
            return db !== null;
        }

        // Migrate data from localStorage to IndexedDB
        async function migrateFromLocalStorage() {
            if (!isLocalStorageAvailable() || !isIndexedDBAvailable()) {
                return false;
            }
            
            // Check migration flag first to avoid unnecessary work
            const alreadyMigrated = localStorage.getItem('dreamJournalMigrated');
            if (alreadyMigrated === 'true') {
                return false; // Exit early
            }
            
            try {
                const localData = localStorage.getItem('dreamJournalEntries');
                if (!localData) return false;
                
                const dreams = JSON.parse(localData);
                if (!dreams || dreams.length === 0) return false;
                
                // Show migration notice
                const notice = document.getElementById('migrationNotice');
                if (notice) {
                    notice.style.display = 'block';
                }
                
                // Check if IndexedDB already has data (double-check)
                const existingCount = await getIndexedDBCount();
                if (existingCount > 0) {
                    // Already migrated but flag wasn't set
                    localStorage.setItem('dreamJournalMigrated', 'true');
                    if (notice) notice.style.display = 'none';
                    return false;
                }
                
                // Migrate dreams to IndexedDB
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                
                for (const dream of dreams) {
                    // Convert old numeric IDs to new string format for consistency
                    if (typeof dream.id === 'number') {
                        dream.id = dream.id.toString();
                    }
                    // Ensure each dream has a valid ID
                    if (!dream.id) {
                        dream.id = generateUniqueId();
                    }
                    store.add(dream);
                }
                
                await new Promise((resolve, reject) => {
                    transaction.oncomplete = resolve;
                    transaction.onerror = reject;
                });
                
                // Keep localStorage as backup but mark as migrated
                localStorage.setItem('dreamJournalMigrated', 'true');
                
                // Hide migration notice
                setTimeout(() => {
                    if (notice) notice.style.display = 'none';
                }, 1000);
                
                return true;
            } catch (error) {
                console.error('Migration error:', error);
                return false;
            }
        }

        // Get count of dreams in IndexedDB
        async function getIndexedDBCount() {
            if (!isIndexedDBAvailable()) return 0;
            
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    // Transaction-level error handling
                    transaction.onabort = () => {
                        console.error('Count dreams transaction aborted');
                        resolve(0);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Count dreams transaction error:', transaction.error);
                        resolve(0);
                    };
                    
                    const request = store.count();
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => {
                        console.error('Failed to count dreams:', request.error);
                        resolve(0);
                    };
                } catch (error) {
                    console.error('Error creating count dreams transaction:', error);
                    resolve(0);
                }
            });
        }

        // Load dreams from IndexedDB
        async function loadFromIndexedDB() {
            if (!isIndexedDBAvailable()) return null;
            
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    // Transaction-level error handling
                    transaction.onabort = () => {
                        console.error('Load dreams transaction aborted');
                        resolve(null);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Load dreams transaction error:', transaction.error);
                        resolve(null);
                    };
                    
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        const dreams = request.result || [];
                        // Sort by timestamp (newest first)
                        dreams.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                        resolve(dreams);
                    };
                    
                    request.onerror = () => {
                        console.error('Failed to load from IndexedDB:', request.error);
                        resolve(null);
                    };
                } catch (error) {
                    console.error('Error creating load dreams transaction:', error);
                    resolve(null);
                }
            });
        }

        // Save dreams to IndexedDB - improved to use put() for efficiency
        async function saveToIndexedDB(dreams) {
            if (!isIndexedDBAvailable()) return false;
            
            // Validate all dreams before saving
            for (const dream of dreams) {
                if (!validateDreamData(dream)) {
                    console.error('Bulk save failed: invalid dream data detected');
                    return false;
                }
            }
            
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    // Transaction-level error handling
                    transaction.onabort = () => {
                        console.error('Bulk save transaction aborted');
                        resolve(false);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Bulk save transaction error:', transaction.error);
                        resolve(false);
                    };
                    
                    transaction.oncomplete = async () => {
                        // Update localStorage backup after successful IndexedDB operation
                        await updateLocalStorageBackup();
                        resolve(true);
                    };
                    
                    // Use put() which updates existing or adds new records
                    for (const dream of dreams) {
                        store.put(dream);
                    }
                } catch (error) {
                    console.error('Error creating bulk save transaction:', error);
                    resolve(false);
                }
            });
        }
        
        // Add individual dream to IndexedDB
        async function addDreamToIndexedDB(dream) {
            if (!isIndexedDBAvailable()) return false;
            
            // Validate dream data before adding
            if (!validateDreamData(dream)) {
                return false;
            }
            
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    // Transaction-level error handling
                    transaction.onabort = () => {
                        console.error('Add dream transaction aborted');
                        resolve(false);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Add dream transaction error:', transaction.error);
                        resolve(false);
                    };
                    
                    const request = store.add(dream);
                    
                    request.onsuccess = async () => {
                        // Update localStorage backup after successful IndexedDB operation
                        await updateLocalStorageBackup();
                        resolve(true);
                    };
                    request.onerror = (event) => {
                        // Handle ID collision specifically
                        if (event.target.error && event.target.error.name === 'ConstraintError') {
                            // ID collision - fallback to put() instead of add()
                            const putRequest = store.put(dream);
                            putRequest.onsuccess = async () => {
                                await updateLocalStorageBackup();
                                resolve(true);
                            };
                            putRequest.onerror = () => {
                                console.error('Failed to update dream after ID collision:', putRequest.error);
                                resolve(false);
                            };
                        } else {
                            console.error('Failed to add dream:', event.target.error);
                            resolve(false);
                        }
                    };
                } catch (error) {
                    console.error('Error creating add dream transaction:', error);
                    resolve(false);
                }
            });
        }
        
        // Update individual dream in IndexedDB
        async function updateDreamInIndexedDB(dream) {
            if (!isIndexedDBAvailable()) return false;
            
            // Validate dream data before updating
            if (!validateDreamData(dream)) {
                return false;
            }
            
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    // Transaction-level error handling
                    transaction.onabort = () => {
                        console.error('Update dream transaction aborted');
                        resolve(false);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Update dream transaction error:', transaction.error);
                        resolve(false);
                    };
                    
                    const request = store.put(dream);
                    
                    request.onsuccess = async () => {
                        // Update localStorage backup after successful IndexedDB operation
                        await updateLocalStorageBackup();
                        resolve(true);
                    };
                    request.onerror = () => {
                        console.error('Failed to update dream:', request.error);
                        resolve(false);
                    };
                } catch (error) {
                    console.error('Error creating update dream transaction:', error);
                    resolve(false);
                }
            });
        }
        
        // Delete individual dream from IndexedDB
        async function deleteDreamFromIndexedDB(dreamId) {
            if (!isIndexedDBAvailable()) return false;
            
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    // Transaction-level error handling
                    transaction.onabort = () => {
                        console.error('Delete dream transaction aborted');
                        resolve(false);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Delete dream transaction error:', transaction.error);
                        resolve(false);
                    };
                    
                    const request = store.delete(dreamId);
                    
                    request.onsuccess = async () => {
                        // Update localStorage backup after successful IndexedDB operation
                        await updateLocalStorageBackup();
                        resolve(true);
                    };
                    request.onerror = () => {
                        console.error('Failed to delete dream:', request.error);
                        resolve(false);
                    };
                } catch (error) {
                    console.error('Error creating delete dream transaction:', error);
                    resolve(false);
                }
            });
        }

        // Load dreams with fallback chain: IndexedDB -> localStorage -> memory
        async function loadDreams() {
            // Try IndexedDB first
            if (isIndexedDBAvailable()) {
                const indexedDBDreams = await loadFromIndexedDB();
                if (indexedDBDreams !== null && Array.isArray(indexedDBDreams)) {
                    storageType = 'indexeddb';
                    return indexedDBDreams;
                }
            }
            
            // Fallback to localStorage
            if (isLocalStorageAvailable()) {
                try {
                    const dreams = localStorage.getItem('dreamJournalEntries');
                    if (dreams) {
                        const parsedDreams = JSON.parse(dreams);
                        if (Array.isArray(parsedDreams)) {
                            storageType = 'localstorage';
                            return parsedDreams;
                        }
                    }
                } catch (error) {
                    console.error('Failed to load from localStorage:', error);
                }
            }
            
            // Final fallback to memory
            storageType = 'memory';
            return Array.isArray(memoryStorage) ? memoryStorage : [];
        }

        // Save dreams with fallback chain: IndexedDB -> localStorage -> memory (with mutex protection)
        async function saveDreams(dreams) {
            return withMutex('saveDreams', async () => {
                // Try IndexedDB first
                if (isIndexedDBAvailable()) {
                    const saved = await saveToIndexedDB(dreams);
                    if (saved) {
                        storageType = 'indexeddb';
                        // localStorage backup is automatically updated by saveToIndexedDB
                        return;
                    }
                }
                
                // Fallback to localStorage
                if (isLocalStorageAvailable()) {
                    try {
                        localStorage.setItem('dreamJournalEntries', JSON.stringify(dreams));
                        storageType = 'localstorage';
                        return;
                    } catch (error) {
                        console.error('Failed to save to localStorage:', error);
                    }
                }
                
                // Final fallback to memory
                memoryStorage = dreams;
                storageType = 'memory';
                
                // Show warning about data persistence if using memory only
                if (!document.getElementById('storageWarning')) {
                    showStorageWarning();
                }
            });
        }

        // VOICE NOTES STORAGE & PLAYBACK SYSTEM
        
        // Voice Notes Storage Functions
        
        // Load voice notes from IndexedDB
        async function loadVoiceNotesFromIndexedDB() {
            if (!isIndexedDBAvailable()) return null;
            
            return new Promise((resolve) => {
                try {
                    // Check if voice notes store exists
                    if (!db.objectStoreNames.contains(VOICE_STORE_NAME)) {
                        resolve([]);
                        return;
                    }
                    
                    const transaction = db.transaction([VOICE_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(VOICE_STORE_NAME);
                    
                    transaction.onabort = () => {
                        console.error('Load voice notes transaction aborted');
                        resolve([]);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Load voice notes transaction error:', transaction.error);
                        resolve([]);
                    };
                    
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        const voiceNotes = request.result || [];
                        // Sort by timestamp (newest first)
                        voiceNotes.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                        resolve(voiceNotes);
                    };
                    
                    request.onerror = () => {
                        console.error('Failed to load voice notes from IndexedDB:', request.error);
                        resolve([]);
                    };
                } catch (error) {
                    console.error('Error creating load voice notes transaction:', error);
                    resolve([]);
                }
            });
        }
        
        // Load voice notes with fallback
        async function loadVoiceNotes() {
            // Try IndexedDB first
            if (isIndexedDBAvailable()) {
                const indexedDBVoiceNotes = await loadVoiceNotesFromIndexedDB();
                if (indexedDBVoiceNotes !== null && Array.isArray(indexedDBVoiceNotes)) {
                    return indexedDBVoiceNotes;
                }
            }
            
            // Fallback to memory
            return Array.isArray(memoryVoiceNotes) ? memoryVoiceNotes : [];
        }
        
        // Save voice note to IndexedDB
        async function saveVoiceNoteToIndexedDB(voiceNote) {
            if (!isIndexedDBAvailable()) return false;
            
            return new Promise((resolve) => {
                try {
                    // Check if voice notes store exists
                    if (!db.objectStoreNames.contains(VOICE_STORE_NAME)) {
                        resolve(false);
                        return;
                    }
                    
                    const transaction = db.transaction([VOICE_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(VOICE_STORE_NAME);
                    
                    transaction.onabort = () => {
                        console.error('Save voice note transaction aborted');
                        resolve(false);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Save voice note transaction error:', transaction.error);
                        resolve(false);
                    };
                    
                    const request = store.add(voiceNote);
                    
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => {
                        // Handle ID collision
                        if (event.target.error && event.target.error.name === 'ConstraintError') {
                            const putRequest = store.put(voiceNote);
                            putRequest.onsuccess = () => resolve(true);
                            putRequest.onerror = () => resolve(false);
                        } else {
                            console.error('Failed to save voice note:', event.target.error);
                            resolve(false);
                        }
                    };
                } catch (error) {
                    console.error('Error creating save voice note transaction:', error);
                    resolve(false);
                }
            });
        }
        
        // Delete voice note from IndexedDB
        async function deleteVoiceNoteFromIndexedDB(voiceNoteId) {
            if (!isIndexedDBAvailable()) return false;
            
            return new Promise((resolve) => {
                try {
                    // Check if voice notes store exists
                    if (!db.objectStoreNames.contains(VOICE_STORE_NAME)) {
                        resolve(false);
                        return;
                    }
                    
                    const transaction = db.transaction([VOICE_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(VOICE_STORE_NAME);
                    
                    transaction.onabort = () => {
                        console.error('Delete voice note transaction aborted');
                        resolve(false);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Delete voice note transaction error:', transaction.error);
                        resolve(false);
                    };
                    
                    const request = store.delete(voiceNoteId);
                    
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => {
                        console.error('Failed to delete voice note:', request.error);
                        resolve(false);
                    };
                } catch (error) {
                    console.error('Error creating delete voice note transaction:', error);
                    resolve(false);
                }
            });
        }
        
        // Save voice note with fallback (with mutex protection)
        async function saveVoiceNote(voiceNote) {
            return withMutex('voiceOperations', async () => {
                // Try IndexedDB first
                if (isIndexedDBAvailable()) {
                    const saved = await saveVoiceNoteToIndexedDB(voiceNote);
                    if (saved) return true;
                }
                
                // Fallback to memory
                memoryVoiceNotes.unshift(voiceNote);
                // Keep only most recent in memory fallback
                if (memoryVoiceNotes.length > CONSTANTS.VOICE_STORAGE_LIMIT) {
                    memoryVoiceNotes.splice(CONSTANTS.VOICE_STORAGE_LIMIT);
                }
                
                // Show warning about temporary storage
                if (!document.getElementById('voiceStorageWarning')) {
                    showVoiceStorageWarning();
                }
                
                return true;
            });
        }

        // Show warning when voice notes are stored in memory only
        function showVoiceStorageWarning() {
            const container = document.querySelector('.voice-notes-section');
            if (!container) return;
            
            createInlineMessage('warning', 
                'âš ï¸ Voice Storage Notice: Voice recordings are stored temporarily in memory only. They will be lost when you close this tab. Download important recordings!', 
                {
                    container: container,
                    position: 'top',
                    duration: 10000,
                    className: 'voice-storage-warning'
                }
            );
        }

        // VOICE RECORDING INTERFACE & CONTROLS
        
        // Voice Recording Functions
        
        // Enhanced browser detection for voice features
        function getVoiceCapabilities() {
            const hasGetUserMedia = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
            const hasMediaRecorder = !!(window.MediaRecorder);
            const hasSpeechRecognition = !!(window.SpeechRecognition || window.webkitSpeechRecognition);
            
            // Detect browser type
            const userAgent = navigator.userAgent.toLowerCase();
            const isFirefox = userAgent.includes('firefox');
            const isFirefoxMobile = isFirefox && userAgent.includes('mobile');
            const isSafari = userAgent.includes('safari') && !userAgent.includes('chrome');
            const isSafariMobile = isSafari && userAgent.includes('mobile');
            const isChrome = userAgent.includes('chrome') && !userAgent.includes('edg');
            const isEdge = userAgent.includes('edg');
            
            return {
                canRecord: hasGetUserMedia && hasMediaRecorder,
                canTranscribe: hasSpeechRecognition,
                hasGetUserMedia,
                hasMediaRecorder,
                hasSpeechRecognition,
                browser: {
                    isFirefox,
                    isFirefoxMobile,
                    isSafari,
                    isSafariMobile,
                    isChrome,
                    isEdge
                },
                getStatusMessage() {
                    if (this.canRecord && this.canTranscribe) {
                        return { type: 'success', message: 'Full voice recording and transcription support' };
                    } else if (this.canRecord && !this.canTranscribe) {
                        if (isFirefox) {
                            return { type: 'warning', message: 'Voice recording supported, Firefox does not support transcription' };
                        } else if (isSafari) {
                            return { type: 'warning', message: 'Voice recording supported, Safari does not support transcription' };
                        } else {
                            return { type: 'warning', message: 'Voice recording supported, transcription not available' };
                        }
                    } else if (!this.canRecord) {
                        if (isSafariMobile) {
                            return { type: 'error', message: 'Safari iOS has limited voice recording support. Try Chrome or Edge mobile.' };
                        } else {
                            return { type: 'error', message: 'Voice recording not supported in this browser. Try Chrome, Edge, or Firefox.' };
                        }
                    }
                }
            };
        }
        
        // Check if browser supports voice recording
        function isVoiceRecordingSupported() {
            return getVoiceCapabilities().canRecord;
        }
        
        // Check if speech recognition is supported
        function isSpeechRecognitionSupported() {
            return getVoiceCapabilities().canTranscribe;
        }
        
        // Setup speech recognition
        function setupSpeechRecognition() {
            if (!isSpeechRecognitionSupported()) return null;
            
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            
            let finalTranscript = '';
            
            recognition.onresult = (event) => {
                let interimTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                recognitionResults = finalTranscript + interimTranscript;
                updateVoiceStatus(`Recording... "${recognitionResults.slice(-CONSTANTS.TEXT_TRUNCATE_LENGTH)}${recognitionResults.length > CONSTANTS.TEXT_TRUNCATE_LENGTH ? '...' : ''}"`, 'info');
            };
            
            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                // Don't show error for network issues - transcription is optional
                if (event.error !== 'network') {
                    updateVoiceStatus('Recording... (transcription unavailable)', 'info');
                }
            };
            
            recognition.onend = () => {
                isTranscribing = false;
            };
            
            return recognition;
        }
        
        // Format recording duration
        function formatDuration(seconds) {
            if (!seconds || isNaN(seconds) || seconds < 0) return '0:00';
            const safeSeconds = Math.max(0, Math.floor(seconds));
            const mins = Math.floor(safeSeconds / 60);
            const secs = safeSeconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Update recording timer
        function updateRecordingTimer() {
            if (!recordingStartTime || !recordingTimer) {
                // Safety check: if recording should be stopped, clear any lingering timer
                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }
                return;
            }
            
            const elapsed = (Date.now() - recordingStartTime) / 1000;
            const timerElement = document.getElementById('recordingTimer');
            if (timerElement) {
                timerElement.textContent = formatDuration(elapsed);
            }
        }
        
        // Update voice status message
        function updateVoiceStatus(message, type = 'info') {
            const statusElement = document.getElementById('voiceStatus');
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.className = `voice-status ${type}`;
            }
        }
        
        // Update record button state
        async function updateRecordButtonState() {
            const recordBtn = document.getElementById('recordBtn');
            const recordIcon = document.getElementById('recordIcon');
            const recordText = document.getElementById('recordText');
            
            if (!recordBtn || !recordIcon || !recordText) return;
            
            try {
                const voiceNotes = await loadVoiceNotes();
                const voiceCount = voiceNotes.length;
                
                // Check if currently recording
                const isCurrentlyRecording = mediaRecorder && mediaRecorder.state === 'recording';
                
                if (isCurrentlyRecording) {
                    // Don't change button state if recording is in progress
                    return;
                }
                
                if (voiceCount >= CONSTANTS.VOICE_STORAGE_LIMIT) {
                    recordBtn.className = 'record-btn disabled';
                    recordBtn.disabled = true;
                    recordIcon.textContent = 'ðŸš«';
                    recordText.textContent = 'Storage Full';
                    updateVoiceStatus(`Storage full (${voiceCount}/${CONSTANTS.VOICE_STORAGE_LIMIT}). Delete a recording to record new ones.`, 'error');
                } else {
                    recordBtn.className = 'record-btn ready';
                    recordBtn.disabled = false;
                    recordIcon.textContent = 'ðŸŽ¤';
                    recordText.textContent = 'Start Recording';
                    
                    if (voiceCount >= 3) {
                        updateVoiceStatus(`Voice Notes (${voiceCount}/${CONSTANTS.VOICE_STORAGE_LIMIT}) - ${CONSTANTS.VOICE_STORAGE_LIMIT - voiceCount} slot${CONSTANTS.VOICE_STORAGE_LIMIT - voiceCount === 1 ? '' : 's'} remaining`, 'warning');
                    } else {
                        const voiceCapabilities = getVoiceCapabilities();
                        if (voiceCapabilities.canTranscribe) {
                            updateVoiceStatus(`Voice Notes (${voiceCount}/${CONSTANTS.VOICE_STORAGE_LIMIT}) - Recording and transcription supported`, 'info');
                        } else {
                            updateVoiceStatus(`Voice Notes (${voiceCount}/${CONSTANTS.VOICE_STORAGE_LIMIT}) - Recording supported (no transcription)`, 'warning');
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating record button state:', error);
                updateVoiceStatus('Error checking voice note storage', 'error');
            }
        }
        
        // Start voice recording
        async function startRecording() {
            try {
                if (!isVoiceRecordingSupported()) {
                    updateVoiceStatus('Voice recording not supported in this browser', 'error');
                    return;
                }
                
                // Check storage limit
                const voiceNotes = await loadVoiceNotes();
                if (voiceNotes.length >= CONSTANTS.VOICE_STORAGE_LIMIT) {
                    updateVoiceStatus(`Cannot record: Storage full (${CONSTANTS.VOICE_STORAGE_LIMIT}/${CONSTANTS.VOICE_STORAGE_LIMIT}). Delete a recording first.`, 'error');
                    return;
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Determine the best MIME type
                const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' :
                               MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' :
                               MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' :
                               'audio/webm'; // fallback
                
                mediaRecorder = new MediaRecorder(stream, { mimeType });
                
                audioChunks = [];
                recordingStartTime = Date.now();
                recognitionResults = '';
                
                // Setup speech recognition if supported
                if (isSpeechRecognitionSupported()) {
                    speechRecognition = setupSpeechRecognition();
                    if (speechRecognition) {
                        try {
                            isTranscribing = true;
                            speechRecognition.start();
                        } catch (speechError) {
                            console.error('Failed to start speech recognition:', speechError);
                            isTranscribing = false;
                        }
                    }
                }
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data && event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    try {
                        if (audioChunks.length > 0) {
                            const audioBlob = new Blob(audioChunks, { type: mimeType });
                            if (audioBlob.size > 0) {
                                await saveRecording(audioBlob);
                            } else {
                                updateVoiceStatus('Recording failed: No audio data captured', 'error');
                            }
                        } else {
                            updateVoiceStatus('Recording failed: No audio data', 'error');
                        }
                    } catch (saveError) {
                        console.error('Error processing recording:', saveError);
                        updateVoiceStatus('Failed to save recording', 'error');
                    }
                    
                    // Stop all tracks to release microphone
                    if (stream) {
                        stream.getTracks().forEach(track => {
                            try {
                                track.stop();
                            } catch (e) {
                                console.error('Error stopping track:', e);
                            }
                        });
                    }
                };
                
                mediaRecorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event);
                    updateVoiceStatus('Recording error occurred', 'error');
                    stopRecording();
                };
                
                mediaRecorder.start();
                
                // Update UI to recording state
                const recordBtn = document.getElementById('recordBtn');
                const recordIcon = document.getElementById('recordIcon');
                const recordText = document.getElementById('recordText');
                const timerElement = document.getElementById('recordingTimer');
                
                if (recordBtn) recordBtn.className = 'record-btn recording';
                if (recordIcon) recordIcon.textContent = 'â¹ï¸';
                if (recordText) recordText.textContent = 'Stop Recording';
                if (timerElement) timerElement.style.display = 'block';
                
                if (isSpeechRecognitionSupported()) {
                    updateVoiceStatus('Recording with transcription... Speak clearly for best results', 'info');
                } else {
                    updateVoiceStatus('Recording... (transcription not available in this browser)', 'info');
                }
                
                // Start timer
                recordingTimer = setInterval(updateRecordingTimer, 100);
                
            } catch (error) {
                console.error('Error starting recording:', error);
                
                // Handle specific permission errors
                if (error.name === 'NotAllowedError') {
                    updateVoiceStatus('Microphone access denied. Please allow microphone access and try again.', 'error');
                } else if (error.name === 'NotFoundError') {
                    updateVoiceStatus('No microphone found. Please check your audio devices.', 'error');
                } else if (error.name === 'NotSupportedError') {
                    updateVoiceStatus('Audio recording not supported in this browser.', 'error');
                } else {
                    updateVoiceStatus('Failed to start recording. Check microphone permissions.', 'error');
                }
                
                // Ensure UI is reset on error
                await updateRecordButtonState();
            }
        }
        
        // Stop voice recording
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
            
            // Stop speech recognition
            if (speechRecognition && isTranscribing) {
                speechRecognition.stop();
                isTranscribing = false;
            }
            
            // Clear timer
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
            
            // Reset UI elements
            const recordBtn = document.getElementById('recordBtn');
            const recordIcon = document.getElementById('recordIcon');
            const recordText = document.getElementById('recordText');
            const timerElement = document.getElementById('recordingTimer');
            
            // Reset button to ready state
            if (recordBtn) recordBtn.className = 'record-btn ready';
            if (recordIcon) recordIcon.textContent = 'ðŸŽ¤';
            if (recordText) recordText.textContent = 'Start Recording';
            
            // Hide and reset timer
            if (timerElement) {
                timerElement.style.display = 'none';
                timerElement.textContent = '0:00';
            }
            
            recordingStartTime = null;
        }
        
        // Toggle recording state
        async function toggleRecording() {
            console.log('Toggle recording called'); // Debug log
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                stopRecording();
            } else {
                await startRecording();
            }
        }
        
        // Save completed recording
        async function saveRecording(audioBlob) {
            try {
                if (!audioBlob || audioBlob.size === 0) {
                    throw new Error('Invalid audio data');
                }
                
                const now = new Date();
                const duration = recordingStartTime ? (Date.now() - recordingStartTime) / 1000 : 0;
                
                const voiceNote = {
                    id: `voice_${now.getTime()}_${Math.random().toString(36).slice(2, 11)}`,
                    audioBlob: audioBlob,
                    timestamp: now.toISOString(),
                    duration: Math.round(Math.max(0, duration)),
                    title: `Voice Note ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`,
                    dateString: now.toLocaleDateString('en-AU', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    }),
                    size: audioBlob.size,
                    transcription: (recognitionResults && recognitionResults.trim()) || null // Store transcribed text
                };
                
                await saveVoiceNote(voiceNote);
                await updateRecordButtonState();
                await displayVoiceNotes();
                
                // Switch to stored notes tab to show the new recording
                switchVoiceTab('stored');
                
                // Show different success messages based on transcription
                if (recognitionResults && recognitionResults.trim()) {
                    updateVoiceStatus(`Recording saved with transcription! Duration: ${formatDuration(duration)}`, 'info');
                    
                    // Show option to create dream entry
                    const container = document.querySelector('.voice-recording-section');
                    if (container) {
                        const successMsg = document.createElement('div');
                        successMsg.style.cssText = `
                            background: var(--notification-success-bg);
                            color: var(--success-color);
                            padding: 15px;
                            border-radius: var(--border-radius);
                            margin-top: 15px;
                            text-align: center;
                            font-weight: var(--font-weight-semibold);
                        `;
                        successMsg.innerHTML = `
                            Voice note saved with transcription! (${formatDuration(duration)})<br>
                            <button data-action="create-from-transcription" data-voice-note-id="${voiceNote.id}" class="btn btn-primary" style="margin-top: 10px; font-size: 14px;">
                                ðŸ“ Create Dream Entry
                            </button>
                        `;
                        container.appendChild(successMsg);
                        
                        setTimeout(() => {
                            if (successMsg.parentNode) {
                                successMsg.remove();
                            }
                        }, 10000);
                    }
                } else {
                    updateVoiceStatus(`Recording saved! Duration: ${formatDuration(duration)} (no transcription captured)`, 'info');
                    
                    // Show regular success message
                    const container = document.querySelector('.voice-recording-section');
                    if (container) {
                        createInlineMessage('success', `Voice note saved! (${formatDuration(duration)})`, {
                            container: container,
                            position: 'bottom',
                            duration: 3000
                        });
                    }
                }
                
            } catch (error) {
                console.error('Error saving recording:', error);
                updateVoiceStatus('Failed to save recording: ' + error.message, 'error');
            } finally {
                // Ensure button state is updated regardless of save success/failure
                await updateRecordButtonState();
            }
        }

        // VOICE NOTES DISPLAY & PLAYBACK CONTROLS
        
        // Voice Notes Display and Controls
        
        // Throttle progress updates to prevent excessive DOM manipulation
        let lastProgressUpdate = 0;
        const PROGRESS_UPDATE_THROTTLE = 100; // ms
        
        // Display voice notes (Updated for Event Delegation)
        async function displayVoiceNotes() {
            const container = document.getElementById('voiceNotesContainer');
            if (!container) return;
            
            try {
                const voiceNotes = await loadVoiceNotes();
                
                if (voiceNotes.length === 0) {
                    container.innerHTML = `
                        <div class="no-voice-notes">
                            No voice notes recorded yet.<br>
                            Use the recording button above to capture quick voice memos of your dreams.
                        </div>
                    `;
                    return;
                }
                
                // Show warning if at capacity
                                        let warningHTML = '';
                if (voiceNotes.length >= CONSTANTS.VOICE_STORAGE_LIMIT) {
                    warningHTML = `
                        <div class="voice-full-warning">
                            âš ï¸ Storage full (${CONSTANTS.VOICE_STORAGE_LIMIT}/${CONSTANTS.VOICE_STORAGE_LIMIT} voice notes). Delete recordings to free space for new ones.
                        </div>
                    `;
                }
                
                const notesHTML = voiceNotes.map(note => {
                    const sizeKB = Math.round(note.size / CONSTANTS.BYTES_PER_KB);
                    const sizeMB = (note.size / CONSTANTS.BYTES_PER_MB).toFixed(1);
                    const sizeDisplay = note.size < CONSTANTS.BYTES_PER_MB ? `${sizeKB} KB` : `${sizeMB} MB`;
                    
                    // Check if transcription is available
                    const hasTranscription = note.transcription && note.transcription.trim();
                    const transcriptionIndicator = hasTranscription ? ' â€¢ ðŸ“ Transcribed' : '';
                    
                    // Create meta information
                    const metaItems = [
                        { value: escapeHtml(note.dateString) },
                        { value: formatDuration(note.duration) },
                        { value: sizeDisplay }
                    ];
                    
                    if (transcriptionIndicator) {
                        metaItems.push({ value: transcriptionIndicator });
                    }
                    
                    // Create control buttons
                    const controlButtons = [
                        createActionButton('play-voice', note.id, 'â–¶ï¸ Play', 'voice-btn play', { id: `play-btn-${note.id}` }),
                        createActionButton('transcribe-voice', note.id, 
                            hasTranscription ? 'ðŸ“ Use as Dream' : 'ðŸ“ Transcribe & Create Dream', 
                            'voice-btn transcribe', 
                            { title: hasTranscription ? 'Create a dream entry from this transcription' : 'Transcribe the audio and create a dream entry' }
                        ),
                        createActionButton('download-voice', note.id, 'â¬‡ï¸ Download', 'voice-btn download'),
                        createActionButton('delete-voice', note.id, 'ðŸ—‘ï¸ Delete', 'voice-btn delete')
                    ].join('');
                    
                    return `
                        <div class="voice-note" id="voice-note-${escapeAttr(note.id)}">
                            <div class="voice-note-info">
                                <div class="voice-note-title">${escapeHtml(note.title)}</div>
                                <div class="voice-note-meta">${createMetaDisplay(metaItems)}</div>
                            </div>
                            <div class="voice-note-controls">
                                ${controlButtons}
                                <div class="voice-progress-container" id="progress-container-${escapeAttr(note.id)}" style="display: none;">
                                    <div class="voice-time-display" id="time-current-${escapeAttr(note.id)}">0:00</div>
                                    <div class="voice-progress-bar" data-action="seek-audio" data-voice-note-id="${escapeAttr(note.id)}" id="progress-bar-${escapeAttr(note.id)}">
                                        <div class="voice-progress-fill" id="progress-fill-${escapeAttr(note.id)}"></div>
                                    </div>
                                    <div class="voice-time-display" id="time-total-${escapeAttr(note.id)}">${formatDuration(note.duration)}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                container.innerHTML = warningHTML + notesHTML;
                
            } catch (error) {
                console.error('Error displaying voice notes:', error);
                container.innerHTML = `
                    <div class="no-voice-notes">
                        Error loading voice notes. Please try refreshing the page.
                    </div>
                `;
            }
        }
        
        // Play voice note (Updated for Event Delegation)
        async function playVoiceNote(voiceNoteId) {
            try {
                const voiceNotes = await loadVoiceNotes();
                const voiceNote = voiceNotes.find(n => n.id === voiceNoteId);
                
                if (!voiceNote) {
                    updateVoiceStatus('Voice note not found', 'error');
                    return;
                }
                
                const playBtn = document.getElementById(`play-btn-${voiceNoteId}`);
                const progressContainer = document.getElementById(`progress-container-${voiceNoteId}`);
                
                // Stop any currently playing audio
                if (currentPlayingAudio) {
                    currentPlayingAudio.pause();
                    currentPlayingAudio = null;
                    
                    // Reset all play buttons and hide progress bars
                    document.querySelectorAll('.voice-btn.pause').forEach(btn => {
                        btn.className = 'voice-btn play';
                        btn.innerHTML = 'â–¶ï¸ Play';
                        btn.dataset.action = 'play-voice';
                    });
                    document.querySelectorAll('[id^="progress-container-"]').forEach(container => {
                        container.style.display = 'none';
                    });
                }
                
                // Create audio element
                const audio = new Audio();
                const audioURL = URL.createObjectURL(voiceNote.audioBlob);
                audio.src = audioURL;
                
                // Update button to pause state and show progress bar
                if (playBtn) {
                    playBtn.className = 'voice-btn pause';
                    playBtn.innerHTML = 'â¸ï¸ Pause';
                    playBtn.dataset.action = 'pause-voice';
                }
                
                if (progressContainer) {
                    progressContainer.style.display = 'flex';
                }
                
                // Set up audio event listeners for progress tracking
                audio.ontimeupdate = () => {
                    updateAudioProgress(voiceNoteId, audio.currentTime, audio.duration);
                };
                
                audio.onloadedmetadata = () => {
                    // Update total time display when metadata loads
                    const totalTimeEl = document.getElementById(`time-total-${voiceNoteId}`);
                    if (totalTimeEl) {
                        totalTimeEl.textContent = formatDuration(audio.duration);
                    }
                };
                
                audio.onended = () => {
                    try {
                        URL.revokeObjectURL(audioURL);
                    } catch (e) {
                        console.warn('Failed to revoke audio URL:', e);
                    }
                    currentPlayingAudio = null;
                    
                    // Reset button to play state and hide progress bar
                    if (playBtn) {
                        playBtn.className = 'voice-btn play';
                        playBtn.innerHTML = 'â–¶ï¸ Play';
                        playBtn.dataset.action = 'play-voice';
                    }
                    
                    if (progressContainer) {
                        progressContainer.style.display = 'none';
                    }
                    
                    // Reset progress bar
                    const progressFill = document.getElementById(`progress-fill-${voiceNoteId}`);
                    if (progressFill) {
                        progressFill.style.width = '0%';
                    }
                    
                    // Reset time displays
                    const currentTimeEl = document.getElementById(`time-current-${voiceNoteId}`);
                    if (currentTimeEl) {
                        currentTimeEl.textContent = '0:00';
                    }
                };
                
                audio.onerror = () => {
                    try {
                        URL.revokeObjectURL(audioURL);
                    } catch (e) {
                        console.warn('Failed to revoke audio URL on error:', e);
                    }
                    currentPlayingAudio = null;
                    updateVoiceStatus('Error playing voice note', 'error');
                    
                    // Reset button and hide progress bar
                    if (playBtn) {
                        playBtn.className = 'voice-btn play';
                        playBtn.innerHTML = 'â–¶ï¸ Play';
                        playBtn.dataset.action = 'play-voice';
                    }
                    
                    if (progressContainer) {
                        progressContainer.style.display = 'none';
                    }
                };
                
                currentPlayingAudio = audio;
                await audio.play();
                
            } catch (error) {
                console.error('Error playing voice note:', error);
                updateVoiceStatus('Failed to play voice note', 'error');
            }
        }
        
        // Pause voice note (Updated for Event Delegation)
        function pauseVoiceNote(voiceNoteId) {
            if (currentPlayingAudio) {
                try {
                    currentPlayingAudio.pause();
                    // Don't revoke URL here since user might want to resume
                } catch (e) {
                    console.warn('Error pausing audio:', e);
                }
                currentPlayingAudio = null;
            }
            
            const playBtn = document.getElementById(`play-btn-${voiceNoteId}`);
            const progressContainer = document.getElementById(`progress-container-${voiceNoteId}`);
            
            if (playBtn) {
                playBtn.className = 'voice-btn play';
                playBtn.innerHTML = 'â–¶ï¸ Play';
                playBtn.dataset.action = 'play-voice';
            }
            
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
        }
        
        // Update audio progress bar and time displays
        function updateAudioProgress(voiceNoteId, currentTime, duration) {
            if (!voiceNoteId || isNaN(currentTime) || isNaN(duration) || duration <= 0) return;
            
            // Throttle updates to prevent excessive DOM manipulation
            const now = Date.now();
            if (now - lastProgressUpdate < PROGRESS_UPDATE_THROTTLE) return;
            lastProgressUpdate = now;
            
            const progressFill = document.getElementById(`progress-fill-${voiceNoteId}`);
            const currentTimeEl = document.getElementById(`time-current-${voiceNoteId}`);
            
            if (progressFill) {
                // Extra safety check to prevent division by zero and invalid values
                const safeCurrentTime = Math.max(0, Math.min(currentTime, duration));
                const progress = Math.max(0, Math.min(100, (safeCurrentTime / duration) * 100));
                progressFill.style.width = `${progress}%`;
            }
            
            if (currentTimeEl) {
                currentTimeEl.textContent = formatDuration(Math.max(0, currentTime));
            }
        }
        
        // Seek to specific position in audio
        function seekAudio(voiceNoteId, event) {
            if (!currentPlayingAudio || !event) return;
            
            const progressBar = document.getElementById(`progress-bar-${voiceNoteId}`);
            if (!progressBar) return;
            
            const rect = progressBar.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const progressBarWidth = rect.width;
            
            if (progressBarWidth <= 0) return; // Prevent division by zero
            
            const clickPercentage = clickX / progressBarWidth;
            
            // Ensure percentage is between 0 and 1
            const seekPercentage = Math.max(0, Math.min(1, clickPercentage));
            
            if (!isNaN(currentPlayingAudio.duration) && currentPlayingAudio.duration > 0) {
                const seekTime = seekPercentage * currentPlayingAudio.duration;
                currentPlayingAudio.currentTime = seekTime;
                
                // Update progress immediately for responsive feedback
                updateAudioProgress(voiceNoteId, seekTime, currentPlayingAudio.duration);
            }
        }
        
        // Download voice note
        async function downloadVoiceNote(voiceNoteId) {
            try {
                const voiceNotes = await loadVoiceNotes();
                const voiceNote = voiceNotes.find(n => n.id === voiceNoteId);
                
                if (!voiceNote) {
                    updateVoiceStatus('Voice note not found', 'error');
                    return;
                }
                
                const url = URL.createObjectURL(voiceNote.audioBlob);
                const a = document.createElement('a');
                a.href = url;
                
                // Generate filename with date
                const date = new Date(voiceNote.timestamp);
                const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD
                const timeStr = date.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
                const extension = voiceNote.audioBlob.type.includes('webm') ? 'webm' : 'mp4';
                
                a.download = `dream-voice-note-${dateStr}-${timeStr}.${extension}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                updateVoiceStatus('Voice note downloaded', 'info');
                
            } catch (error) {
                console.error('Error downloading voice note:', error);
                updateVoiceStatus('Failed to download voice note', 'error');
            }
        }
        
        // Show delete confirmation for voice note
        function deleteVoiceNote(voiceNoteId) {
            // Clear any existing timeout for this voice note
            if (voiceDeleteTimeouts[voiceNoteId]) {
                clearTimeout(voiceDeleteTimeouts[voiceNoteId]);
                delete voiceDeleteTimeouts[voiceNoteId];
            }
            
            const voiceNoteElement = document.getElementById(`voice-note-${voiceNoteId}`);
            if (!voiceNoteElement) return; // Safety check
            
            // Add pending delete styling
            voiceNoteElement.classList.add('delete-pending');
            
            // Find and replace delete button with confirm button
            const deleteBtn = voiceNoteElement.querySelector(`button[data-voice-note-id="${voiceNoteId}"][data-action="delete-voice"]`);
            if (deleteBtn) {
                deleteBtn.outerHTML = createActionButton('confirm-delete-voice', voiceNoteId, 'Confirm Delete', 'voice-btn delete', { style: 'animation: pulse 0.5s ease-in-out;' });
            }
            
            // Set timeout to revert after specified time
            voiceDeleteTimeouts[voiceNoteId] = setTimeout(() => {
                cancelDeleteVoiceNote(voiceNoteId);
            }, CONSTANTS.MESSAGE_DURATION_EXTENDED);
        }

        // Actually delete the voice note after confirmation (with mutex protection)
        async function confirmDeleteVoiceNote(voiceNoteId) {
            return withMutex('voiceOperations', async () => {
                try {
                    // Clear the timeout
                    if (voiceDeleteTimeouts[voiceNoteId]) {
                        clearTimeout(voiceDeleteTimeouts[voiceNoteId]);
                        delete voiceDeleteTimeouts[voiceNoteId];
                    }
                    
                    // Stop playing if this note is currently playing
                    if (currentPlayingAudio) {
                        currentPlayingAudio.pause();
                        currentPlayingAudio = null;
                    }
                    
                    // Try to delete from IndexedDB first
                    let deleted = false;
                    if (isIndexedDBAvailable()) {
                        deleted = await deleteVoiceNoteFromIndexedDB(voiceNoteId);
                    }
                    
                    // If IndexedDB deletion failed or unavailable, delete from memory
                    if (!deleted) {
                        const index = memoryVoiceNotes.findIndex(n => n.id === voiceNoteId);
                        if (index !== -1) {
                            memoryVoiceNotes.splice(index, 1);
                            deleted = true;
                        }
                    }
                    
                    if (deleted) {
                        await updateRecordButtonState();
                        await displayVoiceNotes();
                        updateVoiceStatus('Voice note deleted', 'info');
                    } else {
                        updateVoiceStatus('Voice note not found', 'error');
                    }
                    
                } catch (error) {
                    console.error('Error deleting voice note:', error);
                    updateVoiceStatus('Failed to delete voice note', 'error');
                }
            });
        }

        // Cancel voice note delete and revert to normal state
        function cancelDeleteVoiceNote(voiceNoteId) {
            // Clear the timeout
            if (voiceDeleteTimeouts[voiceNoteId]) {
                clearTimeout(voiceDeleteTimeouts[voiceNoteId]);
                delete voiceDeleteTimeouts[voiceNoteId];
            }
            
            const voiceNoteElement = document.getElementById(`voice-note-${voiceNoteId}`);
            if (voiceNoteElement) {
                // Remove pending delete styling
                voiceNoteElement.classList.remove('delete-pending');
                
                // Replace confirm button with original delete button
                const confirmBtn = voiceNoteElement.querySelector(`button[data-voice-note-id="${voiceNoteId}"][data-action="confirm-delete-voice"]`);
                if (confirmBtn) {
                    confirmBtn.outerHTML = createActionButton('delete-voice', voiceNoteId, 'ðŸ—‘ï¸ Delete', 'voice-btn delete');
                }
            }
        }

        // PIN SECURITY & ACCESS CONTROL SYSTEM
        
        // Show warning when storage isn't persistent
        function showStorageWarning() {
            const warning = document.createElement('div');
            warning.id = 'storageWarning';
            warning.style.cssText = `
                background: var(--notification-warning-bg);
                border: 2px solid var(--warning-color);
                color: var(--warning-color);
                padding: 15px;
                margin: 20px;
                border-radius: var(--border-radius);
                text-align: center;
                font-weight: var(--font-weight-semibold);
            `;
            warning.innerHTML = `
                âš ï¸ <strong>Storage Warning:</strong> Your dreams are stored temporarily in memory only. 
                <br>They will be lost when you close this tab. Please export your dreams regularly!
                <br><small>To enable permanent storage, access this page through a web server.</small>
            `;
            
            const container = document.querySelector('.container');
            container.insertBefore(warning, container.children[2]);
        }

        // Simple hash function for PIN (DEPRECATED - kept for migration)
        function hashPinLegacy(pin) {
            let hash = 0;
            for (let i = 0; i < pin.length; i++) {
                const char = pin.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString();
        }

        // Secure PIN hashing using existing crypto infrastructure
        async function hashPinSecure(pin, salt = null) {
            try {
                if (!salt) salt = generateSalt();
                
                // Use existing deriveKey function but make result extractable for storage
                const encoder = new TextEncoder();
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(pin),
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits']
                );
                
                // Derive bits instead of key to avoid extractability issues
                const derivedBits = await crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: CONSTANTS.CRYPTO_PBKDF2_ITERATIONS,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    CONSTANTS.CRYPTO_KEY_LENGTH // 32 bytes
                );
                
                // Convert to hex string
                const hashArray = Array.from(new Uint8Array(derivedBits));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                
                // Convert salt to hex string  
                const saltArray = Array.from(salt);
                const saltHex = saltArray.map(b => b.toString(16).padStart(2, '0')).join('');
                
                return {
                    hash: hashHex,
                    salt: saltHex
                };
            } catch (error) {
                console.error('Secure PIN hashing error:', error);
                throw new Error('Failed to hash PIN securely');
            }
        }

        // Detect if stored PIN data is old format (simple hash) or new format (secure)
        function isLegacyPinFormat(storedData) {
            // Legacy format is just a simple hash string
            // New format is JSON with hash and salt properties
            if (typeof storedData === 'string') {
                try {
                    const parsed = JSON.parse(storedData);
                    return !(parsed && parsed.hash && parsed.salt);
                } catch (e) {
                    return true; // Not JSON, so it's legacy
                }
            }
            return true;
        }

        // PIN storage with fallback system (same as main app)
        let pinStorage = {
            hash: null,
            resetTime: null
        };

        // Check if PIN is set up (with fallback storage)
        function isPinSetup() {
            // Try localStorage first
            if (isLocalStorageAvailable()) {
                return localStorage.getItem('dreamJournalPinHash') !== null;
            }
            
            // Fallback to memory storage
            return pinStorage.hash !== null;
        }

        // Store PIN hash (with fallback storage) - UPDATED for secure hashing
        async function storePinHash(pin) {
            if (!pin) {
                return false;
            }
            
            try {
                // Use secure hashing
                const { hash, salt } = await hashPinSecure(pin);
                const secureData = JSON.stringify({ hash, salt, version: 'secure' });
                
                // Try localStorage first
                if (isLocalStorageAvailable()) {
                    try {
                        localStorage.setItem('dreamJournalPinHash', secureData);
                        return true;
                    } catch (error) {
                        console.error('Error storing secure PIN hash:', error);
                        // Fall through to memory storage
                    }
                }
                
                // Fallback to memory storage
                pinStorage.hash = secureData;
                return true;
            } catch (error) {
                console.error('Error storing secure PIN hash:', error);
                return false;
            }
        }

        // Get stored PIN hash (with fallback storage) - UPDATED for secure hashing
        function getStoredPinData() {
            // Try localStorage first
            if (isLocalStorageAvailable()) {
                const data = localStorage.getItem('dreamJournalPinHash');
                if (data) return data;
            }
            
            // Fallback to memory storage
            return pinStorage.hash;
        }

        // Verify PIN against stored hash - UPDATED to handle both legacy and secure formats
        async function verifyPinHash(enteredPin, storedData) {
            if (!storedData) return false;
            
            try {
                if (isLegacyPinFormat(storedData)) {
                    // Legacy format - use simple hash comparison
                    const legacyHash = hashPinLegacy(enteredPin);
                    return legacyHash === storedData;
                } else {
                    // Secure format - parse and verify
                    const { hash: storedHash, salt: storedSaltHex } = JSON.parse(storedData);
                    
                    // Convert salt from hex back to Uint8Array
                    const saltArray = new Uint8Array(storedSaltHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                    
                    // Hash the entered PIN with the stored salt
                    const { hash: enteredHash } = await hashPinSecure(enteredPin, saltArray);
                    
                    return enteredHash === storedHash;
                }
            } catch (error) {
                console.error('Error verifying PIN:', error);
                return false;
            }
        }

        // Remove PIN hash (with fallback storage) - works with both legacy and secure formats
        function removePinHash() {
            // Remove from localStorage if available
            if (isLocalStorageAvailable()) {
                localStorage.removeItem('dreamJournalPinHash');
            }
            
            // Remove from memory storage
            pinStorage.hash = null;
        }

        // Store reset time (with fallback storage)
        function storeResetTime(time) {
            // Try localStorage first
            if (isLocalStorageAvailable()) {
                try {
                    localStorage.setItem('dreamJournalPinResetTime', time.toString());
                    return true;
                } catch (error) {
                    console.error('storeResetTime: Failed to save to localStorage:', error);
                }
            }
            
            // Fallback to memory storage
            pinStorage.resetTime = time;
            return true;
        }

        // Get reset time (with fallback storage)
        function getResetTime() {
            // Try localStorage first
            if (isLocalStorageAvailable()) {
                const time = localStorage.getItem('dreamJournalPinResetTime');
                if (time) return parseInt(time);
            }
            
            // Fallback to memory storage
            return pinStorage.resetTime;
        }

        // Remove reset time (with fallback storage)
        function removeResetTime() {
            // Remove from localStorage if available
            if (isLocalStorageAvailable()) {
                localStorage.removeItem('dreamJournalPinResetTime');
            }
            
            // Remove from memory storage
            pinStorage.resetTime = null;
        }

        // Update security controls visibility
        // Note: Lock button is ALWAYS visible for better UX - logic handled in toggleLock()
        function updateSecurityControls() {
            const lockBtn = document.getElementById('lockBtn');
            const lockBtnSettings = document.getElementById('lockBtnSettings');
            const setupBtnSettings = document.getElementById('setupPinBtnSettings');
            
            // Always show the lock button - much simpler UX!
            if (lockBtn) {
                lockBtn.style.display = 'inline-block';
                if (isPinSetup()) {
                    if (isUnlocked && !isAppLocked) {
                        lockBtn.textContent = 'ðŸ”’ Lock Journal';
                        lockBtn.title = 'Lock your journal with your PIN to keep dreams private';
                    } else {
                        lockBtn.textContent = 'ðŸ”“ Unlock Journal'; // This case shouldn't happen much since we use lock screen
                        lockBtn.title = 'Unlock your journal by entering your PIN';
                    }
                } else {
                    lockBtn.textContent = 'ðŸ”’ Setup & Lock';
                    lockBtn.title = 'Set up a PIN to secure your dreams, then lock the journal';
                }
            }
            
            // Always show settings lock button too
            if (lockBtnSettings) {
                lockBtnSettings.style.display = 'inline-block';
                if (isPinSetup()) {
                    if (isUnlocked && !isAppLocked) {
                        lockBtnSettings.textContent = 'ðŸ”’ Lock Journal';
                        lockBtnSettings.title = 'Lock your journal with your PIN to keep dreams private';
                    } else {
                        lockBtnSettings.textContent = 'ðŸ”“ Unlock Journal';
                        lockBtnSettings.title = 'Unlock your journal by entering your PIN';
                    }
                } else {
                    lockBtnSettings.textContent = 'ðŸ”’ Setup & Lock';
                    lockBtnSettings.title = 'Set up a PIN to secure your dreams, then lock the journal';
                }
            }
            
            // Update setup button text (only exists in settings)
            if (setupBtnSettings) {
                setupBtnSettings.textContent = isPinSetup() ? 'âš™ï¸ Change PIN' : 'âš™ï¸ Setup PIN';
            }
            
            // Ensure correct app state
            if (!isPinSetup()) {
                isUnlocked = true;
                isAppLocked = false;
            }
        }

        // Show Remove PIN option
        function showRemovePin() {
            const title = document.getElementById('pinTitle');
            const message = document.getElementById('pinMessage');
            const setupLink = document.getElementById('pinSetupLink');
            const removePinLink = document.getElementById('removePinLink');
            const cancelBtn = document.getElementById('cancelPinBtn');
            const unlockBtn = document.getElementById('pinMainBtn');
            
            title.textContent = 'âš ï¸ Remove PIN Protection';
            message.textContent = 'Enter your current PIN to remove protection. Your dreams will no longer be secured.';
            message.style.color = 'var(--text-primary)';
            setupLink.style.display = 'none';
            removePinLink.style.display = 'none';
            cancelBtn.style.display = 'inline-block';
            
            document.getElementById('pinInput').placeholder = 'Enter current PIN';
            document.getElementById('pinInput').value = '';
            document.getElementById('pinInput').style.display = 'block';
            
            unlockBtn.dataset.action = 'confirm-remove-pin';
            unlockBtn.textContent = 'Remove PIN';
            document.getElementById('pinOverlay').style.display = 'flex';
            setTimeout(() => {
                document.getElementById('pinInput').focus();
            }, CONSTANTS.FOCUS_DELAY_MS);
        }

        // Confirm PIN removal - UPDATED for secure hashing
        async function confirmRemovePin() {
            const enteredPin = document.getElementById('pinInput').value;
            
            if (!enteredPin) {
                showMessage('error', 'Please enter your current PIN');
                return;
            }
            
            try {
                const storedData = getStoredPinData();
                const isValid = await verifyPinHash(enteredPin, storedData);
                
                if (!isValid) {
                    const message = document.getElementById('pinMessage');
                    message.textContent = 'Incorrect PIN. Please try again.';
                    message.style.color = 'var(--error-color)';
                    document.getElementById('pinInput').value = '';
                    return;
                }
                
                // Remove the PIN
                removePinHash();
                
                const title = document.getElementById('pinTitle');
                const message = document.getElementById('pinMessage');
                title.textContent = 'âœ… PIN Removed';
                message.textContent = 'PIN protection has been removed. Your dreams are no longer secured.';
                message.style.color = 'var(--success-color)';
                
                // Hide input and update button
                document.getElementById('pinInput').style.display = 'none';
                const unlockBtn = document.getElementById('pinMainBtn');
                const cancelBtn = document.getElementById('cancelPinBtn');
                
                if (unlockBtn) {
                    unlockBtn.textContent = 'Close';
                    unlockBtn.dataset.action = 'complete-pin-removal';
                }
                
                if (cancelBtn) {
                    cancelBtn.style.display = 'none';
                }
                
                isUnlocked = true;
            } catch (error) {
                console.error('Error removing PIN:', error);
                showMessage('error', 'Error removing PIN. Please try again.');
            }
        }

        // Complete PIN removal and close overlay
        async function completePinRemoval() {
            resetPinOverlay();
            hidePinOverlay();
            
            // Reset failed attempts since PIN removal was successful
            failedPinAttempts = 0;
            
            // PIN removed - unlock the app
            isUnlocked = true;
            isAppLocked = false;
            
            console.log('PIN removal complete - ensuring tabs are visible');
            
            // Ensure all tabs are visible (PIN is removed, no need to hide)
            showAllTabButtons();
            
            updateSecurityControls();
            await displayDreams();
        }

        // Show inline message
        function showMessage(type, message, elementId = null) {
            // Clear all messages first
            document.getElementById('pinFeedback').style.display = 'none';
            document.getElementById('pinSuccess').style.display = 'none';
            document.getElementById('pinInfo').style.display = 'none';
            
            let element;
            if (elementId) {
                element = document.getElementById(elementId);
            } else {
                switch(type) {
                    case 'error': element = document.getElementById('pinFeedback'); break;
                    case 'success': element = document.getElementById('pinSuccess'); break;
                    case 'info': element = document.getElementById('pinInfo'); break;
                }
            }
            
            if (element) {
                element.textContent = message;
                element.style.display = 'block';
                
                // Auto-hide success messages after duration
                if (type === 'success') {
                    setTimeout(() => {
                        element.style.display = 'none';
                    }, CONSTANTS.MESSAGE_DURATION_MEDIUM);
                }
            }
        }

        // Verify PIN - UPDATED for secure hashing with migration
        async function verifyPin() {
            const enteredPin = document.getElementById('pinInput').value;
            if (!enteredPin) {
                showMessage('error', 'Please enter a PIN');
                return;
            }
            
            try {
                const storedData = getStoredPinData();
                const isValid = await verifyPinHash(enteredPin, storedData);
                
                if (isValid) {
                    // Check if we need to migrate from legacy format
                    if (isLegacyPinFormat(storedData)) {
                        showMessage('info', 'Upgrading PIN security...');
                        
                        // Migrate to secure format
                        const migrationSuccess = await storePinHash(enteredPin);
                        if (migrationSuccess) {
                            showMessage('success', 'PIN security upgraded successfully!');
                        } else {
                            showMessage('warning', 'PIN security upgrade failed, but access granted.');
                        }
                        
                        // Small delay to let user see the upgrade message
                        await new Promise(resolve => setTimeout(resolve, 1500));
                    }
                    
                    isUnlocked = true;
                    isAppLocked = false; // Ensure app is not locked after successful PIN entry
                    failedPinAttempts = 0; // Reset failed attempts on success
                    
                    console.log('PIN overlay unlock successful - showing all tabs');
                    
                    hidePinOverlay();
                    
                    // Show all tabs again if they were hidden
                    showAllTabButtons();
                    
                    updateSecurityControls();
                    await displayDreams();
                    document.getElementById('pinInput').value = '';
                } else {
                    failedPinAttempts++;
                    
                    // Show forgot PIN link after failed attempts
                    if (failedPinAttempts >= CONSTANTS.FAILED_PIN_ATTEMPT_LIMIT) {
                        document.getElementById('forgotPinLink').style.display = 'block';
                        showMessage('error', 'Incorrect PIN. You can use "Forgot PIN?" below if needed.');
                    } else {
                        showMessage('error', 'Incorrect PIN. Please try again.');
                    }
                    
                    document.getElementById('pinInput').value = '';
                    document.getElementById('pinInput').focus();
                }
            } catch (error) {
                console.error('Error verifying PIN:', error);
                showMessage('error', 'PIN verification failed. Please try again.');
                document.getElementById('pinInput').value = '';
            }
        }

        // Show Forgot PIN options
        async function showForgotPin() {
            const title = document.getElementById('pinTitle');
            const message = document.getElementById('pinMessage');
            const setupLink = document.getElementById('pinSetupLink');
            const removePinLink = document.getElementById('removePinLink');
            const forgotPinLink = document.getElementById('forgotPinLink');
            const cancelBtn = document.getElementById('cancelPinBtn');
            const unlockBtn = document.getElementById('pinMainBtn');
            const pinInput = document.getElementById('pinInput');
            
            // Check if there's an active timer
            const resetTime = getResetTime();
            if (resetTime) {
                const remainingTime = resetTime - Date.now();
                if (remainingTime > 0) {
                    showTimerRecovery(remainingTime);
                } else {
                    // Timer expired, allow reset
                    removeResetTime();
                    removePinHash();
                    isUnlocked = true;
                    failedPinAttempts = 0;
                    hidePinOverlay();
                    updateSecurityControls();
                    displayDreams();
                    
                    // Show success message in main content instead of alert
                    setTimeout(() => {
                        const container = document.querySelector('.main-content');
                        const msg = document.createElement('div');
                        msg.style.cssText = `
                            background: var(--notification-info-bg);
                            color: var(--info-color);
                            padding: 15px;
                            border-radius: var(--border-radius);
                            margin-bottom: 20px;
                            font-weight: var(--font-weight-semibold);
                            text-align: center;
                        `;
                        msg.textContent = 'PIN reset timer has expired. Your PIN has been removed. You can set a new one if desired.';
                        container.insertBefore(msg, container.firstChild);
                        
                        setTimeout(() => {
                            msg.remove();
                        }, 8000);
                    }, 100);
                }
                // Exit the function after handling timer
                return;
            }
            
            title.textContent = 'ðŸ”‘ PIN Recovery';
            message.innerHTML = `
                <strong>Choose a recovery method:</strong><br><br>
                <strong>Option 1:</strong> Enter 3 of your dream titles exactly as written<br>
                <em style="font-size: 0.9em; color: #64748b;">(Note: "Untitled Dream" entries are not valid)</em><br><br>
                <strong>Option 2:</strong> Wait 72 hours for automatic reset<br>
                <em style="font-size: 0.9em; color: #64748b;">(Your dreams will remain safe)</em>
            `;
            message.style.color = '#374151';
            setupLink.style.display = 'none';
            removePinLink.style.display = 'none';
            forgotPinLink.style.display = 'none';
            cancelBtn.style.display = 'inline-block';
            pinInput.style.display = 'none';
            
            // Update buttons for recovery options
            unlockBtn.textContent = 'Verify Dream Titles';
            unlockBtn.dataset.action = 'start-title-recovery';
            
            // Add a second button for timer option
            const buttonsContainer = document.querySelector('.pin-buttons');
            if (!document.getElementById('timerBtn')) {
                const timerBtn = document.createElement('button');
                timerBtn.id = 'timerBtn';
                timerBtn.className = 'btn btn-secondary';
                timerBtn.textContent = 'Start 72hr Timer';
                timerBtn.dataset.action = 'start-timer-recovery';
                buttonsContainer.insertBefore(timerBtn, cancelBtn);
            }
        }

        // Start dream title recovery (Updated for Event Delegation)
        async function startTitleRecovery() {
            const dreams = await loadDreams();
            // Filter out untitled dreams
            const validDreams = dreams.filter(d => d.title !== 'Untitled Dream');
            
            if (validDreams.length < 3) {
                const message = document.getElementById('pinMessage');
                message.innerHTML = `
                    <span style="color: #dc2626;">You need at least 3 dreams with custom titles to use this recovery method.</span><br><br>
                    Please use the 72-hour timer option instead.
                `;
                return;
            }
            
            const title = document.getElementById('pinTitle');
            const message = document.getElementById('pinMessage');
            const unlockBtn = document.getElementById('pinMainBtn');
            const timerBtn = document.getElementById('timerBtn');
            
            title.textContent = 'ðŸ”‘ Verify Your Dreams';
            message.innerHTML = `
                Enter exactly 3 of your dream titles:<br>
                <em style="font-size: 0.9em; color: var(--text-secondary);">Must match exactly, including capitalisation</em><br><br>
                <input type="text" id="recovery1" class="form-control" placeholder="Dream title 1" style="margin-bottom: 10px;">
                <input type="text" id="recovery2" class="form-control" placeholder="Dream title 2" style="margin-bottom: 10px;">
                <input type="text" id="recovery3" class="form-control" placeholder="Dream title 3">
                <div id="recoveryFeedback" style="margin-top: 10px;"></div>
            `;
            
            if (timerBtn) timerBtn.style.display = 'none';
            unlockBtn.textContent = 'Verify Titles';
            unlockBtn.dataset.action = 'verify-dream-titles';
            
            setTimeout(() => {
                document.getElementById('recovery1').focus();
            }, CONSTANTS.FOCUS_DELAY_MS);
        }

        // Verify dream titles for recovery - UPDATED for secure hashing
        async function verifyDreamTitles() {
            const title1 = document.getElementById('recovery1').value.trim();
            const title2 = document.getElementById('recovery2').value.trim();
            const title3 = document.getElementById('recovery3').value.trim();
            const feedback = document.getElementById('recoveryFeedback');
            
            if (!title1 || !title2 || !title3) {
                feedback.innerHTML = '<span style="color: #dc2626;">Please enter all 3 dream titles</span>';
                return;
            }
            
            const dreams = await loadDreams();
            const validDreams = dreams.filter(d => d.title !== 'Untitled Dream');
            const dreamTitles = validDreams.map(d => d.title);
            
            // Check if all three titles exist and are different
            const titles = [title1, title2, title3];
            const uniqueTitles = [...new Set(titles)];
            
            if (uniqueTitles.length !== 3) {
                feedback.innerHTML = '<span style="color: #dc2626;">Please enter 3 DIFFERENT dream titles. Each title must be unique.</span>';
                return;
            }
            
            const allValid = titles.every(t => dreamTitles.includes(t));
            
            if (allValid) {
                // Success - remove PIN
                removePinHash();
                removeResetTime(); // Clear any active timer
                
                const titleEl = document.getElementById('pinTitle');
                const message = document.getElementById('pinMessage');
                titleEl.textContent = 'âœ… Recovery Successful';
                message.innerHTML = `
                    <span style="color: #059669;">Your PIN has been removed. You can now set a new secure PIN.</span><br><br>
                    Click below to continue.
                `;
                message.style.color = 'var(--success-color)';
                
                const unlockBtn = document.getElementById('pinMainBtn');
                const timerBtn = document.getElementById('timerBtn');
                const cancelBtn = document.getElementById('cancelPinBtn');
                
                if (timerBtn) timerBtn.style.display = 'none';
                if (cancelBtn) cancelBtn.style.display = 'none';
                
                unlockBtn.textContent = 'Continue';
                unlockBtn.dataset.action = 'complete-recovery';
                
                isUnlocked = true;
                failedPinAttempts = 0;
                updateTimerWarning(); // Hide warning if it was active
            } else {
                feedback.innerHTML = '<span style="color: #dc2626;">One or more titles did not match. Please try again with exact titles from your dreams.</span>';
            }
        }

        // Start timer recovery
        function startTimerRecovery() {
            const title = document.getElementById('pinTitle');
            const message = document.getElementById('pinMessage');
            const unlockBtn = document.getElementById('pinMainBtn');
            const timerBtn = document.getElementById('timerBtn');
            const cancelBtn = document.getElementById('cancelPinBtn');
            
            // Show confirmation in the dialog
            title.textContent = 'â³ Confirm Timer Reset';
            message.innerHTML = `
                <span style="color: #dc2626; font-weight: 600;">âš ï¸ Warning</span><br><br>
                This will start a 72-hour countdown. After 72 hours, your PIN will be automatically removed.<br><br>
                <span style="color: #64748b;">Your dreams will remain safe and will not be deleted.</span><br><br>
                Do you want to continue?
            `;
            
            if (timerBtn) timerBtn.style.display = 'none';
            unlockBtn.textContent = 'Yes, Start Timer';
            unlockBtn.dataset.action = 'confirm-start-timer';
            cancelBtn.textContent = 'No, Cancel';
        }

        // Confirm and actually start the timer
        function confirmStartTimer() {
            const resetTime = Date.now() + (CONSTANTS.PIN_RESET_HOURS * 60 * 60 * 1000); // hours from now
            storeResetTime(resetTime);
            showTimerRecovery(CONSTANTS.PIN_RESET_HOURS * 60 * 60 * 1000);
            updateTimerWarning(); // Show warning banner
        }

        // Update timer warning banner
        function updateTimerWarning() {
            const warningBanner = document.getElementById('timerWarning');
            const warningTime = document.getElementById('timerWarningTime');
            
            if (!warningBanner || !warningTime) return; // Safety check
            
            const resetTime = getResetTime();
            if (resetTime) {
                const remainingMs = resetTime - Date.now();
                if (remainingMs > 0) {
                    const hours = Math.ceil(remainingMs / (1000 * 60 * 60));
                    const days = Math.ceil(hours / 24);
                    
                    let timeDisplay = '';
                    if (days > 1) {
                        timeDisplay = `${days} days remaining`;
                    } else if (hours > 1) {
                        timeDisplay = `${hours} hours remaining`;
                    } else {
                        timeDisplay = 'Less than 1 hour remaining';
                    }
                    
                    warningTime.textContent = `(${timeDisplay})`;
                    warningBanner.classList.add('active');
                } else {
                    warningBanner.classList.remove('active');
                }
            } else {
                warningBanner.classList.remove('active');
            }
        }

        // Cancel reset timer
        function cancelResetTimer() {
            // Change the warning banner to show confirmation
            const warningBanner = document.getElementById('timerWarning');
            const originalHTML = warningBanner.innerHTML;
            
            warningBanner.innerHTML = `
                âš ï¸ <strong>Cancel PIN Reset Timer?</strong> - You will need to enter your PIN or start recovery again.
                <button data-action="confirm-cancel-timer">Yes, Cancel Timer</button>
                <button data-action="restore-warning-banner">No, Keep Timer</button>
            `;
        }

        // Actually cancel the timer
        function confirmCancelTimer() {
            removeResetTime();
            updateTimerWarning();
            
            // Show success message in the banner briefly
            const warningBanner = document.getElementById('timerWarning');
            warningBanner.innerHTML = 'âœ… PIN reset timer has been cancelled.';
            warningBanner.style.background = 'var(--success-color)';
            
            setTimeout(() => {
                warningBanner.classList.remove('active');
                warningBanner.style.background = 'var(--error-color)'; // Reset to red for future use
            }, 3000);
        }

        // Restore warning banner if user cancels
        function restoreWarningBanner() {
            updateTimerWarning();
        }

        // Show timer recovery status
        function showTimerRecovery(remainingMs) {
            const hours = Math.ceil(remainingMs / (1000 * 60 * 60));
            const days = Math.ceil(hours / 24);
            
            const title = document.getElementById('pinTitle');
            const message = document.getElementById('pinMessage');
            const unlockBtn = document.getElementById('pinMainBtn');
            const timerBtn = document.getElementById('timerBtn');
            const cancelBtn = document.getElementById('cancelPinBtn');
            
            title.textContent = 'â³ Recovery Timer Active';
            
            let timeDisplay = '';
            if (days > 1) {
                timeDisplay = `${days} days`;
            } else if (hours > 1) {
                timeDisplay = `${hours} hours`;
            } else {
                timeDisplay = 'Less than 1 hour';
            }
            
            message.innerHTML = `
                PIN reset timer is active.<br><br>
                <strong>Time remaining: ${timeDisplay}</strong><br><br>
                <em style="font-size: 0.9em; color: #64748b;">Check back later, or try the dream title recovery method instead.</em>
            `;
            message.style.color = '#374151';
            
            if (timerBtn) timerBtn.style.display = 'none';
            unlockBtn.textContent = 'Try Title Recovery';
            unlockBtn.dataset.action = 'start-title-recovery';
            cancelBtn.style.display = 'inline-block';
        }

        // Complete recovery process
        async function completeRecovery() {
            resetPinOverlay();
            hidePinOverlay();
            
            // Recovery successful - unlock the app
            isUnlocked = true;
            isAppLocked = false;
            
            console.log('PIN overlay recovery complete - showing all tabs');
            
            // Show all tabs again
            showAllTabButtons();
            
            updateSecurityControls();
            updateTimerWarning(); // Hide warning if recovery was successful
            await displayDreams();
            
            // Show success in main view instead of alert
            const container = document.querySelector('.main-content');
            if (container) {
                const successMsg = document.createElement('div');
                successMsg.style.cssText = `
                    background: var(--notification-success-bg);
                    color: var(--success-color);
                    padding: 15px;
                    border-radius: var(--border-radius);
                    margin-bottom: 20px;
                    font-weight: var(--font-weight-semibold);
                    text-align: center;
                `;
                successMsg.textContent = 'Recovery complete! You can now set a new PIN from the security controls if desired.';
                container.insertBefore(successMsg, container.firstChild);
                
                setTimeout(() => {
                    try {
                        if (successMsg && successMsg.parentNode) {
                            successMsg.remove();
                        }
                    } catch (e) {
                        // Ignore cleanup errors
                    }
                }, 5000);
            }
        }

        // LOCK SCREEN TAB FUNCTIONS
        
        // Verify PIN on lock screen
        async function verifyLockScreenPin() {
            const pinInput = document.getElementById('lockScreenPinInput');
            const feedbackDiv = document.getElementById('lockScreenFeedback');
            
            if (!pinInput || !feedbackDiv) return;
            
            const enteredPin = pinInput.value;
            if (!enteredPin) {
                showLockScreenMessage('error', 'Please enter a PIN');
                return;
            }
            
            try {
                const storedData = getStoredPinData();
                const isValid = await verifyPinHash(enteredPin, storedData);
                
                if (isValid) {
                    showLockScreenMessage('success', 'PIN verified! Unlocking journal...');
                    
                    // Reset failed attempts and unlock
                    failedPinAttempts = 0;
                    isUnlocked = true;
                    isAppLocked = false; // Important: set this false when unlocking
                    
                    console.log('Lock screen unlock successful - showing all tabs');
                    
                    // Clear PIN input
                    pinInput.value = '';
                    
                    // Return to previous tab after short delay
                    setTimeout(() => {
                        // Show all tabs again
                        showAllTabButtons();
                        
                        // Switch to previous tab (or journal if preLockActiveTab is lock)
                        const targetTab = (preLockActiveTab === 'lock') ? 'journal' : preLockActiveTab;
                        switchAppTab(targetTab);
                        updateSecurityControls(); // Simple call, no extra timeout needed
                    }, 1000);
                    
                } else {
                    failedPinAttempts++;
                    pinInput.value = '';
                    
                    if (failedPinAttempts >= CONSTANTS.FAILED_PIN_ATTEMPT_LIMIT) {
                        showLockScreenMessage('error', 'Incorrect PIN. Use "Forgot PIN?" if needed.');
                    } else {
                        showLockScreenMessage('error', 'Incorrect PIN. Please try again.');
                    }
                }
            } catch (error) {
                console.error('Lock screen PIN verification error:', error);
                showLockScreenMessage('error', 'PIN verification failed. Please try again.');
                pinInput.value = '';
            }
        }
        
        // Show forgot PIN options on lock screen
        async function showLockScreenForgotPin() {
            // Check if there's an active timer
            const resetTime = getResetTime();
            if (resetTime) {
                const remainingTime = resetTime - Date.now();
                if (remainingTime > 0) {
                    const hours = Math.ceil(remainingTime / (1000 * 60 * 60));
                    const days = Math.ceil(hours / 24);
                    
                    let timeDisplay = '';
                    if (days > 1) {
                        timeDisplay = `${days} days`;
                    } else if (hours > 1) {
                        timeDisplay = `${hours} hours`;
                    } else {
                        timeDisplay = 'Less than 1 hour';
                    }
                    
                    showLockScreenMessage('info', `Recovery timer active. Time remaining: ${timeDisplay}. Press "Forgot PIN?" again when timer expires to unlock.`);
                } else {
                    // Timer expired but not processed yet
                    removeResetTime();
                    removePinHash();
                    isUnlocked = true;
                    isAppLocked = false;
                    switchAppTab(preLockActiveTab);
                    updateSecurityControls();
                }
                return;
            }
            
            // Check if dream title recovery is possible
            const dreams = await loadDreams();
            const validDreams = dreams.filter(d => d.title !== 'Untitled Dream');
            
            // Update the lock screen to show recovery options - FIXED SELECTOR
            const lockCard = document.querySelector('#lockTab > div > div');
            
            if (lockCard) {
                lockCard.innerHTML = `
                    <div class="text-2xl mb-lg">ðŸ”‘</div>
                    <h2 class="text-primary mb-md text-xl">PIN Recovery</h2>
                    <p class="text-secondary mb-lg line-height-relaxed">
                        Choose a recovery method to regain access to your journal:
                    </p>
                    
                    ${validDreams.length >= 3 ? `
                    <div class="card-sm mb-md text-left">
                        <h4 class="text-primary mb-sm">ðŸ“ Dream Title Verification</h4>
                        <p class="text-secondary text-sm mb-sm">
                            Enter 3 of your dream titles exactly as written (case-sensitive)
                        </p>
                        <button data-action="start-lock-screen-title-recovery" class="btn btn-primary btn-small">Verify Dream Titles</button>
                    </div>
                    ` : `
                    <div class="message-base message-warning mb-md text-left">
                        <h4 class="text-warning mb-sm">ðŸ“ Dream Title Verification</h4>
                        <p class="text-secondary text-sm">
                            You need at least 3 dreams with custom titles to use this method. You currently have ${validDreams.length} valid dream titles.
                        </p>
                    </div>
                    `}
                    
                    <div class="card-sm mb-lg text-left">
                        <h4 class="text-warning mb-sm">â° 72-Hour Timer Reset</h4>
                        <p class="text-secondary text-sm mb-sm">
                            Start a timer that will automatically remove your PIN after 72 hours
                        </p>
                        <button data-action="start-lock-screen-timer-recovery" class="btn btn-secondary btn-small">Start Timer Reset</button>
                    </div>
                    
                    <div class="flex-center gap-sm">
                        <button data-action="return-to-lock-screen" class="btn btn-secondary">â† Back to PIN Entry</button>
                    </div>
                    
                    <div id="lockScreenFeedback" class="mt-md p-sm" style="border-radius: var(--border-radius); display: none;"></div>
                `;
            } else {
                showLockScreenMessage('error', 'Error accessing recovery options');
            }
        }
        
        // Show message on lock screen
        function showLockScreenMessage(type, message) {
            const feedbackDiv = document.getElementById('lockScreenFeedback');
            if (!feedbackDiv) return;
            
            // Clear previous state
            feedbackDiv.style.display = 'none';
            feedbackDiv.className = '';
            
            // Set new message
            feedbackDiv.textContent = message;
            feedbackDiv.style.display = 'block';
            
            // Apply styling based on type using CSS variables
            switch(type) {
                case 'error':
                    feedbackDiv.style.background = 'var(--notification-error-bg)';
                    feedbackDiv.style.color = 'var(--error-color)';
                    break;
                case 'success':
                    feedbackDiv.style.background = 'var(--notification-success-bg)';
                    feedbackDiv.style.color = 'var(--success-color)';
                    break;
                case 'info':
                    feedbackDiv.style.background = 'var(--notification-info-bg)';
                    feedbackDiv.style.color = 'var(--info-color)';
                    break;
                case 'warning':
                    feedbackDiv.style.background = 'var(--notification-warning-bg)';
                    feedbackDiv.style.color = 'var(--warning-color)';
                    break;
            }
            
            // Auto-hide success messages
            if (type === 'success') {
                setTimeout(() => {
                    if (feedbackDiv) {
                        feedbackDiv.style.display = 'none';
                    }
                }, CONSTANTS.MESSAGE_DURATION_MEDIUM);
            }
        }
        
        // Return to main lock screen
        function returnToLockScreen() {
            const lockCard = document.querySelector('#lockTab > div > div');
            if (lockCard) {
                // Check if there's an active timer to show instructional text
                const resetTime = getResetTime();
                let timerInstructions = '';
                
                if (resetTime) {
                    const remainingTime = resetTime - Date.now();
                    if (remainingTime > 0) {
                        const hours = Math.ceil(remainingTime / (1000 * 60 * 60));
                        const days = Math.ceil(hours / 24);
                        
                        let timeDisplay = '';
                        if (days > 1) {
                            timeDisplay = `${days} days`;
                        } else if (hours > 1) {
                            timeDisplay = `${hours} hours`;
                        } else {
                            timeDisplay = 'Less than 1 hour';
                        }
                        
                        timerInstructions = `
                            <div class="message-base message-info mb-md text-sm">
                                â° Recovery timer active (${timeDisplay} remaining)<br>
                                <span class="text-sm font-normal">Press "Forgot PIN?" again when timer expires to unlock</span>
                            </div>
                        `;
                    }
                }
                
                lockCard.innerHTML = `
                    <div class="text-4xl mb-lg">ðŸ”’</div>
                    <h2 class="text-primary mb-md text-xl">Journal Locked</h2>
                    <p class="text-secondary mb-lg line-height-relaxed">
                        Your dream journal is protected with a PIN. Enter your PIN to access your dreams and all app features.
                    </p>
                    ${timerInstructions}
                    <input type="password" id="lockScreenPinInput" placeholder="Enter PIN" maxlength="6" class="input-pin w-full mb-lg">
                    <div class="flex-center gap-sm flex-wrap">
                        <button data-action="verify-lock-screen-pin" class="btn btn-primary">ðŸ”“ Unlock Journal</button>
                        <button data-action="show-lock-screen-forgot-pin" class="btn btn-secondary">Forgot PIN?</button>
                    </div>
                    <div id="lockScreenFeedback" class="mt-md p-sm" style="border-radius: var(--border-radius); display: none;"></div>
                `;
                
                // Auto-focus PIN input
                setTimeout(() => {
                    const pinInput = document.getElementById('lockScreenPinInput');
                    if (pinInput) {
                        pinInput.focus();
                    }
                }, CONSTANTS.FOCUS_DELAY_MS);
            }
        }
        
        // Start dream title recovery on lock screen
        async function startLockScreenTitleRecovery() {
            const dreams = await loadDreams();
            const validDreams = dreams.filter(d => d.title !== 'Untitled Dream');
            
            if (validDreams.length < 3) {
                showLockScreenMessage('error', 'You need at least 3 dreams with custom titles to use this recovery method.');
                return;
            }
            
            const lockCard = document.querySelector('#lockTab > div > div');
            if (lockCard) {
                lockCard.innerHTML = `
                    <div class="text-2xl mb-lg">ðŸ“</div>
                    <h2 class="text-primary mb-md text-xl">Verify Dream Titles</h2>
                    <p class="text-secondary mb-lg line-height-relaxed">
                        Enter exactly 3 of your dream titles as they appear in your journal.<br>
                        <em class="text-sm">Must match exactly, including capitalization</em>
                    </p>
                    
                    <input type="text" id="recovery1" placeholder="Dream title 1" class="form-control mb-sm">
                    <input type="text" id="recovery2" placeholder="Dream title 2" class="form-control mb-sm">
                    <input type="text" id="recovery3" placeholder="Dream title 3" class="form-control mb-lg">
                    
                    <div class="flex-center gap-sm flex-wrap">
                        <button data-action="verify-lock-screen-dream-titles" class="btn btn-primary">Verify Titles</button>
                        <button data-action="return-to-lock-screen" class="btn btn-secondary">â† Back</button>
                    </div>
                    
                    <div id="lockScreenFeedback" class="mt-md p-sm" style="border-radius: var(--border-radius); display: none;"></div>
                `;
                
                // Auto-focus first input
                setTimeout(() => {
                    const firstInput = document.getElementById('recovery1');
                    if (firstInput) {
                        firstInput.focus();
                    }
                }, CONSTANTS.FOCUS_DELAY_MS);
            }
        }
        
        // Verify dream titles on lock screen
        async function verifyLockScreenDreamTitles() {
            const title1 = document.getElementById('recovery1')?.value.trim();
            const title2 = document.getElementById('recovery2')?.value.trim();
            const title3 = document.getElementById('recovery3')?.value.trim();
            
            if (!title1 || !title2 || !title3) {
                showLockScreenMessage('error', 'Please enter all 3 dream titles');
                return;
            }
            
            const dreams = await loadDreams();
            const validDreams = dreams.filter(d => d.title !== 'Untitled Dream');
            const dreamTitles = validDreams.map(d => d.title);
            
            // Check if all three titles exist and are different
            const titles = [title1, title2, title3];
            const uniqueTitles = [...new Set(titles)];
            
            if (uniqueTitles.length !== 3) {
                showLockScreenMessage('error', 'Please enter 3 DIFFERENT dream titles. Each title must be unique.');
                return;
            }
            
            const allValid = titles.every(t => dreamTitles.includes(t));
            
            if (allValid) {
                // Success - remove PIN and unlock
                removePinHash();
                removeResetTime(); // Clear any active timer
                
                showLockScreenMessage('success', 'Recovery successful! Your PIN has been removed. Unlocking journal...');
                
                isUnlocked = true;
                isAppLocked = false;
                failedPinAttempts = 0;
                updateTimerWarning(); // Hide warning if it was active
                
                console.log('Lock screen recovery successful - showing all tabs');
                
                setTimeout(() => {
                    // Show all tabs again
                    showAllTabButtons();
                    
                    // Switch to previous tab (or journal if preLockActiveTab is lock)
                    const targetTab = (preLockActiveTab === 'lock') ? 'journal' : preLockActiveTab;
                    switchAppTab(targetTab);
                    updateSecurityControls(); // Simple call, no extra timeout needed
                }, 2000);
                
            } else {
                showLockScreenMessage('error', 'One or more titles did not match. Please try again with exact titles from your dreams.');
                
                // Clear the inputs for retry
                document.getElementById('recovery1').value = '';
                document.getElementById('recovery2').value = '';
                document.getElementById('recovery3').value = '';
                document.getElementById('recovery1').focus();
            }
        }
        
        // Start timer recovery on lock screen
        function startLockScreenTimerRecovery() {
            const lockCard = document.querySelector('#lockTab > div > div');
            if (lockCard) {
                lockCard.innerHTML = `
                    <div class="text-2xl mb-lg">â°</div>
                    <h2 class="text-primary mb-md text-xl">72-Hour Timer Reset</h2>
                    <div class="message-base message-warning mb-lg text-left">
                        <h4 class="mb-sm">âš ï¸ Important Warning</h4>
                        <p class="mb-sm line-height-relaxed">
                            This will start a 72-hour countdown. After the timer expires, your PIN will be automatically removed.
                        </p>
                        <p style="margin: 0; font-weight: 600;">
                            Your dreams will remain safe and will not be deleted.
                        </p>
                    </div>
                    
                    <p class="text-secondary mb-lg line-height-relaxed">
                        Do you want to start the 72-hour recovery timer?
                    </p>
                    
                    <div class="flex-center gap-sm flex-wrap">
                        <button data-action="confirm-lock-screen-timer" class="btn btn-primary">Start Timer</button>
                        <button data-action="return-to-lock-screen" class="btn btn-secondary">â† Cancel</button>
                    </div>
                    
                    <div id="lockScreenFeedback" class="mt-md p-sm" style="border-radius: var(--border-radius); display: none;"></div>
                `;
            }
        }
        
        // Confirm timer recovery on lock screen
        function confirmLockScreenTimer() {
            const resetTime = Date.now() + (CONSTANTS.PIN_RESET_HOURS * 60 * 60 * 1000);
            storeResetTime(resetTime);
            updateTimerWarning(); // Show warning banner
            
            showLockScreenMessage('success', '72-hour recovery timer started! You can check back later or continue using dream title recovery.');
            
            setTimeout(() => {
                returnToLockScreen();
            }, 3000);
        }

        // Show PIN overlay
        function showPinOverlay() {
            // If already unlocked, don't show overlay
            if (isUnlocked && isPinSetup()) {
                return;
            }
            
            // Reset failed attempts when showing overlay fresh
            failedPinAttempts = 0;
            
            document.getElementById('pinOverlay').style.display = 'flex';
            setTimeout(() => {
                document.getElementById('pinInput').focus();
            }, CONSTANTS.FOCUS_DELAY_MS);
        }

        // Hide PIN overlay
        function hidePinOverlay() {
            // Reset the overlay to default state when hiding
            resetPinOverlay();
            
            // Reset failed attempts when closing overlay
            failedPinAttempts = 0;
            
            document.getElementById('pinOverlay').style.display = 'none';
            document.getElementById('pinInput').value = '';
        }

        // Show PIN setup
        function showPinSetup() {
            const title = document.getElementById('pinTitle');
            const message = document.getElementById('pinMessage');
            const setupLink = document.getElementById('pinSetupLink');
            const cancelBtn = document.getElementById('cancelPinBtn');
            
            if (isPinSetup()) {
                title.textContent = 'âš™ï¸ Change PIN';
                message.textContent = 'Enter your current PIN to change it.';
                setupLink.style.display = 'none';
                cancelBtn.style.display = 'inline-block';
            } else {
                title.textContent = 'âš™ï¸ Setup PIN';
                message.textContent = 'Create a 4-6 digit PIN to protect your dreams.';
                setupLink.style.display = 'none';
                cancelBtn.style.display = 'inline-block';
            }
            
            document.getElementById('pinInput').placeholder = isPinSetup() ? 'Current PIN' : 'New PIN (4-6 digits)';
            
            // Use the correct action for processing PIN setup
            const unlockBtn = document.getElementById('pinMainBtn');
            unlockBtn.dataset.action = 'process-pin-setup';
            unlockBtn.textContent = isPinSetup() ? 'Verify Current PIN' : 'Continue';
            document.getElementById('pinOverlay').style.display = 'flex';
            setTimeout(() => {
                document.getElementById('pinInput').focus();
            }, CONSTANTS.FOCUS_DELAY_MS);
        }

        // Setup new PIN (multi-step process) - UPDATED for secure hashing
        async function setupPin() {
            const enteredPin = document.getElementById('pinInput').value;
            const title = document.getElementById('pinTitle');
            const message = document.getElementById('pinMessage');
            const unlockBtn = document.getElementById('pinMainBtn');
            
            if (!enteredPin || enteredPin.length < CONSTANTS.PIN_MIN_LENGTH || enteredPin.length > CONSTANTS.PIN_MAX_LENGTH) {
                message.textContent = `PIN must be ${CONSTANTS.PIN_MIN_LENGTH}-${CONSTANTS.PIN_MAX_LENGTH} digits. Please try again.`;
                message.style.color = 'var(--error-color)';
                document.getElementById('pinInput').value = '';
                return;
            }
            if (!/^\d+$/.test(enteredPin)) {
                message.textContent = 'PIN must contain only numbers. Please try again.';
                message.style.color = 'var(--error-color)';
                document.getElementById('pinInput').value = '';
                return;
            }
            
            if (isPinSetup()) {
                // Step 1: Verify current PIN
                try {
                    const storedData = getStoredPinData();
                    const isValid = await verifyPinHash(enteredPin, storedData);
                    
                    if (!isValid) {
                        message.textContent = 'Current PIN is incorrect. Please try again.';
                        message.style.color = 'var(--error-color)';
                        document.getElementById('pinInput').value = '';
                        return;
                    }
                    
                    // Move to step 2: Enter new PIN
                    title.textContent = 'âš™ï¸ Enter New PIN';
                    message.textContent = 'Enter your new 4-6 digit PIN.';
                    message.style.color = 'var(--text-primary)';
                    document.getElementById('pinInput').placeholder = 'New PIN (4-6 digits)';
                    document.getElementById('pinInput').value = '';
                    unlockBtn.dataset.action = 'setup-new-pin';
                    unlockBtn.textContent = 'Continue';
                } catch (error) {
                    console.error('Error verifying current PIN:', error);
                    message.textContent = 'Error verifying current PIN. Please try again.';
                    message.style.color = 'var(--error-color)';
                    document.getElementById('pinInput').value = '';
                }
            } else {
                // New PIN setup - go to confirmation step
                // Store temporarily and ask for confirmation
                window.tempNewPin = enteredPin;
                title.textContent = 'âš™ï¸ Confirm PIN';
                message.textContent = 'Enter the same PIN again to confirm.';
                message.style.color = '#374151';
                document.getElementById('pinInput').placeholder = 'Confirm PIN';
                document.getElementById('pinInput').value = '';
                unlockBtn.dataset.action = 'confirm-new-pin';
                unlockBtn.textContent = 'Setup PIN';
            }
        }

        // Step 2 of change PIN: Enter new PIN
        function setupNewPin() {
            const enteredPin = document.getElementById('pinInput').value;
            const message = document.getElementById('pinMessage');
            
            if (!enteredPin || enteredPin.length < CONSTANTS.PIN_MIN_LENGTH || enteredPin.length > CONSTANTS.PIN_MAX_LENGTH) {
                message.textContent = `PIN must be ${CONSTANTS.PIN_MIN_LENGTH}-${CONSTANTS.PIN_MAX_LENGTH} digits. Please try again.`;
                message.style.color = 'var(--error-color)';
                document.getElementById('pinInput').value = '';
                return;
            }
            if (!/^\d+$/.test(enteredPin)) {
                message.textContent = 'PIN must contain only numbers. Please try again.';
                message.style.color = 'var(--error-color)';
                document.getElementById('pinInput').value = '';
                return;
            }
            
            // Store temporarily and ask for confirmation
            window.tempNewPin = enteredPin;
            const title = document.getElementById('pinTitle');
            title.textContent = 'âš™ï¸ Confirm New PIN';
            message.textContent = 'Enter the same PIN again to confirm.';
            message.style.color = 'var(--text-primary)';
            document.getElementById('pinInput').placeholder = 'Confirm new PIN';
            document.getElementById('pinInput').value = '';
            const unlockBtn = document.getElementById('pinMainBtn');
            unlockBtn.dataset.action = 'confirm-new-pin';
            unlockBtn.textContent = 'Change PIN';
        }

        // Final step: Confirm the new PIN - UPDATED for secure hashing
        async function confirmNewPin() {
            const enteredPin = document.getElementById('pinInput').value;
            const message = document.getElementById('pinMessage');
            
            if (enteredPin !== window.tempNewPin) {
                message.textContent = 'PINs do not match. Please start over.';
                message.style.color = 'var(--error-color)';
                setTimeout(() => {
                    resetPinOverlay();
                    showPinSetup();
                }, 2000);
                return;
            }
            
            try {
                // Save the PIN with new secure system
                const success = await storePinHash(window.tempNewPin);
                
                if (success) {
                    const title = document.getElementById('pinTitle');
                    title.textContent = 'âœ… PIN Setup Complete';
                    
                    // Show different success message based on storage type
                    if (isLocalStorageAvailable()) {
                        message.textContent = 'Secure PIN has been set successfully! Your dreams are now protected with advanced encryption.';
                    } else {
                        message.textContent = 'Secure PIN has been set successfully using memory storage! Your dreams are now protected. (Note: PIN will reset if you refresh the page)';
                    }
                    message.style.color = 'var(--success-color)';
                    
                    // Hide input and show close option
                    document.getElementById('pinInput').style.display = 'none';
                    
                    const unlockBtn = document.getElementById('pinMainBtn');
                    const cancelBtn = document.getElementById('cancelPinBtn');
                    
                    if (unlockBtn) {
                        unlockBtn.textContent = 'Close';
                        unlockBtn.dataset.action = 'complete-pin-setup';
                    }
                    
                    if (cancelBtn) {
                        cancelBtn.style.display = 'none';
                    }
                    
                    // Clean up
                    delete window.tempNewPin;
                    isUnlocked = true; // User is now authenticated
                } else {
                    message.textContent = 'Error: Failed to save secure PIN. Please try again or restart the browser.';
                    message.style.color = 'var(--error-color)';
                    
                    // Offer to restart the process
                    setTimeout(() => {
                        message.textContent += ' Click Cancel to try again.';
                    }, 2000);
                }
            } catch (error) {
                console.error('Error setting up secure PIN:', error);
                message.textContent = 'Error: Failed to setup secure PIN. Please try again.';
                message.style.color = 'var(--error-color)';
            }
        }

        // Complete PIN setup and close overlay
        async function completePinSetup() {
            // Ensure overlay is properly reset for future use
            resetPinOverlay();
            hidePinOverlay();
            
            // Reset failed attempts since PIN setup was successful
            failedPinAttempts = 0;
            
            // User is now authenticated and unlocked
            isUnlocked = true;
            isAppLocked = false;
            
            console.log('PIN setup complete - ensuring tabs are visible');
            
            // Ensure all tabs are visible (in case they were hidden)
            showAllTabButtons();
            
            updateSecurityControls();
            await displayDreams(); // Refresh to show unlocked dreams
        }

        // Reset PIN overlay to default state
        function resetPinOverlay() {
            const title = document.getElementById('pinTitle');
            const message = document.getElementById('pinMessage');
            const setupLink = document.getElementById('pinSetupLink');
            const removePinLink = document.getElementById('removePinLink');
            const forgotPinLink = document.getElementById('forgotPinLink');
            const cancelBtn = document.getElementById('cancelPinBtn');
            const unlockBtn = document.getElementById('pinMainBtn');
            const pinInput = document.getElementById('pinInput');
            
            // Reset failed attempts when overlay is reset
            failedPinAttempts = 0;
            
            // Remove any timer button if it exists
            const timerBtn = document.getElementById('timerBtn');
            if (timerBtn) {
                timerBtn.remove();
            }
            
            // Reset text content
            title.textContent = 'ðŸ”’ Enter PIN';
            message.textContent = 'Your dreams are protected. Enter your PIN to access them.';
            message.style.color = 'var(--text-primary)'; // Reset color
            
            // Reset visibility based on whether PIN is setup and if user is unlocked
            if (isPinSetup()) {
                setupLink.style.display = 'none';
                removePinLink.style.display = isUnlocked ? 'block' : 'none';
                forgotPinLink.style.display = 'none'; // Reset to hidden since attempts are reset
                cancelBtn.style.display = 'inline-block'; // Always show cancel for locked state
            } else {
                setupLink.style.display = 'block';
                removePinLink.style.display = 'none';
                forgotPinLink.style.display = 'none';
                cancelBtn.style.display = 'inline-block';
            }
            
            // Reset input
            pinInput.style.display = 'block'; // Make sure input is visible
            pinInput.placeholder = 'Enter PIN';
            pinInput.value = '';
            
            // Reset button
            if (unlockBtn) {
                unlockBtn.dataset.action = 'verify-pin';
                unlockBtn.textContent = 'Unlock';
            }
        }

        // Toggle lock state
        async function toggleLock() {
            if (!isPinSetup()) {
                // No PIN set - show setup dialog with helpful message
                const container = document.querySelector('.main-content');
                if (container) {
                    const msg = document.createElement('div');
                    msg.style.cssText = `
                        background: var(--notification-info-bg);
                        color: var(--info-color);
                        padding: 15px;
                        border-radius: var(--border-radius);
                        margin-bottom: 20px;
                        font-weight: var(--font-weight-semibold);
                        text-align: center;
                    `;
                    msg.textContent = 'First, set up a PIN to protect your dreams, then you can lock your journal.';
                    container.insertBefore(msg, container.firstChild);
                    
                    setTimeout(() => {
                        if (msg && msg.parentNode) {
                            msg.remove();
                        }
                    }, 4000);
                }
                
                // Show PIN setup dialog
                showPinSetup();
                return;
            }
            
            if (isUnlocked && !isAppLocked) {
                // User is unlocked and has PIN - lock the app
                isUnlocked = false;
                isAppLocked = true;
                preLockActiveTab = activeAppTab; // Remember which tab they were on
                
                console.log('Locking app - hiding other tabs');
                
                // Hide other tabs and switch to lock screen
                hideAllTabButtons();
                switchAppTab('lock');
                updateSecurityControls();
            } else {
                // This case shouldn't happen much since locked users see the lock screen
                // But if it does, show unlock dialog
                showPinOverlay();
            }
        }

        // DREAM CRUD OPERATIONS (CREATE, READ, UPDATE, DELETE)
        
        // Save a new dream entry - optimized to use individual operations
        async function saveDream() {
            const titleElement = document.getElementById('dreamTitle');
            const contentElement = document.getElementById('dreamContent');
            const dreamDateElement = document.getElementById('dreamDate');
            const isLucidElement = document.getElementById('isLucid');
            const emotionsElement = document.getElementById('dreamEmotions');
            const tagsElement = document.getElementById('dreamTags');
            const dreamSignsElement = document.getElementById('dreamSigns');
            
            // Safety checks for form elements
            if (!titleElement || !contentElement || !dreamDateElement || !isLucidElement || !emotionsElement || !tagsElement || !dreamSignsElement) {
                return;
            }
            
            const title = titleElement.value.trim();
            const content = contentElement.value.trim();
            const dreamDate = dreamDateElement.value;
            const isLucid = isLucidElement.checked;
            const emotions = emotionsElement.value.trim();
            const tags = parseTagsFromInput(tagsElement.value);
            const dreamSigns = parseTagsFromInput(dreamSignsElement.value);
            
            if (!content) {
                // Show error message inline instead of alert
                                    contentElement.style.borderColor = 'var(--error-color)';
                const errorMsg = document.createElement('div');
                errorMsg.style.cssText = `
                    color: #dc2626;
                    font-size: 14px;
                    margin-top: 5px;
                `;
                errorMsg.textContent = 'Please enter a dream description before saving.';
                contentElement.parentElement.appendChild(errorMsg);
                
                setTimeout(() => {
                    try {
                        if (contentElement) {
                            contentElement.style.borderColor = 'var(--border-color)';
                        }
                        if (errorMsg && errorMsg.parentNode) {
                            errorMsg.remove();
                        }
                    } catch (e) {
                        // Ignore cleanup errors
                    }
                }, 3000);
                return;
            }
            
            // Use custom date if provided, otherwise current time
            let timestamp, dateForDisplay;
            
            if (dreamDate) {
                try {
                    dateForDisplay = new Date(dreamDate);
                    if (isNaN(dateForDisplay.getTime())) {
                        // Invalid date, fallback to current time
                        dateForDisplay = new Date();
                    }
                    timestamp = dateForDisplay.toISOString();
                } catch (error) {
                    // Error parsing date, fallback to current time
                    dateForDisplay = new Date();
                    timestamp = dateForDisplay.toISOString();
                }
            } else {
                dateForDisplay = new Date();
                timestamp = dateForDisplay.toISOString();
            }
            
            const newDream = {
                id: generateUniqueId(),
                title: title || 'Untitled Dream',
                content: content,
                emotions: emotions, // Add emotions to the dream data
                tags: tags, // Add tags array
                dreamSigns: dreamSigns, // Add dream signs array
                timestamp: timestamp,
                isLucid: isLucid,
                dateString: dateForDisplay.toLocaleDateString('en-AU', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                })
            };
            
            // Try to add directly to IndexedDB first for better performance
            let saveSuccess = false;
            if (isIndexedDBAvailable()) {
                saveSuccess = await addDreamToIndexedDB(newDream);
            }
            
            // If IndexedDB failed or unavailable, fall back to loading all and saving
            if (!saveSuccess) {
                const dreams = await loadDreams();
                dreams.unshift(newDream);
                await saveDreams(dreams);
            }
            
            // Clear form
            if (titleElement) titleElement.value = '';
            if (contentElement) contentElement.value = '';
            if (dreamDateElement) dreamDateElement.value = '';
            if (isLucidElement) isLucidElement.checked = false;
            if (emotionsElement) emotionsElement.value = '';
            if (tagsElement) tagsElement.value = '';
            if (dreamSignsElement) dreamSignsElement.value = '';
            
            // Reset date to current time for next entry
            if (dreamDateElement) {
                const now = new Date();
                const datetimeLocalValue = now.toISOString().slice(0, CONSTANTS.DATETIME_LOCAL_SLICE_LENGTH);
                dreamDateElement.value = datetimeLocalValue;
            }
            
            // Reset to page 1 to show the new dream
            currentPage = 1;
            
            // Show success message
            const form = document.querySelector('.entry-form');
            if (form) {
                createInlineMessage('success', 'Dream saved successfully!', {
                    container: form,
                    position: 'bottom',
                    duration: CONSTANTS.MESSAGE_DURATION_SHORT
                });
            }
            
            // Refresh display
            await displayDreams();
        }

        // Display dreams in the container with pagination (Refactored and Optimized)
        async function displayDreams() {
            return withMutex('displayDreams', displayDreamsInternal);
        }
        
        // Internal display dreams function (called with mutex protection)
        async function displayDreamsInternal() {
            try {
                // Note: PIN protection is now handled by lock screen tab
                // No need to check isUnlocked here since locked users can't access this tab
                
                // Get filter values
                const { searchTerm, filterType, sortType, limitValue } = getFilterValues();
                const dreams = await loadDreams();
                const container = document.getElementById('entriesContainer');
                
                if (!container) return;
                
                // Show loading for large datasets
                if (Array.isArray(dreams) && dreams.length > CONSTANTS.LARGE_DATASET_THRESHOLD) {
                    showLoadingMessage(container, dreams.length);
                    await new Promise(resolve => setTimeout(resolve, 0)); // Give UI a chance to update
                }
                
                // Filter and sort dreams
                let filteredDreams = filterDreams(dreams, searchTerm, filterType);
                filteredDreams = sortDreams(filteredDreams, sortType);
                
                // Handle no results
                if (filteredDreams.length === 0) {
                    showNoResultsMessage(container, filterType, searchTerm);
                    clearPagination();
                    return;
                }
                
                // Calculate pagination
                const { paginatedDreams, totalPages, totalDreams } = calculatePagination(filteredDreams, limitValue);
                
                // Render dreams
                container.innerHTML = paginatedDreams.map(renderDreamHTML).filter(html => html).join('');
                
                // Render pagination
                renderPaginationHTML(limitValue, totalPages, totalDreams, paginatedDreams);
                
            } finally {
                hideSearchLoading();
            }
        }
        
        // Helper function to get filter values
        function getFilterValues() {
            const searchBox = document.getElementById('searchBox');
            const filterSelect = document.getElementById('filterSelect');
            const sortSelect = document.getElementById('sortSelect');
            const limitSelect = document.getElementById('limitSelect');
            
            return {
                searchTerm: (searchBox ? searchBox.value : '').toLowerCase(),
                filterType: filterSelect ? filterSelect.value : 'all',
                sortType: sortSelect ? sortSelect.value : 'newest',
                limitValue: limitSelect ? limitSelect.value : '10'
            };
        }
        
        // Helper function to show loading message
        function showLoadingMessage(container, dreamCount) {
            container.innerHTML = `
                <div class="loading-state large">
                    <div>ðŸŒ™</div>
                    <div>Loading ${dreamCount} dreams...</div>
                </div>
            `;
        }
        
        // Helper function to show no results message
        function showNoResultsMessage(container, filterType, searchTerm) {
            const filterText = filterType === 'all' ? '' : 
                filterType === 'lucid' ? ' lucid' : ' non-lucid';
            
            let message;
            if (searchTerm) {
                message = `No${filterText} dreams found matching your search.`;
            } else if (filterType === 'lucid') {
                message = 'No lucid dreams recorded yet. Mark dreams as lucid when you achieve lucidity!';
            } else if (filterType === 'non-lucid') {
                message = 'No non-lucid dreams found.';
            } else {
                message = 'No dreams recorded yet. Start by adding your first dream above!';
            }
            
            container.innerHTML = `<div class="no-entries">${message}</div>`;
        }
        
        // Helper function to clear pagination
        function clearPagination() {
            const paginationContainer = document.getElementById('paginationContainer');
            if (paginationContainer) {
                paginationContainer.innerHTML = '';
            }
        }

        // Render pagination controls (Updated for Event Delegation)
        function renderPagination(page, totalPages, totalItems, currentItems) {
            const limitSelect = document.getElementById('limitSelect');
            const limitValue = limitSelect ? limitSelect.value : '10';
            const itemsPerPage = Math.max(1, parseInt(limitValue) || 10);
            
            const startItem = (page - 1) * itemsPerPage + 1;
            const endItem = startItem + currentItems - 1;
            
            let paginationHTML = `
                <div class="pagination">
                    <button class="pagination-btn" data-action="go-to-page" data-page="${page - 1}" ${page <= 1 ? 'disabled' : ''}>
                        â† Previous
                    </button>
                    
                    <div class="page-numbers">
            `;
            
            // Generate page numbers with ellipsis
            const pageNumbers = generatePageNumbers(page, totalPages);
            pageNumbers.forEach(item => {
                if (item === '...') {
                    paginationHTML += `<span class="page-ellipsis">...</span>`;
                } else {
                    const isActive = item === page ? 'active' : '';
                    paginationHTML += `<button class="page-btn ${isActive}" data-action="go-to-page" data-page="${item}">${item}</button>`;
                }
            });
            
            paginationHTML += `
                    </div>
                    
                    <button class="pagination-btn" data-action="go-to-page" data-page="${page + 1}" ${page >= totalPages ? 'disabled' : ''}>
                        Next â†’
                    </button>
                </div>
                
                <div class="pagination-info" style="text-align: center; margin-top: 10px;">
                    Showing ${startItem}-${endItem} of ${totalItems} dreams
                </div>
            `;
            
            return paginationHTML;
        }

        // Generate smart page numbers with ellipsis
        function generatePageNumbers(currentPage, totalPages) {
            const pages = [];
            
            // Validate inputs
            if (!currentPage || !totalPages || currentPage < 1 || totalPages < 1) {
                return [1];
            }
            
            if (totalPages <= CONSTANTS.PAGINATION_MAX_VISIBLE_PAGES) {
                // Show all pages if 7 or fewer
                for (let i = 1; i <= totalPages; i++) {
                    pages.push(i);
                }
            } else {
                // Always show first page
                pages.push(1);
                
                if (currentPage > CONSTANTS.PAGINATION_CURRENT_PAGE_PROXIMITY) {
                    pages.push('...');
                }
                
                // Show pages around current page
                const start = Math.max(2, currentPage - 1);
                const end = Math.min(totalPages - 1, currentPage + 1);
                
                for (let i = start; i <= end; i++) {
                    if (!pages.includes(i)) {
                        pages.push(i);
                    }
                }
                
                if (currentPage < totalPages - CONSTANTS.PAGINATION_ELLIPSIS_THRESHOLD) {
                    pages.push('...');
                }
                
                // Always show last page
                if (!pages.includes(totalPages)) {
                    pages.push(totalPages);
                }
            }
            
            return pages;
        }

        // Navigate to specific page
        async function goToPage(page) {
            const limitSelect = document.getElementById('limitSelect');
            const limitValue = limitSelect ? limitSelect.value : '10';
            
            if (limitValue === 'all' || limitValue === 'endless') return; // No pagination when showing all or endless
            
            try {
                const totalDreamsCount = await getFilteredDreamsCount();
                const itemsPerPage = Math.max(1, parseInt(limitValue) || 10);
                const totalPages = Math.max(1, Math.ceil(totalDreamsCount / itemsPerPage));
                
                // Validate page number
                const pageNum = parseInt(page);
                if (isNaN(pageNum) || pageNum < 1 || pageNum > totalPages) return;
                
                currentPage = pageNum;
                await displayDreams();
            } catch (error) {
                console.error('Error navigating to page:', error);
                // Don't update page on error to prevent broken state
            }
        }

        // Get count of filtered dreams
        async function getFilteredDreamsCount() {
            try {
                const searchBox = document.getElementById('searchBox');
                const filterSelect = document.getElementById('filterSelect');
                
                const searchTerm = (searchBox && searchBox.value ? searchBox.value : '').toLowerCase();
                const filterType = filterSelect && filterSelect.value ? filterSelect.value : 'all';
                const dreams = await loadDreams();
                
                if (!Array.isArray(dreams)) return 0;
                
                return dreams.filter(dream => {
                    // Safety checks for dream data
                    if (!dream || typeof dream !== 'object') return false;
                    
                    const title = (dream.title || '').toString();
                    const content = (dream.content || '').toString();
                    const emotions = (dream.emotions || '').toString();
                    const tags = Array.isArray(dream.tags) ? dream.tags.join(' ') : '';
                    const dreamSigns = Array.isArray(dream.dreamSigns) ? dream.dreamSigns.join(' ') : '';
                    
                    const matchesSearch = !searchTerm || 
                        title.toLowerCase().includes(searchTerm) ||
                        content.toLowerCase().includes(searchTerm) ||
                        emotions.toLowerCase().includes(searchTerm) ||
                        tags.toLowerCase().includes(searchTerm) ||
                        dreamSigns.toLowerCase().includes(searchTerm);
                    
                    const matchesFilter = filterType === 'all' || 
                        (filterType === 'lucid' && Boolean(dream.isLucid)) ||
                        (filterType === 'non-lucid' && !Boolean(dream.isLucid));
                    
                    return matchesSearch && matchesFilter;
                }).length;
            } catch (error) {
                console.error('Error counting filtered dreams:', error);
                return 0;
            }
        }

        // Reset to page 1 when filters change
        async function resetToPageOne() {
            currentPage = 1;
            
            // Reset endless scroll when filters change
            if (endlessScrollState.enabled) {
                endlessScrollState.loaded = 5;
                endlessScrollState.loading = false;
            }
            
            await displayDreams();
        }

        // Edit a dream entry (Updated for Event Delegation)
        async function editDream(dreamId) {
            try {
                const dreams = await loadDreams();
                // Handle both string and numeric IDs for backward compatibility
                const dream = dreams.find(d => d.id === dreamId || d.id === dreamId.toString() || d.id === Number(dreamId));
                if (!dream) {
                    console.error('Dream not found for ID:', dreamId);
                    return;
                }
                
                const entryElement = document.getElementById(`entry-${dreamId}`);
                const titleElement = document.getElementById(`title-${dreamId}`);
                const contentElement = document.getElementById(`content-${dreamId}`);
                
                if (!entryElement || !titleElement || !contentElement) {
                    console.error('Required DOM elements not found for dream:', dreamId);
                    return;
                }
                
                // Convert stored timestamp back to datetime-local format
                let datetimeLocalValue = '';
                try {
                    const dreamDateTime = new Date(dream.timestamp);
                    if (!isNaN(dreamDateTime.getTime())) {
                        datetimeLocalValue = dreamDateTime.toISOString().slice(0, CONSTANTS.DATETIME_LOCAL_SLICE_LENGTH);
                    } else {
                        datetimeLocalValue = new Date().toISOString().slice(0, CONSTANTS.DATETIME_LOCAL_SLICE_LENGTH);
                    }
                } catch (error) {
                    // If timestamp is invalid, use current time
                    datetimeLocalValue = new Date().toISOString().slice(0, CONSTANTS.DATETIME_LOCAL_SLICE_LENGTH);
                }
                
                // Replace with editable inputs
                // entryElement.classList.add('edit-mode');
                entryElement.classList.add('inline-edit-form'); // Updated to use compact inline edit style
                
                const safeDreamId = escapeAttr(dreamId.toString());
                
                titleElement.innerHTML = `
                    <input type="text" class="form-control entry-title-input" id="edit-title-${safeDreamId}" value="${escapeAttr(dream.title || '')}">
                `;
                
                const safeEmotions = escapeAttr(dream.emotions || '');
                const safeTags = Array.isArray(dream.tags) ? escapeAttr(dream.tags.join(', ')) : '';
                const safeDreamSigns = Array.isArray(dream.dreamSigns) ? escapeAttr(dream.dreamSigns.join(', ')) : '';
                const safeContent = escapeAttr(dream.content || '');
                
                contentElement.innerHTML = `
                    <div class="form-group">
                        <label for="edit-date-${safeDreamId}">Dream Date & Time</label>
                        <input type="datetime-local" class="form-control" value="${datetimeLocalValue}" id="edit-date-${safeDreamId}">
                    </div>
                    <div class="form-group">
                        <label for="edit-emotions-${safeDreamId}">Emotions Experienced</label>
                        <input type="text" class="form-control" id="edit-emotions-${safeDreamId}" placeholder="e.g., happy, anxious, excited, confused" value="${safeEmotions}">
                    </div>
                    <div class="form-group">
                        <label for="edit-tags-${safeDreamId}">Tags & Themes</label>
                        <input type="text" class="form-control" id="edit-tags-${safeDreamId}" placeholder="e.g., family, flying, school, animals" value="${safeTags}">
                    </div>
                    <div class="form-group">
                        <label for="edit-dreamsigns-${safeDreamId}">Dream Signs</label>
                        <input type="text" class="form-control" id="edit-dreamsigns-${safeDreamId}" placeholder="e.g., flying, text-changing, deceased-alive" value="${safeDreamSigns}">
                    </div>
                    <div class="lucid-checkbox">
                        <input type="checkbox" id="edit-lucid-${safeDreamId}" ${dream.isLucid ? 'checked' : ''}>
                        <label for="edit-lucid-${safeDreamId}">This was a lucid dream âœ¨</label>
                    </div>
                    <textarea class="form-control entry-content-input" id="edit-content-${safeDreamId}">${safeContent}</textarea>
                    <div class="edit-actions">
                        <button data-action="save-edit" data-dream-id="${safeDreamId}" class="btn btn-primary btn-small">Save Changes</button>
                        <button data-action="cancel-edit" data-dream-id="${safeDreamId}" class="btn btn-secondary btn-small">Cancel</button>
                    </div>
                `;
                
                // Focus on the content textarea after DOM is updated
                setTimeout(() => {
                    const textareaElement = document.getElementById(`edit-content-${safeDreamId}`);
                    if (textareaElement) {
                        textareaElement.focus();
                        textareaElement.setSelectionRange(textareaElement.value.length, textareaElement.value.length);
                    }
                }, CONSTANTS.FOCUS_DELAY_MS);
                
            } catch (error) {
                console.error('Error editing dream:', error);
                
                createInlineMessage('error', 'Error editing dream. Please try again.', {
                    container: document.querySelector('.main-content'),
                    position: 'top',
                    duration: 3000
                });
            }
        }

        // Save dream edit - optimized to use individual update
        async function saveDreamEdit(dreamId) {
            try {
                const newTitleElement = document.getElementById(`edit-title-${dreamId}`);
                const newContentElement = document.getElementById(`edit-content-${dreamId}`);
                const newDateElement = document.getElementById(`edit-date-${dreamId}`);
                const newIsLucidElement = document.getElementById(`edit-lucid-${dreamId}`);
                const newEmotionsElement = document.getElementById(`edit-emotions-${dreamId}`);
                const newTagsElement = document.getElementById(`edit-tags-${dreamId}`);
                const newDreamSignsElement = document.getElementById(`edit-dreamsigns-${dreamId}`);
                
                if (!newTitleElement || !newContentElement || !newDateElement || !newIsLucidElement || 
                    !newEmotionsElement || !newTagsElement || !newDreamSignsElement) {
                    throw new Error('Required form elements not found');
                }
                
                const newTitle = newTitleElement.value.trim();
                const newContent = newContentElement.value.trim();
                const newDate = newDateElement.value;
                const newIsLucid = newIsLucidElement.checked;
                const newEmotions = newEmotionsElement.value.trim();
                const newTags = parseTagsFromInput(newTagsElement.value);
                const newDreamSigns = parseTagsFromInput(newDreamSignsElement.value);
                
                if (!newContent) {
                    // Show error inline in the edit area
                    const contentField = newContentElement;
                    contentField.style.borderColor = 'var(--error-color)';
                    const existingError = contentField.parentElement.querySelector('.edit-error');
                    if (!existingError) {
                        const errorMsg = document.createElement('div');
                        errorMsg.className = 'edit-error';
                        errorMsg.style.cssText = `
                            color: var(--error-color);
                            font-size: 14px;
                            margin-top: 5px;
                        `;
                        errorMsg.textContent = 'Dream description cannot be empty.';
                        contentField.parentElement.appendChild(errorMsg);
                    }
                    
                    setTimeout(() => {
                        contentField.style.borderColor = 'var(--border-color)';
                        const error = contentField.parentElement.querySelector('.edit-error');
                        if (error) error.remove();
                    }, 3000);
                    return;
                }
                
                const dreams = await loadDreams();
                // Handle both string and numeric IDs for backward compatibility
                const dreamIndex = dreams.findIndex(d => 
                    d.id === dreamId || 
                    d.id === dreamId.toString() || 
                    d.id === Number(dreamId)
                );
                
                if (dreamIndex === -1) {
                    throw new Error('Dream not found in database');
                }
                
                // Update timestamp and dateString if date was changed
                let timestamp, dateForDisplay;
                try {
                    if (newDate) {
                        dateForDisplay = new Date(newDate);
                        if (isNaN(dateForDisplay.getTime())) {
                            dateForDisplay = new Date(dreams[dreamIndex].timestamp);
                        }
                        timestamp = dateForDisplay.toISOString();
                    } else {
                        timestamp = dreams[dreamIndex].timestamp;
                        dateForDisplay = new Date(timestamp);
                    }
                } catch (dateError) {
                    console.warn('Error parsing date, using original:', dateError);
                    timestamp = dreams[dreamIndex].timestamp;
                    dateForDisplay = new Date(timestamp);
                }
                
                const updatedDream = {
                    ...dreams[dreamIndex],
                    title: newTitle || 'Untitled Dream',
                    content: newContent,
                    emotions: newEmotions,
                    tags: newTags,
                    dreamSigns: newDreamSigns,
                    isLucid: newIsLucid,
                    timestamp: timestamp,
                    dateString: dateForDisplay.toLocaleDateString('en-AU', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    }),
                    lastModified: new Date().toISOString()
                };
                
                // Try to update directly in IndexedDB first
                let updateSuccess = false;
                if (isIndexedDBAvailable()) {
                    updateSuccess = await updateDreamInIndexedDB(updatedDream);
                }
                
                // If IndexedDB failed, fall back to updating all
                if (!updateSuccess) {
                    dreams[dreamIndex] = updatedDream;
                    await saveDreams(dreams);
                }
                
                await displayDreams();
                
            } catch (error) {
                console.error('Error saving dream edit:', error);
                
                createInlineMessage('error', 'Error saving changes: ' + error.message, {
                    container: document.querySelector('.main-content'),
                    position: 'top',
                    duration: 5000
                });
            }
        }

        // Cancel dream edit
        async function cancelDreamEdit(dreamId) {
            await displayDreams();
        }

        // Show delete confirmation button (Updated for Event Delegation)
        function deleteDream(dreamId) {
            // Clear any existing timeout for this dream
            if (deleteTimeouts[dreamId]) {
                clearTimeout(deleteTimeouts[dreamId]);
                delete deleteTimeouts[dreamId];
            }
            
            const entryElement = document.getElementById(`entry-${dreamId}`);
            if (!entryElement) return; // Safety check
            
            const actionsElement = entryElement.querySelector('.entry-actions');
            if (!actionsElement) return; // Safety check
            
            // Add pending delete styling
            entryElement.classList.add('delete-pending');
            
            // Replace delete button with confirm button
            const deleteBtn = actionsElement.querySelector(`button[data-dream-id="${dreamId}"][data-action="delete-dream"]`);
            if (deleteBtn) {
                deleteBtn.outerHTML = `<button data-action="confirm-delete" data-dream-id="${dreamId}" class="btn btn-confirm-delete btn-small">Confirm Delete</button>`;
            }
            
            // Set timeout to revert after specified time
            deleteTimeouts[dreamId] = setTimeout(() => {
                cancelDelete(dreamId);
            }, CONSTANTS.MESSAGE_DURATION_EXTENDED);
        }

        // Actually delete the dream after confirmation - optimized for IndexedDB (with mutex protection)
        async function confirmDelete(dreamId) {
            return withMutex('deleteOperations', async () => {
                try {
                    // Clear the timeout
                    if (deleteTimeouts[dreamId]) {
                        clearTimeout(deleteTimeouts[dreamId]);
                        delete deleteTimeouts[dreamId];
                    }
                    
                    const dreams = await loadDreams();
                    // Handle both string and numeric IDs for backward compatibility
                    const dream = dreams.find(d => 
                        d.id === dreamId || 
                        d.id === dreamId.toString() || 
                        d.id === Number(dreamId)
                    );
                    
                    if (!dream) {
                        // Show error inline
                        const entryElement = document.getElementById(`entry-${dreamId}`);
                        if (entryElement) {
                            const errorMsg = document.createElement('div');
                            errorMsg.style.cssText = `
                                background: #fee2e2;
                                color: #dc2626;
                                padding: 10px;
                                border-radius: 6px;
                                margin-top: 10px;
                                font-weight: 600;
                            `;
                            errorMsg.textContent = 'Error: Dream not found.';
                            entryElement.appendChild(errorMsg);
                            
                            setTimeout(() => {
                                errorMsg.remove();
                                cancelDelete(dreamId);
                            }, 3000);
                        }
                        return;
                    }
                    
                    // Try to delete directly from IndexedDB first
                    let deleteSuccess = false;
                    if (isIndexedDBAvailable()) {
                        deleteSuccess = await deleteDreamFromIndexedDB(dream.id);
                    }
                    
                    // If IndexedDB delete failed or unavailable, fall back to filtering
                    if (!deleteSuccess) {
                        const filteredDreams = dreams.filter(d => d.id !== dream.id);
                        await saveDreams(filteredDreams);
                    }
                    
                    // Reset to page 1 in case current page becomes empty
                    currentPage = 1;
                    await displayDreams();
                } catch (error) {
                    createInlineMessage('error', 'Error deleting dream: ' + error.message, {
                        container: document.querySelector('.main-content'),
                        position: 'top',
                        duration: 5000
                    });
                }
            });
        }

        // Cancel delete and revert to normal state (Updated for Event Delegation)
        function cancelDelete(dreamId) {
            // Clear the timeout
            if (deleteTimeouts[dreamId]) {
                clearTimeout(deleteTimeouts[dreamId]);
                delete deleteTimeouts[dreamId];
            }
            
            const entryElement = document.getElementById(`entry-${dreamId}`);
            if (entryElement) {
                const actionsElement = entryElement.querySelector('.entry-actions');
                
                // Remove pending delete styling
                entryElement.classList.remove('delete-pending');
                
                // Replace confirm button with original delete button
                const confirmBtn = actionsElement.querySelector(`button[data-dream-id="${dreamId}"][data-action="confirm-delete"]`);
                if (confirmBtn) {
                    confirmBtn.outerHTML = `<button data-action="delete-dream" data-dream-id="${dreamId}" class="btn btn-delete btn-small">Delete</button>`;
                }
            }
        }

        // IMPORT & EXPORT FUNCTIONALITY
        
        // Export dreams to text file (with optional encryption)
        async function exportEntries() {
            // Check if app is locked
            if (isAppLocked || (isPinSetup() && !isUnlocked)) {
                switchAppTab('lock');
                setTimeout(() => {
                    showLockScreenMessage('error', 'Please unlock your journal first to export your dreams.');
                }, 500);
                return;
            }
            
            const dreams = await loadDreams();
            
            if (dreams.length === 0) {
                createInlineMessage('error', 'No dreams to export yet. Add some dreams first!', {
                    container: document.querySelector('.main-content'),
                    position: 'top',
                    duration: 3000
                });
                return;
            }
            
            try {
                const exportText = dreams.map(dream => {
                    // Safety checks for dream properties
                    const safeTitle = dream && dream.title ? dream.title : 'Untitled Dream';
                    const safeTimestamp = dream && dream.timestamp ? dream.timestamp : new Date().toISOString();
                    const safeContent = dream && dream.content ? dream.content : 'No content';
                    const safeIsLucid = dream && dream.isLucid ? 'Lucid Dream âœ¨' : 'Regular Dream';
                    const safeEmotions = dream && dream.emotions ? dream.emotions : '';
                    const safeTags = Array.isArray(dream.tags) && dream.tags.length > 0 ? dream.tags.join(', ') : '';
                    const safeDreamSigns = Array.isArray(dream.dreamSigns) && dream.dreamSigns.length > 0 ? dream.dreamSigns.join(', ') : '';
                    
                    let exportEntry = `Title: ${safeTitle}\n` +
                           `Timestamp: ${safeTimestamp}\n` +
                           `Type: ${safeIsLucid}\n`;
                    
                    // Add emotions if they exist
                    if (safeEmotions) {
                        exportEntry += `Emotions: ${safeEmotions}\n`;
                    }
                    
                    // Add tags if they exist
                    if (safeTags) {
                        exportEntry += `Tags: ${safeTags}\n`;
                    }
                    
                    // Add dream signs if they exist
                    if (safeDreamSigns) {
                        exportEntry += `Dream Signs: ${safeDreamSigns}\n`;
                    }
                    
                    exportEntry += `Content: ${safeContent}\n` +
                                 `${'='.repeat(50)}\n`;
                    
                    return exportEntry;
                }).join('\n');
                
                if (!exportText || exportText.trim().length === 0) {
                    throw new Error('No valid dream data found to export');
                }
                
                // Check if encryption is enabled
                const encryptionEnabled = document.getElementById('encryptionEnabled').checked;
                let finalData = exportText;
                let fileName = `dream-journal-${new Date().toISOString().split('T')[0]}.txt`;
                let mimeType = 'text/plain';
                
                if (encryptionEnabled) {
                    // Show password dialog
                    const password = await showPasswordDialog({
                        type: 'export',
                        title: 'ðŸ” Set Export Password',
                        description: 'Choose a password to encrypt your dream export. This password is not stored - remember it for importing!',
                        requireConfirm: true,
                        primaryButtonText: 'Encrypt & Export'
                    });
                    
                    if (!password) {
                        // User cancelled
                        return;
                    }
                    
                    // Encrypt the data
                    const encryptedData = await encryptData(exportText, password);
                    finalData = encryptedData;
                    fileName = `dream-journal-${new Date().toISOString().split('T')[0]}.enc`;
                    mimeType = 'application/octet-stream';
                }
                
                // Create and download file
                const blob = new Blob([finalData], { type: mimeType });
                
                if (blob.size === 0) {
                    throw new Error('Export file is empty - no data to export');
                }
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.style.display = 'none';
                
                document.body.appendChild(a);
                
                // Mobile browsers need direct click without setTimeout
                try {
                    a.click();
                    
                    // Clean up after a longer delay to ensure download starts
                    setTimeout(() => {
                        if (document.body.contains(a)) {
                            document.body.removeChild(a);
                        }
                        URL.revokeObjectURL(url);
                    }, CONSTANTS.DOWNLOAD_CLEANUP_DELAY_MS); // longer delay instead of 100ms
                    
                } catch (clickError) {
                    console.error('Click error:', clickError);
                    // Clean up on error
                    if (document.body.contains(a)) {
                        document.body.removeChild(a);
                    }
                    URL.revokeObjectURL(url);
                    throw new Error('Failed to initiate download');
                }
                
                // Show success message
                const successMessage = encryptionEnabled ? 
                    'Encrypted dream export created successfully!' : 
                    'Dream export created successfully!';
                    
                createInlineMessage('success', successMessage, {
                    container: document.querySelector('.main-content'),
                    position: 'top',
                    duration: 3000
                });
                
            } catch (error) {
                console.error('Export error:', error);
                
                createInlineMessage('error', 'Error creating export: ' + error.message, {
                    container: document.querySelector('.main-content'),
                    position: 'top',
                    duration: 5000
                });
            }
        }

        // Update localStorage backup after successful IndexedDB operations
        async function updateLocalStorageBackup() {
            if (!isLocalStorageAvailable()) return;
            
            try {
                // Load current state from IndexedDB and sync to localStorage
                const dreams = await loadFromIndexedDB();
                if (dreams !== null) {
                    localStorage.setItem('dreamJournalEntries', JSON.stringify(dreams));
                }
            } catch (error) {
                // Ignore backup errors - IndexedDB is the primary storage
            }
        }

        // Validate dream data before saving
        function validateDreamData(dream) {
            if (!dream || typeof dream !== 'object') {
                console.error('Invalid dream data: not an object');
                return false;
            }
            
            if (!dream.id || typeof dream.id !== 'string') {
                console.error('Invalid dream data: missing or invalid id');
                return false;
            }
            
            if (!dream.content || typeof dream.content !== 'string' || dream.content.trim() === '') {
                console.error('Invalid dream data: missing or empty content');
                return false;
            }
            
            if (!dream.timestamp || typeof dream.timestamp !== 'string') {
                console.error('Invalid dream data: missing or invalid timestamp');
                return false;
            }
            
            // Validate timestamp is a valid date
            const date = new Date(dream.timestamp);
            if (isNaN(date.getTime())) {
                console.error('Invalid dream data: timestamp is not a valid date');
                return false;
            }
            
            if (!dream.title || typeof dream.title !== 'string') {
                console.error('Invalid dream data: missing or invalid title');
                return false;
            }
            
            if (typeof dream.isLucid !== 'boolean') {
                console.error('Invalid dream data: isLucid must be boolean');
                return false;
            }
            
            if (!dream.dateString || typeof dream.dateString !== 'string') {
                console.error('Invalid dream data: missing or invalid dateString');
                return false;
            }
            
            return true;
        }

        // Check if a dream is a duplicate based on title and content
        function isDreamDuplicate(existingDreams, newDream) {
            if (!Array.isArray(existingDreams) || !newDream || typeof newDream !== 'object') {
                return false;
            }
            
            return existingDreams.some(existing => 
                existing && 
                existing.title === newDream.title && 
                existing.content === newDream.content
            );
        }

        // Import dreams from text file (with optional decryption)
        async function importEntries(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                // Check if encryption is enabled
                const encryptionEnabled = document.getElementById('encryptionEnabled').checked;
                const isEncryptedFile = file.name.endsWith('.enc');
                
                // Read file as appropriate type
                const fileData = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    
                    if (encryptionEnabled || isEncryptedFile) {
                        reader.readAsArrayBuffer(file);
                    } else {
                        reader.readAsText(file);
                    }
                });
                
                let text = '';
                
                // Handle encrypted files
                if (encryptionEnabled || isEncryptedFile) {
                    if (typeof fileData === 'string') {
                        throw new Error('Selected file appears to be unencrypted. Uncheck encryption or select an encrypted (.enc) file.');
                    }
                    
                    // Show password dialog
                    const password = await showPasswordDialog({
                        type: 'import',
                        title: 'ðŸ”“ Enter Import Password',
                        description: 'Enter the password used to encrypt this dream export file.',
                        requireConfirm: false,
                        primaryButtonText: 'Decrypt & Import'
                    });
                    
                    if (!password) {
                        // User cancelled
                        event.target.value = ''; // Clear file input
                        return;
                    }
                    
                    try {
                        // Decrypt the data
                        text = await decryptData(new Uint8Array(fileData), password);
                    } catch (decryptError) {
                        throw new Error('Failed to decrypt file. Please check your password and try again.');
                    }
                } else {
                    // Handle unencrypted files
                    if (typeof fileData !== 'string') {
                        throw new Error('Selected file appears to be encrypted. Check encryption option or select a text (.txt) file.');
                    }
                    text = fileData;
                }
                
                // Process the decrypted/plain text
                const dreams = await loadDreams();
                
                // Simple parsing - this could be enhanced based on export format
                const entriesRaw = text.split('='.repeat(50));
                let importedCount = 0;
                let skippedCount = 0;
                
                entriesRaw.forEach((entry, index) => {
                    try {
                        const lines = entry.trim().split('\n').filter(line => line.trim()); // Remove empty lines
                        if (lines.length < 3) return; // Not enough data
                        
                        const title = lines[0].replace('Title: ', '').trim();
                        if (!title) return; // Skip entries without titles
                        
                        // Check if this is new format (timestamp) or old format (date string)
                        let timestamp = null;
                        let typeLineIndex = 2;
                        
                        if (lines[1] && lines[1].startsWith('Timestamp: ')) {
                            // New format - extract timestamp directly
                            timestamp = lines[1].replace('Timestamp: ', '').trim();
                            typeLineIndex = 2;
                        } else if (lines[1] && lines[1].startsWith('Date: ')) {
                            // Old format - try to parse the display date
                            const dateStr = lines[1].replace('Date: ', '').trim();
                            try {
                                const parsed = new Date(dateStr);
                                if (!isNaN(parsed.getTime())) {
                                    timestamp = parsed.toISOString();
                                }
                            } catch (e) {
                                // Continue with fallback
                            }
                            
                            // Check if there's also a timestamp line (mixed format)
                            if (lines[2] && lines[2].startsWith('Timestamp: ')) {
                                timestamp = lines[2].replace('Timestamp: ', '').trim();
                                typeLineIndex = 3;
                            }
                        }
                        
                        // Fallback to current time if no valid timestamp
                        if (!timestamp) {
                            timestamp = new Date().toISOString();
                        }
                        
                        // Validate timestamp
                        const testDate = new Date(timestamp);
                        if (isNaN(testDate.getTime())) {
                            timestamp = new Date().toISOString();
                        }
                        
                        // Check for lucid status, emotions, tags, and dream signs
                        let isLucid = false;
                        let emotions = '';
                        let tags = [];
                        let dreamSigns = [];
                        let contentStartIndex = typeLineIndex;
                        
                        // Look for Type line
                        if (lines[typeLineIndex] && lines[typeLineIndex].includes('Type:')) {
                            isLucid = lines[typeLineIndex].includes('Lucid Dream') || lines[typeLineIndex].includes('âœ¨');
                            contentStartIndex = typeLineIndex + 1;
                        }
                        
                        // Look for Emotions line
                        if (lines[contentStartIndex] && lines[contentStartIndex].startsWith('Emotions:')) {
                            emotions = lines[contentStartIndex].replace('Emotions:', '').trim();
                            contentStartIndex = contentStartIndex + 1;
                        }
                        
                        // Look for Tags line
                        if (lines[contentStartIndex] && lines[contentStartIndex].startsWith('Tags:')) {
                            const tagsText = lines[contentStartIndex].replace('Tags:', '').trim();
                            tags = parseTagsFromInput(tagsText);
                            contentStartIndex = contentStartIndex + 1;
                        }
                        
                        // Look for Dream Signs line
                        if (lines[contentStartIndex] && lines[contentStartIndex].startsWith('Dream Signs:')) {
                            const dreamSignsText = lines[contentStartIndex].replace('Dream Signs:', '').trim();
                            dreamSigns = parseTagsFromInput(dreamSignsText);
                            contentStartIndex = contentStartIndex + 1;
                        }
                        
                        const content = lines.slice(contentStartIndex)
                            .join('\n')
                            .replace(/^Content:\s*/, '') // Remove "Content:" prefix
                            .trim();
                        
                        if (!title || !content) return; // Skip entries without required data
                        
                        // Generate display date from timestamp
                        const timestampDate = new Date(timestamp);
                        const dateString = timestampDate.toLocaleDateString('en-AU', {
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        
                        const newDream = {
                            id: generateUniqueId(),
                            title: title,
                            content: content,
                            emotions: emotions, // Include emotions in imported dreams
                            tags: tags, // Include tags in imported dreams
                            dreamSigns: dreamSigns, // Include dream signs in imported dreams
                            isLucid: Boolean(isLucid),
                            timestamp: timestamp,
                            dateString: dateString
                        };
                        
                        // Validate the dream data before proceeding
                        if (validateDreamData(newDream)) {
                            // Check for duplicates before adding
                            if (isDreamDuplicate(dreams, newDream)) {
                                skippedCount++;
                            } else {
                                dreams.unshift(newDream);
                                importedCount++;
                            }
                        }
                    } catch (entryError) {
                        // Skip invalid entries silently
                    }
                });
                
                try {
                    await saveDreams(dreams);
                    await displayDreams();
                    
                    // Show success message with import stats
                    const container = document.querySelector('.main-content');
                    if (container) {
                        const msg = document.createElement('div');
                        msg.style.cssText = `
                            background: var(--notification-success-bg);
                            color: var(--success-color);
                            padding: 15px;
                            border-radius: var(--border-radius);
                            margin-bottom: 20px;
                            font-weight: var(--font-weight-semibold);
                            text-align: center;
                        `;
                        
                        let messageText = '';
                        const fileType = encryptionEnabled || isEncryptedFile ? 'encrypted' : 'standard';
                        
                        if (importedCount > 0 && skippedCount > 0) {
                            messageText = `${fileType === 'encrypted' ? 'Encrypted import' : 'Import'} complete! Added ${importedCount} new dreams, skipped ${skippedCount} duplicates.`;
                        } else if (importedCount > 0) {
                            messageText = `Successfully imported ${importedCount} dreams from ${fileType} file!`;
                        } else if (skippedCount > 0) {
                            messageText = `Import complete! All ${skippedCount} dreams were already in your journal.`;
                        } else {
                            messageText = 'No valid dreams found in the file.';
                            msg.style.background = '#fee2e2';
                            msg.style.color = '#dc2626';
                        }
                        
                        msg.textContent = messageText;
                        container.insertBefore(msg, container.firstChild);
                        
                        setTimeout(() => {
                            try {
                                if (msg && msg.parentNode) {
                                    msg.remove();
                                }
                            } catch (e) {
                                // Ignore cleanup errors
                            }
                        }, 5000);
                    }
                } catch (saveError) {
                    console.error('Error saving imported dreams:', saveError);
                    throw new Error('Failed to save imported dreams. Please try again.');
                }
                
            } catch (error) {
                console.error('Import error:', error);
                
                // Show error message
                const container = document.querySelector('.main-content');
                if (container) {
                    const msg = document.createElement('div');
                    msg.style.cssText = `
                        background: var(--notification-error-bg);
                        color: var(--error-color);
                        padding: 15px;
                        border-radius: var(--border-radius);
                        margin-bottom: 20px;
                        font-weight: var(--font-weight-semibold);
                        text-align: center;
                    `;
                    msg.textContent = 'Import failed: ' + error.message;
                    container.insertBefore(msg, container.firstChild);
                    
                    setTimeout(() => {
                        try {
                            if (msg && msg.parentNode) {
                                msg.remove();
                            }
                        } catch (e) {
                            // Ignore cleanup errors
                        }
                    }, 5000);
                }
            } finally {
                // Clear the file input
                event.target.value = '';
            }
        }

        // Export dreams formatted for AI analysis
        async function exportForAIAnalysis() {
            // Check if app is locked
            if (isAppLocked || (isPinSetup() && !isUnlocked)) {
                switchAppTab('lock');
                setTimeout(() => {
                    showLockScreenMessage('error', 'Please unlock your journal first to export for analysis.');
                }, 500);
                return;
            }
            
            const searchBox = document.getElementById('searchBox');
            const filterSelect = document.getElementById('filterSelect');
            const sortSelect = document.getElementById('sortSelect');
            
            const searchTerm = (searchBox ? searchBox.value : '').toLowerCase();
            const filterType = filterSelect ? filterSelect.value : 'all';
            const sortType = sortSelect ? sortSelect.value : 'newest';
            const allDreams = await loadDreams();
            
            // Apply same filtering as display
            let dreams = allDreams.filter(dream => {
                if (!dream || typeof dream !== 'object') return false;
                
                const title = dream.title || '';
                const content = dream.content || '';
                const emotions = dream.emotions || '';
                const tags = Array.isArray(dream.tags) ? dream.tags.join(' ') : '';
                const dreamSigns = Array.isArray(dream.dreamSigns) ? dream.dreamSigns.join(' ') : '';
                
                const matchesSearch = !searchTerm || 
                    title.toLowerCase().includes(searchTerm) ||
                    content.toLowerCase().includes(searchTerm) ||
                    emotions.toLowerCase().includes(searchTerm) ||
                    tags.toLowerCase().includes(searchTerm) ||
                    dreamSigns.toLowerCase().includes(searchTerm);
                
                const matchesFilter = filterType === 'all' || 
                    (filterType === 'lucid' && Boolean(dream.isLucid)) ||
                    (filterType === 'non-lucid' && !Boolean(dream.isLucid));
                
                return matchesSearch && matchesFilter;
            });
            
            // Apply same sorting as display for consistency
            dreams.sort((a, b) => {
                switch (sortType) {
                    case 'oldest':
                        return new Date(a.timestamp) - new Date(b.timestamp);
                    
                    case 'lucid-first':
                        if (a.isLucid && !b.isLucid) return -1;
                        if (!a.isLucid && b.isLucid) return 1;
                        return new Date(b.timestamp) - new Date(a.timestamp);
                    
                    case 'longest':
                        return b.content.length - a.content.length;
                    
                    case 'newest':
                    default:
                        return new Date(b.timestamp) - new Date(a.timestamp);
                }
            });
            
            if (dreams.length === 0) {
                const filterText = filterType === 'all' ? '' : 
                    filterType === 'lucid' ? ' lucid' : ' non-lucid';
                
                const noResultsMessage = `No${filterText} dreams to export for analysis${searchTerm ? ' matching your search' : ''}. ${filterType === 'lucid' ? 'Try recording some lucid dreams first!' : 'Record some dreams first!'}`;
                
                createInlineMessage('error', noResultsMessage, {
                    container: document.querySelector('.main-content'),
                    position: 'top',
                    duration: 5000
                });
                return;
            }
            
            try {
                // Performance optimization: Limit analysis to most recent dreams based on size
                const maxDreams = dreams.length > CONSTANTS.AI_ANALYSIS_THRESHOLD ? CONSTANTS.AI_ANALYSIS_RECENT_LIMIT : CONSTANTS.AI_ANALYSIS_TOTAL_LIMIT;
                const recentDreams = dreams.slice(0, maxDreams);
                
                // Format dreams for AI analysis
                const dreamTexts = recentDreams.map(dream => {
                    const lucidStatus = dream.isLucid ? '[LUCID DREAM]' : '[REGULAR DREAM]';
                    const date = new Date(dream.timestamp).toLocaleDateString();
                    const emotions = dream.emotions ? ` [EMOTIONS: ${dream.emotions}]` : '';
                    const tags = Array.isArray(dream.tags) && dream.tags.length > 0 ? ` [TAGS: ${dream.tags.join(', ')}]` : '';
                    const dreamSigns = Array.isArray(dream.dreamSigns) && dream.dreamSigns.length > 0 ? ` [DREAM SIGNS: ${dream.dreamSigns.join(', ')}]` : '';
                    return `${lucidStatus}${emotions}${tags}${dreamSigns} ${date} - ${dream.title}: ${dream.content}`;
                }).join('\n\n');
                
                const totalDreams = dreams.length;
                const lucidCount = dreams.filter(d => d.isLucid).length;
                const lucidPercentage = totalDreams > 0 ? ((lucidCount / totalDreams) * 100).toFixed(1) : 0;
                
                // Create the full AI analysis prompt
                const aiAnalysisPrompt = `Analyze these dream journal entries for patterns, themes, and insights. The user has ${totalDreams} total dreams with ${lucidCount} lucid dreams (${lucidPercentage}% lucid rate). Each entry includes emotions, general tags/themes, and dream signs (specific lucidity triggers) when available.

${dreamTexts}

Please provide a comprehensive analysis including:

1. **Dream Patterns & Themes**: What recurring elements, settings, characters, or situations appear across dreams? How do the user's tags reveal their most common dream themes?

2. **Dream Signs Analysis**: What specific dream signs appear most frequently? Which dream signs correlate with lucid dreams vs regular dreams? What are the user's strongest personal lucidity triggers?

3. **Emotional Patterns**: What emotional themes emerge across dreams? How do emotions correlate with dream content, lucidity, or timing? Are there emotional triggers or patterns?

4. **Tag-Based Insights**: What do the user's tags reveal about their dream world? Are there tag patterns that correlate with lucidity, emotions, or specific time periods?

5. **Lucid Dream Analysis**: What triggers or signs indicate increased lucidity? How do tagged elements, emotions, and dream signs work together to create lucid experiences?

6. **Symbolic Interpretation**: What symbols or metaphors appear frequently and what might they represent? How do emotions and tags connect to symbolic content?

7. **Practical Recommendations**: Specific techniques to improve dream recall, increase lucidity recognition, or work with recurring themes. How can the user leverage their personal dream signs for better lucidity?

8. **Sleep & Dream Quality**: Any observations about dream complexity, vividness, timing patterns, and emotional intensity based on the available data?

Make the analysis personal, insightful, and actionable. Focus on helping the user understand their unique dream patterns, recurring dream signs, emotional landscapes, and how to enhance their lucid dreaming practice using their personal data.

${recentDreams.length < totalDreams ? `\n(Note: Analysis based on ${recentDreams.length} most recent dreams of ${totalDreams} total)` : ''}`;
                
                // Create and download the analysis prompt file
                const blob = new Blob([aiAnalysisPrompt], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dream-analysis-prompt-${new Date().toISOString().split('T')[0]}.txt`;
                a.style.display = 'none';
                
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                setTimeout(() => {
                    if (document.body.contains(a)) {
                        document.body.removeChild(a);
                    }
                    URL.revokeObjectURL(url);
                }, 3000);
                
                // Show success message
                createInlineMessage('success', 'AI analysis prompt exported! Copy the text and paste it into your preferred AI for dream analysis.', {
                    container: document.querySelector('.main-content'),
                    position: 'top',
                    duration: 5000
                });
                
            } catch (error) {
                console.error('Export for AI analysis error:', error);
                
                createInlineMessage('error', 'Error creating AI analysis export: ' + error.message, {
                    container: document.querySelector('.main-content'),
                    position: 'top',
                    duration: 5000
                });
            }
        }

        // APPLICATION INITIALIZATION & EVENT SETUP
        
        // Check browser compatibility for HSL custom properties
        function checkBrowserCompatibility() {
            if (!CSS.supports('color', 'hsl(var(--test))')) {
                // Show upgrade notice for very old browsers
                const body = document.body;
                const notice = document.createElement('div');
                notice.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    background: #dc2626;
                    color: white;
                    padding: 15px;
                    text-align: center;
                    font-weight: 600;
                    z-index: 9999;
                `;
                notice.innerHTML = 'âš ï¸ Your browser is outdated and may not display themes correctly. Please update to a modern browser.';
                body.insertBefore(notice, body.firstChild);
            }
        }
        
        // Initialize app
        document.addEventListener('DOMContentLoaded', async function() {
            // Check browser compatibility first
            checkBrowserCompatibility();
            
            // Setup event delegation system
            setupEventDelegation();
            
            // Initialize IndexedDB
            await initDB();
            
            // Initialize theme system early
            initializeTheme();
            
            // CRITICAL FIX: Ensure tab container exists before any tab switching
            let tabContainer = document.querySelector('.tab-content-container');
            if (!tabContainer) {
                console.log('Creating tab container on initialization');
                
                // Find the container element where tabs should go
                const containerDiv = document.querySelector('.container');
                const appTabs = document.querySelector('.app-tabs');
                
                if (containerDiv && appTabs) {
                    // Create the tab container
                    tabContainer = document.createElement('div');
                    tabContainer.className = 'tab-content-container';
                    tabContainer.style.cssText = `
                        background: var(--bg-primary);
                        min-height: 400px;
                        overflow-x: hidden;
                    `;
                    
                    // Insert it after the app-tabs element
                    appTabs.parentNode.insertBefore(tabContainer, appTabs.nextSibling);
                    console.log('Tab container created successfully');
                } else {
                    console.error('Could not find container or app-tabs elements');
                }
            }
            
            // Perform migration if needed
            if (isIndexedDBAvailable() && isLocalStorageAvailable()) {
                await migrateFromLocalStorage();
            }
            
            // Set current date/time as default for new dreams
            const dreamDateInput = document.getElementById('dreamDate');
            if (dreamDateInput) {
                const now = new Date();
                const datetimeLocalValue = now.toISOString().slice(0, CONSTANTS.DATETIME_LOCAL_SLICE_LENGTH);
                dreamDateInput.value = datetimeLocalValue;
            }
            
            // Check for expired recovery timer FIRST (before determining lock state)
            const resetTime = getResetTime();
            let timerExpiredAndRemovedPin = false;
            
            if (resetTime) {
                const remainingTime = resetTime - Date.now();
                if (remainingTime <= 0) {
                    // Timer expired, remove PIN
                    removeResetTime();
                    removePinHash();
                    isUnlocked = true;
                    isAppLocked = false;
                    failedPinAttempts = 0; // Reset attempts since timer recovery was successful
                    timerExpiredAndRemovedPin = true;
                    
                    // Update security controls immediately after unlocking
                    updateSecurityControls();
                    
                    // Show message in main content instead of alert
                    setTimeout(() => {
                        const container = document.querySelector('.main-content');
                        if (container) {
                            const msg = document.createElement('div');
                            msg.style.cssText = `
                                background: #e0f2fe;
                                color: #0284c7;
                                padding: 15px;
                                border-radius: 8px;
                                margin-bottom: 20px;
                                font-weight: 600;
                                text-align: center;
                            `;
                            msg.textContent = 'Your PIN reset timer has expired. The PIN has been removed. You can set a new one if desired.';
                            container.insertBefore(msg, container.firstChild);
                            
                            setTimeout(() => {
                                msg.remove();
                            }, 8000);
                        }
                    }, 500);
                }
            }
            
            // Update timer warning if active
            updateTimerWarning();
            // Update warning every minute
            const timerWarningInterval = setInterval(updateTimerWarning, 60000);
            
            // Determine starting tab based on PIN status (AFTER checking timer expiry)
            if (isPinSetup() && !timerExpiredAndRemovedPin) {
                // App should start locked if PIN is set and timer didn't just expire
                isUnlocked = false;
                isAppLocked = true;
                preLockActiveTab = 'journal'; // Default to journal when unlocked
                
                console.log('Starting app in locked state - PIN is set');
                
                // CRITICAL FIX: Add delay and error handling for lock screen initialization
                setTimeout(() => {
                    try {
                        // Double-check tab container exists
                        const tabContainer = document.querySelector('.tab-content-container');
                        if (!tabContainer) {
                            console.error('Tab container still missing during lock initialization!');
                            
                            // Force creation one more time
                            const containerDiv = document.querySelector('.container');
                            const appTabs = document.querySelector('.app-tabs');
                            
                            if (containerDiv && appTabs) {
                                const newTabContainer = document.createElement('div');
                                newTabContainer.className = 'tab-content-container';
                                newTabContainer.style.cssText = `
                                    background: var(--bg-primary);
                                    min-height: 400px;
                                    overflow-x: hidden;
                                `;
                                appTabs.parentNode.insertBefore(newTabContainer, appTabs.nextSibling);
                                console.log('Emergency tab container created');
                            }
                        }
                        
                        // Ensure lock tab is created and switch to it
                        switchAppTab('lock');
                        
                        // Hide all other tabs except lock until unlocked
                        hideAllTabButtons();
                        
                        console.log('Lock screen initialization completed successfully');
                        
                    } catch (error) {
                        console.error('Error during lock screen initialization:', error);
                        // Fallback: show PIN overlay instead of lock tab
                        showPinOverlay();
                    }
                }, 50); // Small delay to ensure DOM is fully ready
                
            } else {
                // No PIN set OR timer just expired - app starts unlocked
                isUnlocked = true;
                isAppLocked = false;
                
                console.log('Starting app in unlocked state - no PIN or timer expired');
                
                // Start on journal tab
                switchAppTab('journal');
                
                // Ensure all tabs are visible
                showAllTabButtons();
            }
            
            // Setup security controls - simpler now that lock button is always visible
            updateSecurityControls();
            
            // Cleanup timers on page unload to prevent memory leaks
            window.addEventListener('beforeunload', function() {
                try {
                    // Clear all delete timeouts
                    Object.keys(deleteTimeouts).forEach(dreamId => {
                        if (deleteTimeouts[dreamId]) {
                            clearTimeout(deleteTimeouts[dreamId]);
                            delete deleteTimeouts[dreamId];
                        }
                    });
                    
                    // Clear all voice note delete timeouts
                    Object.keys(voiceDeleteTimeouts).forEach(voiceNoteId => {
                        if (voiceDeleteTimeouts[voiceNoteId]) {
                            clearTimeout(voiceDeleteTimeouts[voiceNoteId]);
                            delete voiceDeleteTimeouts[voiceNoteId];
                        }
                    });
                    
                    // Clear timer warning interval
                    if (timerWarningInterval) {
                        clearInterval(timerWarningInterval);
                    }
                    
                    // Clear performance optimization timers
                    if (searchDebounceTimer) {
                        clearTimeout(searchDebounceTimer);
                    }
                    if (filterDebounceTimer) {
                        clearTimeout(filterDebounceTimer);
                    }
                    if (scrollDebounceTimer) {
                        clearTimeout(scrollDebounceTimer);
                    }
                    
                    // Clear recording timer if active
                    if (recordingTimer) {
                        clearInterval(recordingTimer);
                    }
                    
                    // Stop any playing audio
                    if (currentPlayingAudio) {
                        currentPlayingAudio.pause();
                        currentPlayingAudio = null;
                    }
                    
                    // Stop media recorder if active
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                    
                    // Clean up endless scroll
                    removeEndlessScroll();
                } catch (error) {
                    // Ignore cleanup errors during page unload
                    console.log('Cleanup error during page unload:', error);
                }
            });
            
            // Setup event listeners for non-click interactions (input, change, keydown)
            const searchBox = document.getElementById('searchBox');
            const filterSelect = document.getElementById('filterSelect');
            const sortSelect = document.getElementById('sortSelect');
            const limitSelect = document.getElementById('limitSelect');
            const dreamContent = document.getElementById('dreamContent');
            const pinInput = document.getElementById('pinInput');
            const themeSelect = document.getElementById('themeSelect');
            
            // Use debounced search for better performance
            if (searchBox) searchBox.addEventListener('input', () => debouncedSearch(CONSTANTS.DEBOUNCE_SEARCH_MS));
            
            // Use debounced filter for dropdowns (shorter delay since less frequent)
            if (filterSelect) filterSelect.addEventListener('change', () => debouncedFilter(CONSTANTS.DEBOUNCE_FILTER_MS));
            if (sortSelect) sortSelect.addEventListener('change', () => debouncedFilter(CONSTANTS.DEBOUNCE_FILTER_MS));
            if (limitSelect) limitSelect.addEventListener('change', () => debouncedFilter(CONSTANTS.DEBOUNCE_FILTER_MS));
            
            // Theme switching is now handled by the action system
            
            // Setup tag autocomplete for form inputs
            setupTagAutocomplete('dreamTags', commonTags);
            setupTagAutocomplete('dreamSigns', commonDreamSigns);
            
            // Enter key to save dream
            if (dreamContent) {
                dreamContent.addEventListener('keydown', function(e) {
                    if (e.ctrlKey && e.key === 'Enter') {
                        saveDream();
                    }
                });
            }
            
            // PIN input keyboard listeners
            if (pinInput) {
                pinInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        const unlockBtn = document.getElementById('pinMainBtn');
                        if (unlockBtn) {
                            unlockBtn.click();
                        }
                    }
                });
            }
            
            // Lock screen PIN input keyboard listener  
            document.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    const lockScreenPinInput = document.getElementById('lockScreenPinInput');
                    const recovery1 = document.getElementById('recovery1');
                    const recovery2 = document.getElementById('recovery2');
                    const recovery3 = document.getElementById('recovery3');
                    
                    if (lockScreenPinInput && document.activeElement === lockScreenPinInput) {
                        verifyLockScreenPin();
                    } else if (recovery1 && (document.activeElement === recovery1 || document.activeElement === recovery2 || document.activeElement === recovery3)) {
                        // Handle Enter key in recovery inputs - verify if all are filled
                        const title1 = recovery1.value.trim();
                        const title2 = recovery2.value.trim();
                        const title3 = recovery3.value.trim();
                        
                        if (title1 && title2 && title3) {
                            verifyLockScreenDreamTitles();
                        } else {
                            // Move to next empty field
                            if (!title1) recovery1.focus();
                            else if (!title2) recovery2.focus();
                            else if (!title3) recovery3.focus();
                        }
                    }
                }
            });
            
            // Display dreams on load
            try {
                await displayDreams();
                await updateRecordButtonState();
                await displayVoiceNotes();
                
                // Initialize tab system
                switchAppTab('journal'); // This will create missing tabs if needed
                
                // Update security controls after everything is loaded
                updateSecurityControls();
                
                // Update voice status with proper capability detection
                setTimeout(() => {
                    updateRecordButtonState();
                }, 100);
            } catch (error) {
                console.error('Error displaying dreams on page load:', error);
                // Show a fallback message if initial display fails
                const container = document.getElementById('entriesContainer');
                if (container) {
                    container.innerHTML = `
                        <div class="no-entries">
                            <h3>âš ï¸ Error Loading Dreams</h3>
                            <p>There was a problem loading your dreams. Please refresh the page and try again.</p>
                            <button onclick="location.reload()" class="btn btn-primary" style="margin-top: 15px;">ðŸ”„ Refresh Page</button>
                        </div>
                    `;
                }
            }
            
            // Check voice recording support and update UI with enhanced detection
            const voiceCapabilities = getVoiceCapabilities();
            if (!voiceCapabilities.canRecord) {
                const recordBtn = document.getElementById('recordBtn');
                const voiceStatus = document.getElementById('voiceStatus');
                
                if (recordBtn) {
                    recordBtn.className = 'record-btn disabled';
                    recordBtn.disabled = true;
                    recordBtn.innerHTML = '<span>ðŸš«</span><span>Not Supported</span>';
                }
                
                if (voiceStatus) {
                    const statusInfo = voiceCapabilities.getStatusMessage();
                    voiceStatus.textContent = statusInfo.message;
                    voiceStatus.className = `voice-status ${statusInfo.type}`;
                }
                
                // Add browser-specific help message for truly unsupported browsers
                const voiceSection = document.querySelector('.voice-recording-section');
                if (voiceSection && voiceCapabilities.browser.isSafariMobile) {
                    const helpMsg = document.createElement('div');
                    helpMsg.style.cssText = `
                        background: var(--notification-error-bg);
                        color: var(--error-color);
                        padding: 15px;
                        border-radius: var(--border-radius);
                        margin-top: 15px;
                        font-weight: var(--font-weight-semibold);
                        text-align: center;
                    `;
                    helpMsg.innerHTML = `
                        <strong>ðŸŽ Safari iOS Limitation</strong><br>
                        Safari iOS has limited voice recording support. For voice features, try:<br>
                        â€¢ <strong>Chrome Mobile</strong> (recommended)<br>
                        â€¢ <strong>Microsoft Edge Mobile</strong><br>
                        â€¢ <strong>Firefox Mobile</strong>
                    `;
                    voiceSection.appendChild(helpMsg);
                }
            } else if (!voiceCapabilities.canTranscribe) {
                // Voice recording works but transcription doesn't
                const voiceStatus = document.getElementById('voiceStatus');
                if (voiceStatus) {
                    if (voiceCapabilities.browser.isFirefox) {
                        voiceStatus.textContent = 'Voice recording supported (Firefox does not support transcription)';
                    } else if (voiceCapabilities.browser.isSafari) {
                        voiceStatus.textContent = 'Voice recording supported (Safari does not support transcription)';
                    } else {
                        voiceStatus.textContent = 'Voice recording supported (transcription not available in this browser)';
                    }
                    voiceStatus.className = 'voice-status warning';
                }
                
                // Add helpful message for partial support
                const voiceSection = document.querySelector('.voice-recording-section');
                if (voiceSection && voiceCapabilities.browser.isFirefox) {
                    const helpMsg = document.createElement('div');
                    helpMsg.style.cssText = `
                        background: var(--notification-warning-bg);
                        color: var(--warning-color);
                        padding: 15px;
                        border-radius: var(--border-radius);
                        margin-top: 15px;
                        font-weight: var(--font-weight-semibold);
                        text-align: center;
                    `;
                    helpMsg.innerHTML = `
                        <strong>ðŸ¦Š Firefox Note</strong><br>
                        Voice recording works great! Transcription isn't supported in Firefox yet.<br>
                        You can still record voice notes and play them back to type your dreams manually.
                    `;
                    voiceSection.appendChild(helpMsg);
                }
            }
        });
    </script>
</body>
</html>
