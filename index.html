<!-- 
Dream Journal v1.43.10 - A privacy-focused dream tracking application
Copyright (C) 2025 Dream Journal Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Affero General Public License for more details.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dream Journal</title>
    <style>
        /* === DREAM JOURNAL OPTIMIZED CSS === */
        /* HSL Theme System + Utility Classes - 90% reduction in theme CSS + Phase 2C voice optimization */
        /* === OPTIMIZED HSL THEME SYSTEM === */
        
        :root {
            /* Static values that don't change between themes */
            --border-radius: 8px;
            --border-radius-lg: 12px;
            --border-radius-xl: 15px;
            --font-weight-medium: 500;
            --font-weight-semibold: 600;
            --transition: all 0.3s ease;
            
            /* === COLOR BASE SYSTEM (HSL) === */
            /* Core color families - hue & saturation never change */
            --primary-h: 238;    --primary-s: 84%;
            --success-h: 158;    --success-s: 64%;
            --error-h: 0;        --error-s: 84%;
            --warning-h: 32;     --warning-s: 95%;
            --info-h: 199;       --info-s: 89%;
            
            /* Neutral grays */
            --neutral-h: 222;    --neutral-s: 47%;
            --slate-h: 215;      --slate-s: 20%;
            --gray-h: 220;       --gray-s: 13%;
            
            /* === LIGHT THEME LIGHTNESS VALUES === */
            /* Backgrounds */
            --bg-primary-l: 100%;      --bg-secondary-l: 100%;
            --bg-elevated-l: 100%;     --bg-input-l: 100%;
            --bg-hover-l: 98%;         --bg-subtle-l: 95%;
            --bg-light-l: 98%;         --bg-disabled-l: 99%;
            --bg-selected-l: 97%;
            
            /* Text */
            --text-primary-l: 11%;     --text-secondary-l: 38%;
            --text-tertiary-l: 42%;    --text-muted-l: 64%;
            --text-inverse-l: 100%;    --text-disabled-l: 42%;
            
            /* Borders */
            --border-light-l: 95%;     --border-color-l: 88%;
            --border-dark-l: 82%;      --border-hover-l: 82%;
            
            /* Semantic colors - consistent lightness */
            --primary-l: 59%;          --primary-hover-l: 52%;
            --success-l: 30%;          --success-hover-l: 26%;
            --error-l: 51%;            --error-hover-l: 44%;
            --warning-l: 44%;          --info-l: 39%;
            --secondary-l: 46%;        --secondary-hover-l: 35%;
            
            /* Component specific */
            --shadow-opacity: 0.1;     --modal-backdrop-opacity: 0.9;
            --voice-bg-l: 97%;         --voice-border-l: 86%;       --voice-text-l: 39%;
            --tag-bg-l: 97%;           --tag-text-l: 39%;           --tag-border-l: 86%;
            --dream-sign-bg-l: 95%;    --dream-sign-text-l: 44%;    --dream-sign-border-l: 88%;
            --notification-error-l: 93%;   --notification-success-l: 89%;
            --notification-warning-l: 95%; --notification-info-l: 97%;
        }
        
        /* === UTILITY CLASS SYSTEM === */
        /* Layout & Structure */
        .card { background: var(--bg-secondary); border: 2px solid var(--border-color); }
        .card-elevated { background: var(--bg-elevated); border: 2px solid var(--border-color); }
        .card-lg { border-radius: var(--border-radius-xl); padding: 40px; }
        .card-md { border-radius: var(--border-radius-lg); padding: 20px; }
        .card-sm { border-radius: var(--border-radius); padding: 15px; }
        
        /* Flexbox utilities */
        .flex-center { display: flex; align-items: center; justify-content: center; }
        .flex-between { display: flex; align-items: center; justify-content: space-between; }
        .flex-col { display: flex; flex-direction: column; }
        .flex-wrap { flex-wrap: wrap; }
        
        /* Spacing system */
        .gap-xs { gap: 5px; } .gap-sm { gap: 8px; } .gap-md { gap: 15px; } .gap-lg { gap: 20px; }
        .p-sm { padding: 8px; } .p-md { padding: 15px; } .p-lg { padding: 20px; } .p-xl { padding: 40px; }
        .mb-sm { margin-bottom: 10px; } .mb-md { margin-bottom: 15px; } .mb-lg { margin-bottom: 20px; }
        .mt-sm { margin-top: 10px; } .mt-md { margin-top: 15px; } .mt-lg { margin-top: 20px; }
        .mx-lg { margin-left: 20px; margin-right: 20px; }
        
        /* Typography utilities */
        .text-center { text-align: center; } .text-left { text-align: left; }
        .text-sm { font-size: 0.9em; } .text-base { font-size: 1em; } .text-lg { font-size: 1.2em; } 
        .text-xl { font-size: 1.6em; } .text-2xl { font-size: 1.8em; } .text-4xl { font-size: 4em; }
        .font-normal { font-weight: normal; } .font-semibold { font-weight: var(--font-weight-semibold); }
        .text-primary { color: var(--text-primary); } .text-secondary { color: var(--text-secondary); }
        .text-warning { color: var(--warning-color); }
        .line-height-relaxed { line-height: 1.5; } .line-height-loose { line-height: 1.6; }
        
        /* Width utilities */
        .w-full { width: 100%; } .max-w-sm { max-width: 400px; }
        
        /* Message utilities */
        .message-base { padding: 15px; border-radius: var(--border-radius); margin-bottom: 20px; 
                        font-weight: var(--font-weight-semibold); text-align: center; }
        .message-success { background: var(--notification-success-bg); color: var(--success-color); }
        .message-error { background: var(--notification-error-bg); color: var(--error-color); }
        .message-warning { background: var(--notification-warning-bg); color: var(--warning-color); }
        .message-info { background: var(--notification-info-bg); color: var(--info-color); }
        
        /* Input utilities */
        .input-pin { padding: 15px; border: 2px solid var(--border-color); border-radius: var(--border-radius); 
                     font-size: 18px; text-align: center; letter-spacing: 3px; font-family: monospace; 
                     background: var(--bg-input); }
        
        /* Box shadow utilities */
        .shadow-lg { box-shadow: var(--shadow-lg); }
        
        /* === PHASE 2C: VOICE NOTES UTILITIES === */
        /* Voice controls layout */
        .voice-note-container { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; 
                                background: var(--bg-secondary); border: 2px solid var(--border-color); 
                                border-radius: var(--border-radius); padding: 15px; margin-bottom: 15px; 
                                transition: var(--transition); }
        .voice-note-container:hover { border-color: var(--border-hover); box-shadow: var(--shadow-md); }
        .voice-note-container.delete-pending { background: var(--notification-warning-bg); 
                                               border-color: var(--warning-color); }
        
        /* Voice note content layout */
        .voice-note-info { flex: 1; min-width: 200px; }
        .voice-note-title { font-weight: var(--font-weight-semibold); color: var(--text-primary); 
                            margin-bottom: 4px; }
        .voice-note-meta { color: var(--text-secondary); font-size: 14px; }
        .voice-note-controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; 
                               min-width: 300px; }
        
        /* Voice button base styling */
        .voice-btn-base { padding: 6px 12px; border: none; border-radius: 6px; font-size: 12px; 
                          font-weight: var(--font-weight-semibold); cursor: pointer; transition: var(--transition); 
                          display: flex; align-items: center; gap: 4px; }
        
        /* === STATS TAB SYSTEM === */
        .stats-tabs {
            display: flex;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg) var(--border-radius-lg) 0 0;
            margin: 0;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .stats-tab {
            background: transparent;
            border: none;
            padding: 15px 20px;
            font-weight: var(--font-weight-semibold);
            color: var(--text-secondary);
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
            flex-shrink: 0;
            font-size: 14px;
        }
        
        .stats-tab:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .stats-tab.active {
            background: var(--primary-color);
            color: var(--text-inverse);
        }
        
        .stats-tab-content {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 var(--border-radius-lg) var(--border-radius-lg);
            padding: 20px;
        }
        
        .stats-tab-panel {
            width: 100%;
        }

        .word-cloud {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding: 20px;
        }
        .word-cloud-item {
            display: inline-block;
            font-weight: 600;
            transition: transform 0.2s ease;
            cursor: default;
        }
        .word-cloud-item:hover {
            transform: scale(1.1);
        }
        
        /* Voice button variants */
        .voice-btn-play { background: var(--info-color); color: var(--text-inverse); }
        .voice-btn-play:hover { background: #0284c7; }
        .voice-btn-pause { background: var(--warning-color); color: var(--text-inverse); }
        .voice-btn-pause:hover { background: #d97706; }
        .voice-btn-transcribe { background: #7c3aed; color: var(--text-inverse); }
        .voice-btn-transcribe:hover { background: #6d28d9; }
        .voice-btn-transcribe:disabled { background: var(--text-muted); cursor: not-allowed; }
        .voice-btn-download { background: var(--success-color); color: var(--text-inverse); }
        .voice-btn-download:hover { background: var(--success-hover); }
        .voice-btn-delete { background: var(--error-color); color: var(--text-inverse); }
        .voice-btn-delete:hover { background: var(--error-hover); }
        
        /* Voice progress container */
        .voice-progress-container { flex: 1; min-width: 200px; display: flex; align-items: center; 
                                    gap: 8px; margin: 0 15px; }
        .voice-time-display { font-family: monospace; font-size: 12px; color: var(--text-secondary); 
                              min-width: 80px; text-align: center; }
        
        /* Voice warning messages */
        .voice-full-warning { background: var(--notification-error-bg); color: var(--error-color); 
                              padding: 12px; border-radius: var(--border-radius); 
                              border: 2px solid var(--error-color); margin-bottom: 15px; 
                              font-weight: var(--font-weight-semibold); text-align: center; }
        .no-voice-notes { text-align: center; color: var(--text-secondary); font-style: italic; 
                          padding: 30px; background: var(--bg-light); border: var(--border-dashed); 
                          border-radius: var(--border-radius); }
        
        /* === PHASE 3A: DREAM ENTRY UTILITIES === */
        /* Dream entry emotion display */
        .entry-emotions { margin-top: 8px; color: var(--text-secondary); font-size: 0.9em; }
        .entry-emotions span { font-weight: var(--font-weight-semibold); }
        
        /* === PHASE 3B: FINAL OPTIMIZATION UTILITIES === */
        /* Pagination and info display */
        .pagination-info { text-align: center; padding: 20px; color: var(--text-secondary); }
        
        /* Small text utilities */
        .text-xs { font-size: 0.6em; } .text-xxs { font-size: 12px; }
        .small-helper { color: var(--text-secondary); font-size: 0.9em; margin-top: 5px; display: block; }
        .small-helper-warning { color: var(--warning-color); font-size: 0.9em; margin-top: 5px; display: block; }
        
        /* Form utilities */
        .form-checkbox { width: 16px; height: 16px; accent-color: var(--primary-color); }
        .form-label-inline { font-size: 14px; font-weight: var(--font-weight-semibold); cursor: pointer; }
        
        /* Footer and structural elements */
        .app-footer { background: var(--bg-light); border-top: 1px solid var(--border-color); 
                      padding: 20px; margin-top: 40px; text-align: center; 
                      color: var(--text-secondary); font-size: 14px; }
        .app-footer p { margin: 0; font-size: 12px; opacity: 0.8; }
        
        /* Feedback and autocomplete */
        .feedback-container { border-radius: var(--border-radius); display: none; }
        .autocomplete-item { padding: 8px 12px; cursor: pointer; border-bottom: 1px solid var(--border-light); font-size: 14px; }
        
        /* === PHASE 2A: TAB CONTENT UTILITIES === */
        /* Progress bars */
        .progress-bar { background: var(--border-color); height: 8px; border-radius: 4px; overflow: hidden; }
        .progress-fill { background: var(--success-color); height: 100%; transition: width 0.3s; }
        .progress-success { background: var(--success-color); }
        .progress-primary { background: var(--primary-color); }
        
        /* Status indicators */
        .status-success { color: var(--success-color); font-weight: var(--font-weight-semibold); }
        .status-warning { color: var(--warning-color); font-weight: var(--font-weight-semibold); }
        .status-primary { color: var(--primary-color); font-weight: var(--font-weight-semibold); }
        .status-info { color: var(--info-color); font-weight: var(--font-weight-semibold); }
        
        /* Icon containers */
        .icon-lg { font-size: 2em; margin-bottom: 10px; }
        .icon-xl { font-size: 2.5em; margin-bottom: 10px; }
        
        /* Feature sections */
        .feature-item { background: var(--bg-light); padding: 15px; border-radius: var(--border-radius); 
                        display: flex; align-items: center; gap: 15px; }
        .feature-list { display: grid; gap: 15px; }
        
        /* Border accents */
        .border-l-primary { border-left: 4px solid var(--primary-color); }
        .border-l-success { border-left: 4px solid var(--success-color); }
        .border-l-warning { border-left: 4px solid var(--warning-color); }
        .border-l-info { border-left: 4px solid var(--info-color); }
        
        /* Layout grids */
        .grid-auto { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
        .grid-1 { display: grid; grid-template-columns: 1fr; gap: 15px; }
        
        /* Progress display */
        .progress-display { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        
        /* Content sections */
        .content-highlight { background: linear-gradient(135deg, var(--bg-elevated), var(--bg-secondary)); }
        
        /* Day counters */
        .day-counter { color: var(--primary-color); font-weight: var(--font-weight-semibold); }
        
        /* === DARK THEME - ONLY LIGHTNESS OVERRIDES === */
        [data-theme='dark'] {
            /* Backgrounds - dark */
            --bg-primary-l: 5%;        --bg-secondary-l: 11%;
            --bg-elevated-l: 20%;      --bg-input-l: 11%;
            --bg-hover-l: 20%;         --bg-subtle-l: 28%;
            --bg-light-l: 11%;         --bg-disabled-l: 5%;
            --bg-selected-l: 20%;
            
            /* Text - light */
            --text-primary-l: 98%;     --text-secondary-l: 83%;
            --text-tertiary-l: 68%;    --text-muted-l: 52%;
            --text-inverse-l: 5%;      --text-disabled-l: 52%;
            
            /* Borders - lighter */
            --border-light-l: 20%;     --border-color-l: 28%;
            --border-dark-l: 52%;      --border-hover-l: 59%;
            
            /* Semantic colors - adjusted for dark backgrounds */
            --primary-l: 67%;          --primary-hover-l: 53%;
            --success-l: 70%;          --success-hover-l: 30%;
            --error-l: 72%;            --error-hover-l: 51%;
            --warning-l: 71%;          --info-l: 67%;
            --secondary-l: 68%;        --secondary-hover-l: 83%;
            
            /* Component adjustments */
            --shadow-opacity: 0.3;     --modal-backdrop-opacity: 0.95;
            --voice-bg-l: 20%;         --voice-border-l: 67%;       --voice-text-l: 74%;
            --tag-bg-l: 20%;           --tag-text-l: 74%;           --tag-border-l: 67%;
            --dream-sign-bg-l: 15%;    --dream-sign-text-l: 81%;    --dream-sign-border-l: 35%;
            --notification-error-l: 20%;   --notification-success-l: 15%;
            --notification-warning-l: 15%; --notification-info-l: 20%;
            
            /* Special dark theme hue adjustments */
            --warning-h: 45;  /* Warmer yellow in dark mode */
        }
        
        /* === GENERATED COLOR SYSTEM === */
        :root,
        [data-theme='light'],
        [data-theme='dark'] {
            /* Core Theme Colors */
            --primary-color: hsl(var(--primary-h), var(--primary-s), var(--primary-l));
            --primary-hover: hsl(var(--primary-h), var(--primary-s), var(--primary-hover-l));
            --secondary-color: hsl(var(--slate-h), var(--slate-s), var(--secondary-l));
            --secondary-hover: hsl(var(--slate-h), var(--slate-s), var(--secondary-hover-l));
            --success-color: hsl(var(--success-h), var(--success-s), var(--success-l));
            --success-hover: hsl(var(--success-h), var(--success-s), var(--success-hover-l));
            --error-color: hsl(var(--error-h), var(--error-s), var(--error-l));
            --error-hover: hsl(var(--error-h), var(--error-s), var(--error-hover-l));
            --warning-color: hsl(var(--warning-h), var(--warning-s), var(--warning-l));
            --warning-hover: hsl(var(--warning-h), var(--warning-s), var(--warning-l));
            --info-color: hsl(var(--info-h), var(--info-s), var(--info-l));
            --info-hover: hsl(var(--info-h), var(--info-s), var(--info-l));
            
            /* Background Hierarchy */
            --bg-primary: hsl(var(--neutral-h), var(--neutral-s), var(--bg-primary-l));
            --bg-secondary: hsl(var(--neutral-h), var(--neutral-s), var(--bg-secondary-l));
            --bg-elevated: hsl(var(--gray-h), var(--gray-s), var(--bg-elevated-l));
            --bg-input: hsl(var(--neutral-h), var(--neutral-s), var(--bg-input-l));
            --bg-hover: hsl(var(--gray-h), var(--gray-s), var(--bg-hover-l));
            --bg-subtle: hsl(var(--slate-h), var(--slate-s), var(--bg-subtle-l));
            --bg-light: hsl(var(--gray-h), var(--gray-s), var(--bg-light-l));
            --bg-disabled: hsl(var(--gray-h), var(--gray-s), var(--bg-disabled-l));
            --bg-selected: hsl(var(--info-h), var(--info-s), var(--bg-selected-l));
            
            /* Text Hierarchy */
            --text-primary: hsl(var(--neutral-h), var(--neutral-s), var(--text-primary-l));
            --text-secondary: hsl(var(--slate-h), var(--slate-s), var(--text-secondary-l));
            --text-tertiary: hsl(var(--gray-h), var(--gray-s), var(--text-tertiary-l));
            --text-muted: hsl(var(--gray-h), var(--gray-s), var(--text-muted-l));
            --text-inverse: hsl(var(--neutral-h), var(--neutral-s), var(--text-inverse-l));
            --text-disabled: hsl(var(--gray-h), var(--gray-s), var(--text-disabled-l));
            
            /* Border System */
            --border-light: hsl(var(--slate-h), var(--slate-s), var(--border-light-l));
            --border-color: hsl(var(--slate-h), var(--slate-s), var(--border-color-l));
            --border-dark: hsl(var(--slate-h), var(--slate-s), var(--border-dark-l));
            --border-hover: hsl(var(--primary-h), var(--primary-s), var(--border-hover-l));
            --border-focus: var(--primary-color);
            
            /* Shadow System */
            --shadow-color: rgba(0, 0, 0, var(--shadow-opacity));
            --shadow-color-light: rgba(0, 0, 0, calc(var(--shadow-opacity) * 0.5));
            --shadow-color-dark: rgba(0, 0, 0, calc(var(--shadow-opacity) * 1.5));
            
            /* Component Specific */
            --modal-backdrop: rgba(0, 0, 0, var(--modal-backdrop-opacity));
            --gradient-primary: linear-gradient(135deg, var(--primary-color), hsl(var(--primary-h), var(--primary-s), calc(var(--primary-l) - 10%)));
            --border-dashed: 2px dashed var(--border-dark);
            
            /* Voice Component Colors */
            --voice-bg-primary: hsl(var(--info-h), var(--info-s), var(--voice-bg-l));
            --voice-border: hsl(var(--info-h), var(--info-s), var(--voice-border-l));
            --voice-text: hsl(var(--info-h), var(--info-s), var(--voice-text-l));
            
            /* Tag & Component Colors */
            --tag-bg: hsl(var(--info-h), var(--info-s), var(--tag-bg-l));
            --tag-text: hsl(var(--info-h), var(--info-s), var(--tag-text-l));
            --tag-border: hsl(var(--info-h), var(--info-s), var(--tag-border-l));
            --dream-sign-bg: hsl(var(--warning-h), var(--warning-s), var(--dream-sign-bg-l));
            --dream-sign-text: hsl(var(--warning-h), var(--warning-s), var(--dream-sign-text-l));
            --dream-sign-border: hsl(var(--warning-h), var(--warning-s), var(--dream-sign-border-l));
            
            /* Interactive States */
            --input-focus-ring: hsla(var(--primary-h), var(--primary-s), var(--primary-l), 0.2);
            --selection-bg: var(--primary-color);
            --selection-text: var(--text-inverse);
            
            /* Notification Backgrounds */
            --notification-error-bg: hsl(var(--error-h), var(--error-s), var(--notification-error-l));
            --notification-success-bg: hsl(var(--success-h), var(--success-s), var(--notification-success-l));
            --notification-warning-bg: hsl(var(--warning-h), var(--warning-s), var(--notification-warning-l));
            --notification-info-bg: hsl(var(--info-h), var(--info-s), var(--notification-info-l));
        }
        
        /* Shadow definitions using the optimized theme system */
        :root,
        [data-theme='light'],
        [data-theme='dark'] {
            --shadow-sm: 0 1px 2px var(--shadow-color);
            --shadow-md: 0 4px 6px var(--shadow-color);
            --shadow-lg: 0 10px 25px var(--shadow-color);
            --shadow-xl: 0 20px 60px var(--shadow-color-dark);
        }
        
        /* Extra Small Mobile Screens */
        @media (max-width: 480px) {
            body {
                padding: 2px;
            }
            
            .container {
                border-radius: 0;
                margin: 0;
            }
            
            .header {
                padding: 15px 10px;
            }
            
            .main-content,
            .tab-panel:not(#journalTab) {
                padding: 10px;
            }
            
            .controls {
                padding: 10px;
            }
            
            .entry-form,
            .settings-section {
                padding: 15px 10px;
            }
            
            .stats-card {
                padding: 15px 10px;
            }
            
            .voice-tab-content {
                padding: 10px;
            }
            
            /* Extra small screens - compress tabs further */
            .app-tab {
                min-width: 50px;
                padding: 12px 6px;
                font-size: 11px;
            }
            
            /* Make date filters stack on very small screens */
            .date-filter-group {
                grid-template-columns: auto 1fr !important;
                grid-template-rows: auto auto !important;
                gap: 6px !important;
            }
            
            .date-filter-group label:nth-child(3) {
                grid-column: 1;
                grid-row: 2;
            }
            
            .date-filter-group input:nth-child(4) {
                grid-column: 2;
                grid-row: 2;
            }
        }
        


        
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-subtle);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
            min-height: 100vh;
        }
        
        /* BASE STYLES & LAYOUT COMPONENTS */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* Smooth theme transitions for all elements */
        *,
        *::before,
        *::after {
            transition: background-color 0.3s ease, 
                       color 0.3s ease, 
                       border-color 0.3s ease, 
                       box-shadow 0.3s ease;
        }
        
        /* Preserve faster transitions for interactive elements */
        button,
        .btn,
        input,
        select,
        textarea {
            transition: background-color 0.3s ease, 
                       color 0.3s ease, 
                       border-color 0.3s ease, 
                       box-shadow 0.3s ease,
                       transform 0.2s ease;
        }

        .autocomplete-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-light);
            font-size: 14px;
            transition: background-color 0.2s;
        }
        .autocomplete-item:hover {
            background-color: var(--bg-hover);
        }
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        
        /* Loading States - Consolidated */
        .loading-state, .search-loading, .loading-dreams {
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            background: var(--bg-light);
            border-radius: var(--border-radius);
            margin: 10px 0;
        }
        
        .loading-state.large, .loading-dreams {
            padding: 40px;
            font-style: normal;
        }
        .loading-state.large div:first-child, .loading-dreams div:first-child {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: var(--bg-primary);
            border-radius: var(--border-radius-xl);
            box-shadow: var(--shadow-lg);
            overflow: hidden;
            width: 100%;
            box-sizing: border-box;
        }
        
        .search-loading {
            padding: 20px;
            text-align: center;
            color: #64748b;
            font-style: italic;
            background: #f8fafc;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .loading-dreams {
            padding: 40px;
            text-align: center;
            color: #64748b;
        }
        .loading-dreams div:first-child {
            font-size: 2em;
            margin-bottom: 10px;
        }
        .header {
            background: var(--gradient-primary);
            color: var(--text-inverse);
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }
        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }
        .controls {
            padding: 20px;
            background: var(--bg-light);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        .control-row-break {
            flex-basis: 100%;
            height: 0;
        }
        .search-filter-group {
            display: flex;
            gap: 10px;
            flex: 1;
            min-width: 500px;
        }
        .export-import-controls {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 15px;
            flex-wrap: wrap;
        }
        .ai-export-control {
            margin-left: auto;
        }
        
        /* Hide file input completely */
        .file-input,
        input[type="file"].file-input,
        #importFile,
        #importAllDataFile {
            display: none !important;
            visibility: hidden !important;
            position: absolute !important;
            left: -9999px !important;
        }
        .search-box {
            flex: 2;
            min-width: 150px;
            padding: 12px 15px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border-color 0.3s;
        }
        .filter-select {
            flex: 1;
            min-width: 90px;
            padding: 12px 15px;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 16px;
            background: var(--bg-input);
            color: var(--text-primary);
            cursor: pointer;
            transition: border-color 0.3s;
        }
        .filter-select:focus,
        .search-box:focus {
            outline: none;
            border-color: var(--border-focus);
        }
        /* Button System */
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: var(--border-radius);
            font-size: 14px;
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }
        
        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 6px;
        }
        
        /* Button Colors - Combined selectors */
        .btn-primary, .btn-success {
            color: white;
        }
        
        .btn-primary {
            background: var(--primary-color);
        }
        .btn-primary:hover {
            background: var(--primary-hover);
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background: var(--secondary-color);
            color: var(--text-primary);
        }
        .btn-secondary:hover {
            background: var(--secondary-hover);
        }
        
        /* Dark theme specific button hover fixes */
        [data-theme='dark'] .btn-secondary {
            color: var(--text-inverse);
        }
        [data-theme='dark'] .btn-secondary:hover {
            background: #64748b;
        }
        
        .btn-success {
            background: var(--success-color);
            color: var(--text-inverse);
        }
        .btn-success:hover {
            background: var(--success-hover);
            color: var(--text-inverse);
        }
        
        .btn-edit {
            background: var(--info-color);
            color: var(--text-inverse);
        }
        .btn-edit:hover {
            background: #0284c7;
        }
        
        .btn-delete {
            background: var(--error-color);
            color: var(--text-inverse);
        }
        .btn-delete:hover {
            background: var(--error-hover);
        }
        
        .btn-confirm-delete {
            background: var(--error-hover);
            color: var(--text-inverse);
            animation: pulse 0.5s ease-in-out;
        }
        .btn-confirm-delete:hover {
            background: #b91c1c;
        }
        
        .btn-lock {
            background: var(--text-tertiary);
            color: var(--text-inverse);
            padding: 8px 12px;
            font-size: 12px;
        }
        .btn-lock:hover {
            background: var(--text-secondary);
        }
        
        /* Loading States - Consolidated */
        .loading-state {
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            background: var(--bg-light);
            border-radius: var(--border-radius);
            margin: 10px 0;
        }
        
        .loading-state.large {
            padding: 40px;
            font-style: normal;
        }
        .loading-state.large div:first-child {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        /* Notification Messages - Consolidated */
        .notification-message {
            font-size: 14px;
            margin-top: 10px;
            padding: 10px;
            border-radius: var(--border-radius);
            display: none;
            font-weight: var(--font-weight-semibold);
        }
        .notification-message.error {
            color: var(--error-color);
            background: var(--notification-error-bg);
        }
        .notification-message.success {
            color: var(--success-color);
            background: var(--notification-success-bg);
        }
        .notification-message.info {
            color: var(--info-color);
            background: var(--notification-info-bg);
        }
        .notification-message.warning {
            color: var(--warning-color);
            background: var(--notification-warning-bg);
        }
        
        /* FORM COMPONENTS & INTERACTIVE ELEMENTS */
        
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: var(--font-weight-semibold);
            color: var(--text-primary);
        }
        .form-control {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 16px;
            transition: border-color 0.3s;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
        }
        .form-control:focus {
            outline: none;
            border-color: var(--border-focus);
        }
        
        .form-control::placeholder,
        .search-box::placeholder {
            color: var(--text-tertiary);
            opacity: 1;
        }
        textarea.form-control {
            min-height: 120px;
            resize: vertical;
        }
        .lucid-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 20px;
        }
        .lucid-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #4f46e5;
        }
        .lucid-checkbox label {
            margin: 0;
            font-weight: var(--font-weight-semibold);
            color: var(--text-primary);
            cursor: pointer;
        }
        .dreams-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            margin-left: 20px;
            margin-right: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .dreams-section-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.3em;
        }
        .dreams-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .autocomplete-management-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 250px;
            overflow-y: auto;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 10px;
            margin-top: 15px;
            background: var(--bg-light);
        }

        .autocomplete-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-radius: 6px;
            font-size: 14px;
            border: 1px solid var(--border-light);
        }

        .autocomplete-list-item.default .item-value {
            color: var(--text-secondary);
            font-style: italic;
        }

        .autocomplete-list-item .item-type {
            font-size: 11px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 10px;
            background: var(--bg-input);
            color: var(--text-tertiary);
            text-transform: uppercase;
            margin-left: 10px;
        }
        .entries-section {
            margin-left: 20px;
            margin-right: 20px;
            margin-top: 24px;
        }
        .entries-section h3 {
            margin-bottom: 20px;
            color: var(--text-primary);
            font-size: 1.3em;
        }
        .entry {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            padding: 20px;
            margin-bottom: 20px;
            transition: var(--transition);
        }
        .entry:hover {
            border-color: var(--border-hover);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.1);
        }
        /* Light Theme Lucid Dreams */
        :root .entry.lucid,
        [data-theme='light'] .entry.lucid {
            border-color: var(--success-color);
            background: linear-gradient(135deg, #f0fdf4, var(--bg-secondary));
            position: relative;
        }
        
        /* Dark Theme Lucid Dreams - More prominent override */
        [data-theme='dark'] .entry.lucid {
            border-color: var(--success-color) !important;
            background: linear-gradient(135deg, #0f2e1a, var(--bg-secondary)) !important;
            position: relative;
        }
        
        .entry.lucid::before {
            content: "✨ LUCID";
            position: absolute;
            top: -10px;
            right: 20px;
            background: var(--success-color);
            color: var(--text-inverse);
            padding: 4px 12px;
            border-radius: var(--border-radius-lg);
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.5px;
        }
        
        /* Light Theme Lucid Hover */
        :root .entry.lucid:hover,
        [data-theme='light'] .entry.lucid:hover {
            border-color: var(--success-hover);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
        }
        
        /* Dark Theme Lucid Hover - More prominent */
        [data-theme='dark'] .entry.lucid:hover {
            border-color: var(--success-hover) !important;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3) !important;
            background: linear-gradient(135deg, #1a3d28, var(--bg-secondary)) !important;
        }
        .entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .entry-title {
            font-size: 1.2em;
            font-weight: var(--font-weight-semibold);
            color: var(--text-primary);
            flex: 1;
        }
        .entry-meta {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .entry-date {
            color: var(--text-secondary);
            font-size: 0.9em;
            font-weight: var(--font-weight-medium);
        }
        .entry-actions {
            display: flex;
            gap: 5px;
        }
        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 6px;
        }
        .btn-edit {
            background: #0ea5e9;
            color: white;
        }
        .btn-edit:hover {
            background: #0284c7;
        }
        .btn-delete {
            background: #ef4444;
            color: white;
        }
        .btn-delete:hover {
            background: #dc2626;
        }
        .btn-confirm-delete {
            background: #dc2626;
            color: white;
            animation: pulse 0.5s ease-in-out;
        }
        .btn-confirm-delete:hover {
            background: #b91c1c;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .delete-pending {
            background: var(--notification-warning-bg);
            border-color: var(--warning-color) !important;
        }
        /* STYLES FOR .edit-mode HAVE BEEN REMOVED AND CONSOLIDATED INTO .inline-edit-form */
        /* This rule is now handled by .inline-edit-form .edit-actions */
        .entry-content {
            color: var(--text-primary);
            line-height: 1.7;
            white-space: pre-wrap;
        }

        .entry-form {
            background: var(--bg-light);
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 30px;
            border: 2px solid var(--border-color);
        }

        .entry-form h3 {
            margin-bottom: 15px;
            color: var(--text-primary);
            font-size: 1.3em;
        }

        .no-entries {
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            padding: 40px;
            background: var(--bg-light);
            border-radius: var(--border-radius-lg);
            border: var(--border-dashed);
        }
        /* Pagination System */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding: 30px 20px;
            margin-top: 20px;
            border-top: 1px solid var(--border-color);
            background: var(--bg-light);
        }
        
        .pagination-info {
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: var(--font-weight-medium);
        }
        
        .pagination-btn, .page-btn {
            border: 2px solid var(--border-color);
            background: var(--bg-secondary);
            border-radius: 6px;
            font-size: 14px;
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: var(--transition);
            color: var(--text-primary);
        }
        
        .pagination-btn {
            padding: 8px 16px;
        }
        
        .page-btn {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .pagination-btn:hover:not(:disabled), .page-btn:hover {
            border-color: var(--border-focus);
            color: var(--primary-color);
        }
        
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pagination-ellipsis {
            display: flex;
            align-items: center;
            padding: 0 8px;
            color: var(--text-secondary);
            font-weight: var(--font-weight-semibold);
        }
        
        .page-btn.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: var(--text-inverse);
        }
        
        .page-numbers {
            display: flex;
            gap: 5px;
        }
        
        .page-ellipsis {
            color: var(--text-secondary);
            font-weight: var(--font-weight-semibold);
            padding: 0 5px;
        }
        
        /* SPECIALIZED COMPONENTS (VOICE, SECURITY, MODALS) */
        
        /* Voice Recording & Tabs */
        .voice-tabs-container {
            background: var(--voice-bg-primary);
            border: 2px solid var(--voice-border);
            border-radius: var(--border-radius-lg);
            margin-bottom: 20px;
            margin-left: 20px;
            margin-right: 20px;
            overflow: hidden;
        }
        
        .voice-tabs {
            display: flex;
            border-bottom: 2px solid var(--voice-border);
            background: var(--bg-secondary);
        }
        
        .voice-tab {
            flex: 1;
            padding: 15px 20px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: var(--transition);
            border-bottom: 3px solid transparent;
        }
        
        .voice-tab:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .voice-tab.active {
            background: var(--voice-bg-primary);
            color: var(--voice-text);
            border-bottom-color: var(--voice-text);
        }
        
        .voice-tab-content {
            padding: 20px;
        }
        
        .voice-tab-panel {
            display: block;
        }
        
        .voice-tab-panel:not(.active) {
            display: none;
        }
        
        .voice-recording-section {
            background: var(--voice-bg-primary);
            border: 2px solid var(--voice-border);
            border-radius: var(--border-radius-lg);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .voice-recording-section h3 {
            color: var(--voice-text);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .voice-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .record-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 140px;
            justify-content: center;
        }
        
        .record-btn.ready {
            background: var(--success-color);
            color: white;
        }
        .record-btn.ready:hover {
            background: var(--success-hover);
            transform: translateY(-2px);
        }
        
        .record-btn.recording {
            background: var(--error-color);
            color: white;
            animation: pulse-record 1.5s ease-in-out infinite;
        }
        
        .record-btn.disabled {
            background: #9ca3af;
            color: #6b7280;
            cursor: not-allowed;
        }
        
        .recording-timer {
            font-family: monospace;
            font-size: 18px;
            font-weight: var(--font-weight-semibold);
            color: var(--error-color);
            background: var(--notification-error-bg);
            padding: 8px 16px;
            border-radius: var(--border-radius);
            border: 2px solid var(--error-color);
        }
        
        .voice-status {
            font-size: 14px;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: var(--font-weight-semibold);
        }
        .voice-status.info {
            background: #dbeafe;
            color: #1d4ed8;
        }
        .voice-status.warning {
            background: #fef3c7;
            color: var(--warning-color);
        }
        .voice-status.error {
            background: #fee2e2;
            color: var(--error-color);
        }
        
        /* Voice Notes */
        .voice-notes-section {
            margin-top: 30px;
            padding: 25px;
            background: var(--bg-light);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
        }
        
        .voice-notes-section h3 {
            color: var(--text-primary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .voice-note {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            transition: var(--transition);
        }
        
        .voice-note:hover {
            border-color: var(--border-hover);
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.1);
        }
        
        .voice-note.delete-pending {
            background: #fef3c7;
            border-color: #f59e0b !important;
        }
        
        .voice-note-info {
            flex: 1;
            min-width: 200px;
        }
        
        .voice-note-title {
            font-weight: var(--font-weight-semibold);
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        
        .voice-note-meta {
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        .voice-note-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            min-width: 300px;
        }
        
        .voice-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .voice-btn.play {
            background: #0ea5e9;
            color: white;
        }
        .voice-btn.play:hover {
            background: #0284c7;
        }
        
        .voice-btn.pause {
            background: #f59e0b;
            color: white;
        }
        .voice-btn.pause:hover {
            background: var(--warning-color);
        }
        
        .voice-btn.transcribe {
            background: #7c3aed;
            color: white;
        }
        .voice-btn.transcribe:hover {
            background: #6d28d9;
        }
        .voice-btn.transcribe:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        
        .voice-btn.download {
            background: var(--success-color);
            color: white;
        }
        .voice-btn.download:hover {
            background: var(--success-hover);
        }
        
        .voice-btn.delete {
            background: var(--error-color);
            color: white;
        }
        .voice-btn.delete:hover {
            background: var(--error-hover);
        }
        
        .voice-progress-container {
            flex: 1;
            min-width: 200px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0 15px;
        }
        
        .voice-progress-bar {
            flex: 1;
            height: 6px;
            background: var(--border-color);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            transition: height 0.2s;
        }
        .voice-progress-bar:hover {
            height: 8px;
        }
        
        .voice-progress-fill {
            height: 100%;
            background: var(--primary-color);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .voice-time-display {
            font-family: monospace;
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 80px;
            text-align: center;
        }
        
        .voice-full-warning {
            background: #fee2e2;
            color: var(--error-color);
            padding: 12px;
            border-radius: var(--border-radius);
            border: 2px solid #fecaca;
            margin-bottom: 15px;
            font-weight: var(--font-weight-semibold);
            text-align: center;
        }
        
        .no-voice-notes {
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            padding: 30px;
            background: var(--bg-light);
            border: var(--border-dashed);
            border-radius: var(--border-radius);
        }
        .pin-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--modal-backdrop);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .pin-container {
            background: var(--bg-elevated);
            padding: 40px;
            border-radius: var(--border-radius-xl);
            box-shadow: var(--shadow-xl);
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        .pin-container h2 {
            color: var(--text-primary);
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        .pin-input {
            width: 100%;
            padding: 15px;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 18px;
            text-align: center;
            letter-spacing: 3px;
            margin-bottom: 20px;
            font-family: monospace;
            background: var(--bg-input);
        }
        .pin-input:focus {
            outline: none;
            border-color: var(--border-focus);
        }
        .pin-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .pin-setup-link {
            color: var(--primary-color);
            text-decoration: underline;
            cursor: pointer;
            font-size: 14px;
            margin-top: 15px;
            display: block;
        }
        .notification-message {
            font-size: 14px;
            margin-top: 10px;
            padding: 10px;
            border-radius: var(--border-radius);
            display: none;
            font-weight: var(--font-weight-semibold);
        }
        .notification-message.error {
            color: var(--error-color);
            background: var(--notification-error-bg);
        }
        .notification-message.success {
            color: var(--success-color);
            background: var(--notification-success-bg);
        }
        .notification-message.info {
            color: var(--info-color);
            background: var(--notification-info-bg);
        }
        .notification-message.warning {
            color: var(--warning-color);
            background: var(--notification-warning-bg);
        }
        
        /* Main App Tabs System */
        .app-tabs {
            display: flex;
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--border-color);
            padding: 0;
            margin: 0;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .app-tabs::-webkit-scrollbar {
            display: none;
        }
        
        .app-tab {
            flex: 1;
            min-width: 80px;
            padding: 16px 12px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-weight: var(--font-weight-semibold);
            font-size: 14px;
            cursor: pointer;
            transition: var(--transition);
            border-bottom: 3px solid transparent;
            white-space: nowrap;
        }
        
        .app-tab:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .app-tab.active {
            background: var(--bg-primary);
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        
        .tab-content-container {
            background: var(--bg-primary);
            min-height: 400px;
            overflow-x: hidden;
        }
        
        .tab-panel {
            display: none;
            width: 100%;
            min-height: 200px;
            background: var(--bg-primary);
            border: 2px solid transparent;
            overflow-x: hidden;
            box-sizing: border-box;
        }
        
        .tab-panel.active {
            display: block;
            border-color: var(--primary-color);
        }
        
        .tab-panel:not(#journalTab) {
            padding: 20px;
        }
        
        /* Stats Tab Styling - Theme-aware */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            padding: 0;
            width: 100%;
            box-sizing: border-box;
        }
        
        .stats-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            padding: 20px;
            text-align: center;
            transition: var(--transition);
            margin-bottom: 15px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .stats-card:hover {
            border-color: var(--border-hover);
            box-shadow: var(--shadow-md);
        }
        
        .hover-card {
            cursor: pointer;
            transition: var(--transition);
        }
        
        .hover-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .goal-card {
            border-left: 4px solid var(--primary-color);
        }
        
        .goal-card.completed {
            border-left-color: var(--success-color);
            opacity: 0.8;
        }
        
        .goal-progress-section {
            background: var(--bg-light);
            padding: 15px;
            border-radius: var(--border-radius);
            margin: 15px 0;
        }
        
        .goal-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        
        .custom-goal-controls {
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
        }
        
        .custom-goal-controls .btn {
            min-width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        
        /* Dark theme fixes for Goals/Advice content boxes */
        [data-theme='dark'] .stats-card {
            background: var(--bg-secondary) !important;
            border-color: var(--border-color) !important;
        }
        
        /* Fix light backgrounds in dynamically created content */
        [data-theme='dark'] div[style*="background: linear-gradient(135deg, #f0f9ff"] {
            background: linear-gradient(135deg, var(--bg-elevated), var(--bg-secondary)) !important;
        }
        
        [data-theme='dark'] div[style*="background: #f8fafc"],
        [data-theme='dark'] div[style*="background: var(--bg-light)"] {
            background: var(--bg-elevated) !important;
        }
        
        [data-theme='dark'] div[style*="background: #f0f9ff"] {
            background: var(--bg-elevated) !important;
        }
        
        [data-theme='dark'] div[style*="background: linear-gradient(135deg, #f0f9ff"] {
            background: linear-gradient(135deg, var(--bg-elevated), var(--bg-secondary)) !important;
        }
        
        .stats-number {
            font-size: 2.5em;
            font-weight: var(--font-weight-semibold);
            color: var(--primary-color);
            margin-bottom: 10px;
        }
        
        .stats-label {
            color: var(--text-secondary);
            font-weight: var(--font-weight-medium);
            margin-bottom: 5px;
        }
        
        .stats-detail {
            color: var(--text-tertiary);
            font-size: 14px;
        }

        /* Pie Chart Styles */
        .pie-chart-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .pie-chart {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            position: relative;
        }

        .pie-chart-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            background: var(--bg-secondary);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            border: 2px solid var(--border-color);
        }

        .pie-chart-total {
            font-size: 1.5em;
            font-weight: var(--font-weight-semibold);
            color: var(--text-primary);
        }

        .pie-chart-label {
            font-size: 0.8em;
            color: var(--text-secondary);
        }

        .pie-chart-legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            padding: 0 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: var(--font-weight-medium);
            color: var(--text-secondary);
        }

        .legend-color-box {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        /* Calendar Styles */
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .calendar-nav {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        /* Modern Calendar Navigation Buttons */
        .calendar-nav-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(145deg, var(--bg-elevated), var(--bg-secondary));
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1), inset 0 1px 2px rgba(255, 255, 255, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }
        
        .calendar-nav-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15), inset 0 1px 3px rgba(255, 255, 255, 0.2);
            background: linear-gradient(145deg, var(--bg-hover), var(--bg-elevated));
        }
        
        .calendar-nav-btn:active {
            transform: scale(0.95);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2), inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        /* Triangular Arrow Shapes */
        .calendar-nav-btn::before {
            content: '';
            width: 0;
            height: 0;
            position: absolute;
        }
        
        .calendar-nav-btn.prev::before {
            border-right: 8px solid var(--text-primary);
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            margin-left: -2px;
        }
        
        .calendar-nav-btn.next::before {
            border-left: 8px solid var(--text-primary);
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            margin-right: -2px;
        }
        
        /* Hover effect for triangle color */
        .calendar-nav-btn:hover::before {
            border-right-color: var(--primary-color);
            border-left-color: var(--primary-color);
        }
        
        /* Dark theme adjustments */
        [data-theme='dark'] .calendar-nav-btn {
            background: linear-gradient(145deg, #374151, #4b5563);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3), inset 0 1px 2px rgba(255, 255, 255, 0.05);
        }
        
        [data-theme='dark'] .calendar-nav-btn:hover {
            background: linear-gradient(145deg, #4b5563, #6b7280);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), inset 0 1px 3px rgba(255, 255, 255, 0.1);
        }
        .calendar-grid {
            width: 100%;
            border-collapse: collapse;
        }
        .calendar-grid th {
            text-align: center;
            padding: 10px;
            font-weight: var(--font-weight-semibold);
            color: var(--text-secondary);
            font-size: 14px;
        }
        .calendar-grid td {
            border: 1px solid var(--border-color);
            height: 100px;
            vertical-align: top;
            padding: 8px;
            width: 14.28%;
        }
        .calendar-day {
            cursor: pointer;
            height: 100%;
            display: flex;
            flex-direction: column;
            border-radius: var(--border-radius);
            transition: background-color 0.2s;
        }
        .calendar-day:hover {
            background: var(--bg-hover);
        }
        .day-number {
            font-weight: var(--font-weight-semibold);
            font-size: 14px;
        }
        .calendar-day.other-month {
            opacity: 0.5;
        }
        .calendar-day.today .day-number {
            color: var(--primary-color);
            background-color: var(--bg-selected);
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .dream-indicator {
            margin-top: 8px;
            background-color: var(--primary-color);
            color: var(--text-inverse);
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 12px;
            font-weight: var(--font-weight-semibold);
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        
        /* Settings Tab Styling */
        .settings-section {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            padding: 25px;
            margin-bottom: 20px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .settings-section h3 {
            color: var(--text-primary);
            margin-bottom: 15px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .settings-grid {
            padding: 0;
            width: 100%;
            box-sizing: border-box;
        }
        
        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid var(--border-light);
        }
        
        .settings-row:last-child {
            border-bottom: none;
        }
        
        .settings-label {
            flex: 1;
            color: var(--text-primary);
            font-weight: var(--font-weight-medium);
        }
        
        .settings-description {
            color: var(--text-secondary);
            font-size: 14px;
            margin-top: 4px;
        }
        
        .settings-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        /* Mobile Tab Optimizations */
        @media (max-width: 768px) {
            .app-tab {
                min-width: 100px;
                padding: 14px 16px;
                font-size: 14px;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
                padding: 0;
                gap: 15px;
            }
            
            .settings-grid {
                padding: 0;
            }
            
            .settings-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .settings-controls {
                width: 100%;
                justify-content: flex-start;
            }
        }
        
        /* Utility classes for common spacing */
        .text-center { text-align: center; }
        .font-weight-600 { font-weight: 600; }
        .border-radius-8 { border-radius: 8px; }
        .margin-bottom-20 { margin-bottom: 20px; }
        .padding-15 { padding: 15px; }
        .meta-item { display: inline; }
        .tag, .dream-sign {
            display: inline-block;
            padding: 3px 8px;
            margin: 2px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: lowercase;
        }
        .tag {
            background: var(--tag-bg);
            color: var(--tag-text);
            border: 1px solid var(--tag-border);
        }
        .dream-sign {
            background: var(--dream-sign-bg);
            color: var(--dream-sign-text);
            border: 1px solid var(--dream-sign-border);
        }
        .dream-sign::before {
            content: "⚡ ";
            font-size: 10px;
        }
        .entry-tags {
            margin-top: 8px;
            line-height: 1.4;
        }
        .entry-tags .tag-section {
            display: inline-block;
            margin-right: 12px;
        }
        .entry-tags .tag-label {
            font-size: 11px;
            color: #64748b;
            font-weight: 600;
            margin-right: 4px;
        }
        .tag-input-group {
            position: relative;
        }
        .tag-autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-elevated);
            border: 2px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 var(--border-radius) var(--border-radius);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: var(--shadow-md);
        }
        .autocomplete-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-light);
            font-size: 14px;
            transition: background-color 0.2s;
        }
        .autocomplete-item:hover {
            background-color: var(--bg-hover);
        }
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        .timer-warning {
            background: var(--error-color);
            color: var(--text-inverse);
            padding: 15px 20px;
            text-align: center;
            font-weight: var(--font-weight-semibold);
            font-size: 16px;
            display: none;
            position: relative;
        }
        .timer-warning.active {
            display: block;
        }
        .timer-warning button {
            background: var(--text-inverse);
            color: var(--error-color);
            border: none;
            padding: 5px 15px;
            border-radius: 5px;
            margin-left: 15px;
            cursor: pointer;
            font-weight: var(--font-weight-semibold);
        }
        .timer-warning button:hover {
            background: var(--notification-error-bg);
        }
        .migration-notice {
            background: var(--notification-info-bg);
            color: var(--info-color);
            padding: 15px;
            border-radius: var(--border-radius);
            margin: 20px;
            font-weight: var(--font-weight-semibold);
            text-align: center;
            display: none;
        }
        .voice-recording-section {
            background: var(--voice-bg-primary);
            border: 2px solid var(--voice-border);
            border-radius: var(--border-radius-lg);
            padding: 20px;
            margin-bottom: 20px;
        }
        .voice-recording-section h3 {
            color: var(--voice-text);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .voice-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .record-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 140px;
            justify-content: center;
        }
        .record-btn.ready {
            background: var(--success-color);
            color: var(--text-inverse);
        }
        .record-btn.ready:hover {
            background: var(--success-hover);
            transform: translateY(-2px);
        }
        .record-btn.recording {
            background: var(--error-color);
            color: var(--text-inverse);
            animation: pulse-record 1.5s ease-in-out infinite;
        }
        .record-btn.disabled {
            background: var(--text-muted);
            color: var(--text-tertiary);
            cursor: not-allowed;
        }
        @keyframes pulse-record {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .recording-timer {
            font-family: monospace;
            font-size: 18px;
            font-weight: var(--font-weight-semibold);
            color: var(--error-color);
            background: var(--notification-error-bg);
            padding: 8px 16px;
            border-radius: var(--border-radius);
            border: 2px solid var(--error-color);
        }
        .voice-status {
            font-size: 14px;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: 600;
        }
        .voice-status.info {
            background: var(--notification-info-bg);
            color: var(--info-color);
        }
        .voice-status.warning {
            background: var(--notification-warning-bg);
            color: var(--warning-color);
        }
        
        /* Force dark theme colors for voice status warning */
        [data-theme='dark'] .voice-status.warning {
            background: #78350f !important;
            color: #fde047 !important;
            border: 1px solid #a16207 !important;
        }
        
        /* Target voice status within voice recording section specifically */
        [data-theme='dark'] .voice-recording-section .voice-status.warning,
        [data-theme='dark'] .voice-tab-content .voice-status.warning {
            background: #78350f !important;
            color: #fde047 !important;
            border: 1px solid #a16207 !important;
        }
        
        /* Catch-all for any voice status warning in dark theme */
        [data-theme='dark'] *[class*="voice-status"][class*="warning"],
        [data-theme='dark'] div[class*="voice-status"][class*="warning"] {
            background: #78350f !important;
            color: #fde047 !important;
            border: 1px solid #a16207 !important;
        }
        [data-theme='dark'] body #voiceStatus.voice-status.warning,
        [data-theme='dark'] html body #voiceStatus.voice-status.warning {
            background: #78350f !important;
            color: #fde047 !important;
            border: 1px solid #a16207 !important;
        }
        .voice-status.error {
            background: var(--notification-error-bg);
            color: var(--error-color);
        }
        .voice-notes-section {
            margin-top: 30px;
            padding: 25px;
            background: var(--bg-light);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
        }
        .voice-notes-section h3 {
            color: var(--text-primary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .voice-note {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        @media (max-width: 768px) {
            .voice-note-container {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            .voice-note-controls {
                min-width: auto;
                justify-content: center;
            }
            .voice-progress-container {
                min-width: auto;
                margin: 0 5px;
            }
            
            /* Voice Tabs Mobile */
            .voice-tab {
                padding: 12px 16px;
                font-size: 14px;
            }
            
            .voice-tab-content {
                padding: 15px;
            }
            
            /* Stats Tabs Mobile */
            .stats-tab {
                padding: 12px 16px;
                font-size: 14px;
            }
            
            .stats-tab-content {
                padding: 15px;
            }

            #tipText {
                font-size: 0.9em;
            }

            #tipCounter {
                font-size: 0.6em;
            }
        }
        .voice-note:hover {
            border-color: #c7d2fe;
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.1);
        }
        .voice-note-info {
            flex: 1;
            min-width: 200px;
        }
        .voice-note-title {
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 4px;
        }
        .voice-note-meta {
            color: #64748b;
            font-size: 14px;
        }
        .voice-note-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            min-width: 300px;
        }
        .voice-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .voice-btn.play {
            background: var(--info-color);
            color: var(--text-inverse);
        }
        .voice-btn.play:hover {
            background: #0284c7;
        }
        .voice-btn.pause {
            background: var(--warning-color);
            color: var(--text-inverse);
        }
        .voice-btn.pause:hover {
            background: #d97706;
        }
        .voice-btn.transcribe {
            background: #7c3aed;
            color: var(--text-inverse);
        }
        .voice-btn.transcribe:hover {
            background: #6d28d9;
        }
        .voice-btn.transcribe:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
        }
        .voice-btn.download {
            background: var(--success-color);
            color: var(--text-inverse);
        }
        .voice-btn.download:hover {
            background: var(--success-hover);
        }
        .voice-btn.delete {
            background: var(--error-color);
            color: var(--text-inverse);
        }
        .voice-btn.delete:hover {
            background: var(--error-hover);
        }
        .voice-progress-container {
            flex: 1;
            min-width: 200px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0 15px;
        }
        .voice-progress-bar {
            flex: 1;
            height: 6px;
            background: var(--border-color);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            transition: height 0.2s;
        }
        .voice-progress-bar:hover {
            height: 8px;
        }
        .voice-progress-fill {
            height: 100%;
            background: var(--primary-color);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }
        .voice-time-display {
            font-family: monospace;
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 80px;
            text-align: center;
        }
        .voice-full-warning {
            background: var(--notification-error-bg);
            color: var(--error-color);
            padding: 12px;
            border-radius: var(--border-radius);
            border: 2px solid var(--error-color);
            margin-bottom: 15px;
            font-weight: var(--font-weight-semibold);
            text-align: center;
        }
        .no-voice-notes {
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            padding: 30px;
            background: var(--bg-light);
            border: var(--border-dashed);
            border-radius: var(--border-radius);
        }
        
        /* RESPONSIVE DESIGN & MOBILE OPTIMIZATION */
        
        /* Mobile Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header {
                padding: 20px;
            }
            .header h1 {
                font-size: 2em;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-row-break {
                display: none;
            }
            
            .search-filter-group {
                flex-direction: column;
                min-width: auto;
                gap: 10px;
            }
            
            .search-box, .filter-select {
                min-width: auto;
                flex: none;
            }
            
            .main-content {
                padding: 15px;
                overflow-x: hidden;
                max-width: 100%;
                box-sizing: border-box;
            }
            
            .tab-panel:not(#journalTab) {
                padding: 15px;
            }
            
            .entry-form {
                padding: 15px;
                margin-bottom: 20px;
            }
            
            /* Mobile Form Control Fixes */
            .form-control {
                padding: 10px 12px;
                font-size: 16px;
                width: 100%;
                box-sizing: border-box;
                max-width: 100%;
            }
            
            .form-group {
                margin-bottom: 15px;
            }
            
            .form-group label {
                font-size: 14px;
                margin-bottom: 6px;
            }
            
            .lucid-checkbox {
                margin-bottom: 15px;
            }
            
            textarea.form-control {
                min-height: 100px;
                resize: vertical;
            }
            
            .entry {
                padding: 15px;
            }
            
            .entry-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .entry-meta {
                width: 100%;
                justify-content: space-between;
                align-items: center;
            }
            
            .entry-actions {
                flex-shrink: 0;
            }
            
            .pagination {
                flex-direction: column;
                gap: 15px;
            }
            
            .page-numbers {
                order: -1;
            }
            
            .pagination-btn {
                min-width: 100px;
            }
            
            .security-controls {
                margin-left: 0;
                margin-top: 10px;
                justify-content: center;
            }
            
            .voice-note {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            
            .voice-note-controls {
                min-width: auto;
                justify-content: center;
            }
            
            .voice-progress-container {
                min-width: auto;
                margin: 0 5px;
            }
        }
        
        /* Footer Styles */
        footer {
            background: var(--bg-light);
            border-top: 1px solid var(--border-color);
            padding: 20px;
            margin-top: 40px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        footer div {
            max-width: 800px;
            margin: 0 auto;
        }
        
        footer p {
            margin-bottom: 10px;
        }
        
        footer p:last-child {
            margin: 0;
            font-size: 12px;
            opacity: 0.8;
        }


    </style>
        <script>
        (function() {
            try {
            var theme = localStorage.getItem('dreamJournalTheme') || 'dark';
            document.documentElement.setAttribute('data-theme', theme);
            } catch (e) {}
        })();
        </script>
</head>
<body>
    <!-- MAIN APPLICATION STRUCTURE -->
    
    <div class="container" style="visibility: hidden;">
        <div class="timer-warning" id="timerWarning">
            ⚠️ <strong>PIN RESET TIMER ACTIVE</strong> - Someone has initiated a PIN reset!
            <span id="timerWarningTime"></span>
            <button data-action="cancel-timer">Cancel Timer</button>
        </div>
        
        <div id="migrationNotice" class="migration-notice">
            📦 Migrating your dreams to improved storage...
        </div>
        
        <div class="header">
            <h1>🌙 Dream Journal</h1>
            <p>Capture your dreams and discover patterns for lucid dreaming</p>
        </div>
        
        <!-- Main App Tabs Navigation -->
        <div class="app-tabs">
            <button class="app-tab active" data-action="switch-app-tab" data-tab="journal">
                📝 Journal
            </button>
            <button class="app-tab" data-action="switch-app-tab" data-tab="goals">
                🎯 Goals
            </button>
            <button class="app-tab" data-action="switch-app-tab" data-tab="stats">
                📊 Stats
            </button>
            <button class="app-tab" data-action="switch-app-tab" data-tab="advice">
                💡 Advice
            </button>
            <button class="app-tab" data-action="switch-app-tab" data-tab="settings">
                ⚙️ Settings
            </button>
            <button class="app-tab" data-action="switch-app-tab" data-tab="lock" style="display: none;">
                🔒 Locked
            </button>
        </div>
        
        <!-- Tab Content Container -->
        <div class="tab-content-container">
            <!-- Journal Tab (All existing functionality) -->
            <div id="journalTab" class="tab-panel">
        <div class="main-content">
            <div class="entry-form" id="dreamFormFull">
                <h3 data-action="toggle-dream-form" style="cursor: pointer; user-select: none;">
                    🌙 Record Your Dream 
                    <span class="text-xs text-secondary font-normal">(Click to collapse)</span>
                </h3>
                <div class="form-group">
                    <label for="dreamDate">Dream Date & Time</label>
                    <input type="datetime-local" id="dreamDate" class="form-control">
                </div>
                <div class="lucid-checkbox">
                    <input type="checkbox" id="isLucid">
                    <label for="isLucid">This was a lucid dream ✨</label>
                </div>
                <div class="form-group">
                    <label for="dreamTitle">Dream Title (optional)</label>
                    <input type="text" id="dreamTitle" class="form-control" placeholder="Give your dream a memorable title...">
                </div>
                <div class="form-group">
                    <label for="dreamContent">Dream Description</label>
                    <textarea id="dreamContent" class="form-control" placeholder="Describe your dream in as much detail as you can remember..." required></textarea>
                </div>
                <div class="form-group">
                    <label for="dreamEmotions">Emotions Experienced (optional)</label>
                    <input type="text" id="dreamEmotions" class="form-control" placeholder="e.g., happy, anxious, excited, confused (separate with commas)">
                    <small class="small-helper">
                        Common emotions: happy, sad, anxious, excited, confused, peaceful, scared, angry, joyful, curious
                    </small>
                </div>
                <div class="form-group">
                    <label for="dreamTags">Tags & Themes (optional)</label>
                    <div class="tag-input-group">
                        <input type="text" id="dreamTags" class="form-control" placeholder="e.g., family, flying, school, animals (separate with commas)">
                    </div>
                    <small class="small-helper">
                        Tag your dream with themes, people, places, objects, or activities for easy searching
                    </small>
                </div>
                <div class="form-group">
                    <label for="dreamSigns">⚡ Dream Signs (Lucidity Triggers) (optional)</label>
                    <div class="tag-input-group">
                        <input type="text" id="dreamSigns" class="form-control" placeholder="e.g., flying, text-changing, deceased-alive (separate with commas)">
                    </div>
                    <small class="small-helper-warning">
                        Elements that could trigger lucidity - track these to improve dream awareness!
                    </small>
                </div>
                <button data-action="save-dream" class="btn btn-primary">Save Dream</button>
            </div>
            
            <!-- Collapsed Form State -->
            <div class="entry-form" id="dreamFormCollapsed" style="display: none;">
                <h3 data-action="toggle-dream-form" style="cursor: pointer; user-select: none;">
                    📝 Record Your Dream 
                    <span class="text-xs text-secondary font-normal">(Click to expand)</span>
                </h3>
            </div>
            
            <div class="voice-tabs-container">
                <div class="voice-tabs">
                    <button class="voice-tab active" data-action="switch-voice-tab" data-tab="record">
                        🎤 Record
                    </button>
                    <button class="voice-tab" data-action="switch-voice-tab" data-tab="stored">
                        🎵 Stored Notes
                    </button>
                </div>
                
                <div class="voice-tab-content">
                    <!-- Record Tab -->
                    <div id="voiceTabRecord" class="voice-tab-panel active">
                        <div class="voice-controls">
                            <button id="recordBtn" data-action="toggle-recording" class="record-btn ready">
                                <span id="recordIcon">🎤</span>
                                <span id="recordText">Start Recording</span>
                            </button>
                            <div id="recordingTimer" class="recording-timer" style="display: none;">0:00</div>
                            <div id="voiceStatus" class="voice-status info">Checking browser capabilities for voice features...</div>
                        </div>
                    </div>
                    
                    <!-- Stored Notes Tab -->
                    <div id="voiceTabStored" class="voice-tab-panel" style="display: none;">
                        <div id="voiceNotesContainer"></div>
                    </div>
                </div>
            </div>
            <div class="dreams-section-header">
                <h3>Your Dreams</h3>
                <div class="dreams-controls">
                    <button data-action="toggle-lock" id="lockBtn" class="btn btn-lock" title="Set up a PIN to secure your dreams, then lock the journal">🔒 Setup & Lock</button>
                    <button data-action="export-ai" class="btn btn-success" title="Export a prompt for analysis by an AI model">🤖 Export for AI Analysis</button>
                </div>
            </div>
            <div class="controls">
            <div class="search-filter-group">
                <input type="text" id="searchBox" class="search-box" placeholder="Search dreams by title, content, emotions, tags, or dream signs...">
                <select id="filterSelect" class="filter-select">
                    <option value="all">All Dreams</option>
                    <option value="lucid">Lucid Dreams</option>
                    <option value="non-lucid">Non-Lucid Dreams</option>
                </select>
                <select id="sortSelect" class="filter-select">
                    <option value="newest">Newest First</option>
                    <option value="oldest">Oldest First</option>
                    <option value="lucid-first">Lucid First</option>
                    <option value="longest">Longest First</option>
                </select>
                <select id="limitSelect" class="filter-select">
                    <option value="5">Show 5</option>
                    <option value="10">Show 10</option>
                    <option value="20">Show 20</option>
                    <option value="50">Show 50</option>
                    <option value="endless" selected>Endless</option>
                    <option value="all">Show All</option>
                </select>
            </div>
            <div class="date-filter-group" style="display: grid; grid-template-columns: auto 1fr auto 1fr; gap: 8px; align-items: center;">
                <label for="startDateFilter" class="form-label-inline text-primary" style="font-size: 13px;">From:</label>
                <input type="date" id="startDateFilter" class="filter-select" style="padding: 8px; font-size: 14px;">
                <label for="endDateFilter" class="form-label-inline text-primary" style="font-size: 13px;">To:</label>
                <input type="date" id="endDateFilter" class="filter-select" style="padding: 8px; font-size: 14px;">
            </div>
            <div class="control-row-break"></div>
        </div>
            <div class="entries-section">
                <div id="entriesContainer"></div>
                <div id="paginationContainer"></div>
            </div>
        </div>
    </div>
    
    <!-- Footer -->
    <footer class="app-footer">
        <div style="max-width: 800px; margin: 0 auto;">
            <p style="margin-bottom: 10px;">
                <strong>Disclaimer:</strong> This application is for entertainment and personal journaling purposes only. 
                It is not intended to provide medical, psychological, or therapeutic advice. 
                If you have concerns about your sleep, dreams, or mental health, please consult a qualified healthcare professional.
            </p>
            <p style="margin-bottom: 10px; font-size: 12px;">
                Licensed under <a href="https://www.gnu.org/licenses/agpl-3.0.html" target="_blank" style="color: var(--primary-color);">AGPL v3.0</a> | <a href="https://github.com/Webdreamjournal/DreamJournal" target="_blank" style="color: var(--primary-color);">Source Code</a>
            </p>
            <p class="app-footer p">
                Dream Journal v1.43.10 | Not a substitute for professional medical advice
            </p>
        </div>
    </footer>

    <!-- PIN Protection Overlay -->
    <div id="pinOverlay" class="pin-overlay" style="display: none;">
        <div class="pin-container">
            <h2 id="pinTitle">🔒 Enter PIN</h2>
            <p id="pinMessage">Your dreams are protected. Enter your PIN to access them.</p>
            <input type="password" id="pinInput" class="pin-input" placeholder="Enter PIN" maxlength="6">
            <div class="pin-buttons">
                <button data-action="verify-pin" class="btn btn-primary" id="pinMainBtn">Unlock</button>
                <button data-action="hide-pin-overlay" class="btn btn-secondary" id="cancelPinBtn">Cancel</button>
            </div>
            <div id="pinFeedback" class="notification-message error"></div>
            <div id="pinSuccess" class="notification-message success"></div>
            <div id="pinInfo" class="notification-message info"></div>
            <span data-action="show-pin-setup" class="pin-setup-link" id="pinSetupLink">Setup new PIN</span>
            <span data-action="show-remove-pin" class="pin-setup-link" id="removePinLink" style="display: none;">Remove PIN protection</span>
            <span data-action="show-forgot-pin" class="pin-setup-link" id="forgotPinLink" style="display: none;">Forgot PIN?</span>
        </div>
    </div>

    <input type="file" id="importFile" class="file-input" accept=".txt,.enc">
    <input type="file" id="importAllDataFile" class="file-input" accept=".json,.enc">
    <script>
    (function() {
        "use strict";
    // ===================================================================================
    //                                TABLE OF CONTENTS
    // ===================================================================================
    //
    // 1.  CONSTANTS & CONFIGURATION
    // 2.  GLOBAL APPLICATION STATE
    // 3.  DOM & UI HELPERS
    // 4.  DATABASE & STORAGE
    // 5.  CORE LOGIC (Subdivided by Feature)
    //     5.1  Dream CRUD
    //     5.2  Voice Notes System
    //     5.3  Goal Management
    //     5.4  Stats & Calendar
    //     5.5  Import, Export & Data Management
    //     5.6  Security & PIN Logic
    // 6.  EVENT HANDLERS & ACTION ROUTING
    // 7.  INITIALIZATION
    //
    // ===================================================================================


    // ===================================================================================
    // SECTION 1: CONSTANTS & CONFIGURATION
    // ===================================================================================

    // UI State Keys
    const DREAM_FORM_COLLAPSE_KEY = 'dreamFormCollapsed';
    
    // Application Constants - Single Source of Truth
    const CONSTANTS = {
        // Voice Recording Limits
        VOICE_STORAGE_LIMIT: 5,
        
        // Security & PIN Constants
        PIN_RESET_HOURS: 72,
        PIN_MIN_LENGTH: 4,
        PIN_MAX_LENGTH: 6,
        PASSWORD_MIN_LENGTH: 4,
        FAILED_PIN_ATTEMPT_LIMIT: 3,
        
        // Cryptography Constants
        CRYPTO_SALT_SIZE: 16,
        CRYPTO_IV_SIZE: 12,
        CRYPTO_PBKDF2_ITERATIONS: 100000,
        CRYPTO_KEY_LENGTH: 256,
        
        // Performance & Debouncing
        DEBOUNCE_SEARCH_MS: 300,
        DEBOUNCE_FILTER_MS: 150,
        DEBOUNCE_SCROLL_MS: 100,
        ENDLESS_SCROLL_THRESHOLD_PX: 500,
        ENDLESS_SCROLL_INCREMENT: 5,
        
        // Data Limits
        MAX_TAGS_PER_DREAM: 20,
        MAX_TAG_LENGTH: 50,
        AI_ANALYSIS_RECENT_LIMIT: 15,
        AI_ANALYSIS_TOTAL_LIMIT: 20,
        AI_ANALYSIS_THRESHOLD: 50,
        LARGE_DATASET_THRESHOLD: 50,
        
        // UI & Autocomplete
        AUTOCOMPLETE_MIN_CHARS: 2,
        AUTOCOMPLETE_MAX_RESULTS: 8,
        DOM_TRAVERSAL_LEVELS: 3,
        TEXT_TRUNCATE_LENGTH: 50,
        
        // Pagination Constants
        PAGINATION_MAX_VISIBLE_PAGES: 7,
        PAGINATION_CURRENT_PAGE_PROXIMITY: 4,
        PAGINATION_ELLIPSIS_THRESHOLD: 3,
        
        // File Size Constants
        BYTES_PER_KB: 1024,
        BYTES_PER_MB: 1048576, // 1024 * 1024
        
        // Database Constants
        DB_VERSION: 5,
        DATETIME_LOCAL_SLICE_LENGTH: 16,
        
        // UI Timing & Durations (milliseconds)
        MESSAGE_DURATION_SHORT: 3000,
        MESSAGE_DURATION_MEDIUM: 5000,
        MESSAGE_DURATION_LONG: 7000,
        MESSAGE_DURATION_EXTENDED: 10000,
        CLEANUP_DELAY_MS: 3000,
        FOCUS_DELAY_MS: 100,
        
        // File & Storage
        BACKUP_UPDATE_DELAY_MS: 100,
        DOWNLOAD_CLEANUP_DELAY_MS: 3000
    };
    
    // Goal templates
    const GOAL_TEMPLATES = {
        'lucid-monthly': {
            title: 'Monthly Lucid Dreams',
            description: 'Achieve lucid dreams this month',
            type: 'lucid_count',
            period: 'monthly',
            target: 3,
            icon: '✨'
        },
        'recall-streak': {
            title: 'Dream Recall Streak',
            description: 'Remember dreams for consecutive days',
            type: 'recall_streak',
            period: 'streak',
            target: 7,
            icon: '🧠'
        },
        'journal-habit': {
            title: 'Daily Journaling',
            description: 'Write in dream journal consistently',
            type: 'journal_streak',
            period: 'streak',
            target: 30,
            icon: '📝'
        },
        'dream-signs': {
            title: 'Dream Signs Collection',
            description: 'Identify and track dream signs',
            type: 'dream_signs_count',
            period: 'total',
            target: 10,
            icon: '🔍'
        },
        'custom': {
            title: 'Custom Goal',
            description: 'Track your personal goal manually',
            type: 'custom',
            period: 'total',
            target: 1,
            icon: '⭐'
        }
    };

    const dailyTips = [
        { category: 'Scientific Foundations and Research', text: 'Understand the hybrid consciousness state: Lucid dreams occur during REM sleep but show unique brain activity - combining REM-like delta and theta waves with wake-like 40Hz gamma activity in frontal regions.' },
        { category: 'Scientific Foundations and Research', text: 'Know your REM timing: REM sleep periods get progressively longer throughout the night, with the final REM period lasting 45-60 minutes - this is prime time for lucid dreaming attempts.' },
        { category: 'Scientific Foundations and Research', text: 'Learn about acetylcholine\'s role: This neurotransmitter is crucial for REM sleep and dream vividness. Understanding this helps explain why some supplements can increase lucid dream frequency.' },
        { category: 'Scientific Foundations and Research', text: 'Recognize individual variation: Only about 50-60% of people ever experience lucid dreams naturally, with less than 1% having them multiple times per week - your natural ability varies significantly.' },
        { category: 'Scientific Foundations and Research', text: 'Use verified communication methods: Stephen LaBerge proved lucid dreams are real by having dreamers signal with pre-arranged eye movements during REM sleep, which were recorded on EEG equipment.' },
        { category: 'Scientific Foundations and Research', text: 'Understand the prefrontal cortex connection: Increased activity in the anterior prefrontal cortex during lucid dreams enables the self-awareness and metacognition necessary for recognizing the dream state.' },
        { category: 'Scientific Foundations and Research', text: 'Know the research timeline: Modern lucid dream research began on April 12, 1975, when Keith Hearne first recorded verified signals from a lucid dreamer - now celebrated as Lucid Dreaming Day.' },
        { category: 'Scientific Foundations and Research', text: 'Learn about gamma wave activity: Successful lucid dreams show increased 40Hz gamma wave activity, particularly in frontal brain regions associated with consciousness and self-awareness.' },
        { category: 'Scientific Foundations and Research', text: 'Understand sleep architecture: Lucid dreams maintain all normal REM characteristics (rapid eye movements, muscle atonia, high-frequency EEG) while adding higher-order consciousness functions.' },
        { category: 'Scientific Foundations and Research', text: 'Recognize frequency statistics: Research shows MILD technique increases lucid dream frequency from baseline 3.7% to approximately 13% when properly practiced.' },
        { category: 'Scientific Foundations and Research', text: 'Know about phasic REM activity: Lucid dreams are associated with increased REM density (more frequent eye movements) compared to regular REM sleep periods.' },
        { category: 'Scientific Foundations and Research', text: 'Understand memory limitations in dreams: Even when lucid, dreamers can access episodic memories but often with significant distortions and inaccuracies compared to waking recall.' },
        { category: 'Scientific Foundations and Research', text: 'Learn about metacognitive networks: Lucid dreaming activates brain regions involved in self-referential processing and metacognition, including the default mode network.' },
        { category: 'Scientific Foundations and Research', text: 'Recognize sleep quality impact: Research indicates spontaneous lucid dreaming doesn\'t significantly impair overall sleep quality when occurring naturally.' },
        { category: 'Scientific Foundations and Research', text: 'Understand neural connectivity: Frequent lucid dreamers show increased functional connectivity between anterior prefrontal cortex and angular gyrus during both sleep and waking states.' },
        { category: 'Scientific Foundations and Research', text: 'Know about transcranial stimulation research: Scientists have successfully induced lucid dreams using 25Hz and 40Hz transcranial alternating current stimulation in controlled studies.' },
        { category: 'Scientific Foundations and Research', text: 'Learn about targeted memory reactivation: Recent studies achieve 50% lucid dream success rates by playing sounds during REM that were paired with pre-sleep lucid dreaming training.' },
        { category: 'Scientific Foundations and Research', text: 'Understand the motor cortex connection: Mental practice of physical skills in lucid dreams activates the same brain regions as actual physical practice and can improve real-world performance.' },
        { category: 'Scientific Foundations and Research', text: 'Recognize meditation correlations: Long-term meditators experience 4.28 lucid dreams per month compared to 2.55 for non-meditators, likely due to enhanced metacognitive abilities.' },
        { category: 'Scientific Foundations and Research', text: 'Know about dream content incorporation: External stimuli presented during REM sleep can be incorporated into dream content, forming the basis for technological lucid dream induction devices.' },
        { category: 'Scientific Foundations and Research', text: 'Understand consciousness spectrum: Lucid dreams represent a unique state on the consciousness spectrum - neither fully asleep nor awake, but possessing qualities of both states.' },
        { category: 'Scientific Foundations and Research', text: 'Learn about developmental patterns: Many frequent lucid dreamers report first experiences in childhood or adolescence, with ability appearing relatively stable across the adult lifespan.' },
        { category: 'Scientific Foundations and Research', text: 'Recognize therapeutic validation: The American Academy of Sleep Medicine now includes Lucid Dreaming Therapy (LDT) as an effective treatment option for nightmare disorder.' },
        { category: 'Scientific Foundations and Research', text: 'Know about PTSD research: Recent studies show 85% of PTSD participants experienced "remarkable decrease" in symptoms after lucid dreaming workshops, with benefits persisting at 4-week follow-up.' },
        { category: 'Scientific Foundations and Research', text: 'Understand false awakening neuroscience: False awakenings occur because the brain\'s reality monitoring systems remain partially compromised even during lucid dreams.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Master the finger-through-palm test: Press your finger against your opposite palm. In dreams, your finger will typically pass through your palm, making this an extremely reliable reality check. Because dream physics is based on expectation, it is profoundly unlikely to fail.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Use the nose-pinch breathing test: Pinch your nose closed and try to breathe. In dreams, you can often breathe normally even with your nose pinched, making this both discreet and highly effective for most dreamers.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Examine your hands carefully: Look at your hands and count your fingers. In dreams, hands frequently appear distorted, have the wrong number of fingers, or show impossible details.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Check digital clocks twice: Look at a digital clock, look away, then look back. In dreams, the time will often change dramatically between glances or show impossible times, though this requires genuine attention to detail.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Read text multiple times: Read any text (signs, books, labels), look away, then read again. Dream text typically changes between readings or appears as meaningless symbols, though this works best when you truly expect text instability.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Perform 10-15 reality checks daily: Consistency is key - spread reality checks throughout your day rather than clustering them in one period.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Associate checks with triggers: Link reality checks to specific daily events like walking through doorways, hearing phones ring, or seeing your reflection.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Question with genuine curiosity: Don\'t perform reality checks mechanically. Always ask "Am I dreaming?" with sincere interest in the answer and emotional investment.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Use the light switch test: Flip light switches on and off. In dreams, lights often don\'t work properly or behave in impossible ways.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Check your reflection: Look at yourself in mirrors. Dream reflections are often distorted, show the wrong person, or display impossible features.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Examine written text closely: Look for details in text like specific words, letters, or numbers. Dream text is often blurry, changes when re-read, or contains nonsensical content.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Test electronic devices: Try using phones, computers, or other electronic devices. In dreams, they rarely function normally and often display strange or impossible information.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Question your memory: Ask yourself how you got to your current location and what you did earlier in the day. Dream memory is often incomplete or nonsensical.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Check the time format: Look for impossible times like 25:73 or 14:92. Digital clocks in dreams often show times that don\'t exist in reality.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Use the gravity test: Jump up and see how quickly you fall. In dreams, you might float, fly, or fall very slowly due to altered dream physics.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Examine environmental details: Look for inconsistencies in your surroundings - rooms that change size, doors that lead to wrong places, or objects that shouldn\'t be there.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Test cause and effect: Try simple actions like turning doorknobs, pushing buttons, or moving objects. Dream logic often breaks down with simple physical interactions.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Count your fingers carefully: Not just a quick glance - actually count each finger one by one. Dreams often show extra fingers, fewer fingers, or fingers that change as you count.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Check analog clocks: While less reliable than digital clocks, analog clocks in dreams often have wrong numbers, move backwards, or show impossible configurations.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Question conversations: Pay attention to whether conversations make logical sense and if people respond appropriately to what you\'re saying.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Use the breathing awareness test: Focus on your breathing pattern. In dreams, you might notice you\'re not breathing at all or breathing in impossible ways.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Test your balance: Stand on one foot or try to walk in a straight line. Dream physics often makes balance and coordination feel different from waking life.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Look at your shoes or clothing: Check if you\'re wearing what you remember putting on. Dream clothing often changes or appears inappropriate for the situation.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Use the writing test: Try to write your name or a simple sentence. In dreams, writing is often impossible or produces illegible scribbles.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Check for pain sensation: Pinch yourself gently. In dreams, pain sensations are often muted or completely absent.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Question the weather: If outdoors, notice if the weather makes sense and remains consistent. Dream weather often changes impossibly or defies physical laws.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Examine fine details: Look closely at textures, patterns, or small objects. Dreams often lack fine detail that would be present in waking vision.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Use the color consistency test: Notice if colors remain stable when you look away and back. Dream colors sometimes shift or appear impossible.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Test your knowledge: Try to remember specific facts, phone numbers, or addresses. Dream memory often fails to provide accurate specific information.' },
        { category: 'Reality Checking Techniques and Methods', text: 'Check your keys or wallet: Look for items you always carry. In dreams, these familiar objects are often missing or completely different.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Keep your journal within arm\'s reach: Place a notebook and pen directly beside your bed so you can reach them without getting up or turning on lights.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Record immediately upon waking: Don\'t move, stretch, or think about your day first. Dreams fade within 5-10 minutes, so capture them instantly upon awakening.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Write in present tense: Record dreams as if they\'re happening now ("I am walking down a hallway") rather than past tense to maintain vividness and emotional connection.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Capture fragments without judgment: Even tiny dream pieces are valuable. Record partial memories, single images, or emotions rather than waiting for complete recall.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Include the date and sleep details: Note the date, approximate sleep duration, and sleep quality to track patterns over time.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Create meaningful dream titles: Give each dream a memorable title that captures its essence, making it easier to reference and remember later.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Record emotions prominently: Document the feelings experienced during dreams, as emotions often provide clues to underlying dream meanings and triggers.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Note all characters present: Write down everyone in your dream, including strangers, family members, friends, and fictional characters.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Describe locations in detail: Document where dreams take place, including familiar locations, unknown places, and impossible or changing environments.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Use keywords for quick capture: Develop a personal shorthand system for quickly noting dream elements without losing momentum.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Draw visual elements: Sketch objects, people, or scenes from your dreams, especially unusual or impossible visual elements that words can\'t fully capture.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Note dream transitions: Record how scenes changed, whether abruptly or gradually, as these transitions can become reality check triggers.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Identify recurring dream signs: Mark repeated elements, themes, or characters that appear across multiple dreams - these become your personal dream signs.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Rate dream vividness: Use a 1-10 scale to rate how vivid and memorable each dream was, helping track factors that influence dream intensity.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Record pre-sleep activities: Note what you did, ate, or experienced before bed to identify factors that influence dream content and lucidity.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Use voice recording when helpful: If writing is too disruptive, use voice memos on your phone, then transcribe later while the recording helps refresh your memory.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Color-code different themes: Use different colored pens or highlighters to mark different types of dream content (nightmares, lucid dreams, recurring themes).' },
        { category: 'Dream Journal Practices and Approaches', text: 'Include sensory details: Record not just what you saw, but what you heard, felt, smelled, or tasted in the dream.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Note impossible elements: Mark things that couldn\'t happen in real life, as these become valuable dream signs for future recognition.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Track lucidity levels: When you have any level of dream awareness, rate it from 1-10 and note what triggered the lucidity.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Create weekly review sessions: Set aside time each week to read through recent entries and identify patterns, themes, and potential dream signs.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Use mind maps for complex dreams: For dreams with multiple scenes or complex narratives, create visual maps showing how different elements connect.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Record false awakenings: Document dreams where you thought you woke up but were still dreaming, as these can become lucidity triggers.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Note seasonal or cyclical patterns: Track whether certain types of dreams occur more frequently during specific times of year or months.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Include waking life connections: Note any obvious connections between dream content and recent waking experiences, thoughts, or concerns.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Use dream dictionaries wisely: While personal associations matter most, occasionally reference dream symbol dictionaries to explore alternative meanings.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Create a dream sign catalog: Maintain a separate list of your most common dream signs, updating it regularly as you identify new patterns.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Track technique effectiveness: Note which lucid dreaming techniques you used before sleep and whether they preceded successful lucid dreams.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Record sleep position: Notice if sleeping position affects dream content or lucidity, as different positions can influence dream experiences.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Use apps or digital tools: Consider dream journal apps that allow voice recording, easy searching, and pattern recognition features.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Share with others when appropriate: Discussing dreams with friends or dream groups can provide new perspectives and insights.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Include health factors: Note if illness, medications, or physical discomfort affected your dreams, as these factors can significantly influence dream content.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Practice dream re-entry: If you wake from an interesting dream, try to fall back asleep and re-enter the same dream scenario.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Record dreams from naps: Include daytime nap dreams in your journal, as they often have different qualities and may be easier to remember.' },
        { category: 'Dream Journal Practices and Approaches', text: 'Create monthly summaries: At month\'s end, summarize the most significant dreams, patterns observed, and progress made toward lucid dreaming goals.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Practice MILD after dream recall: Use Mnemonic Induction of Lucid Dreams by recalling a recent dream and visualizing becoming lucid when encountering a dream sign from that dream.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Set strong intentions with MILD: Repeat the mantra "The next time I dream, I will remember that I am dreaming" while falling asleep after the WBTB technique.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Master the WBTB timing: Wake after 4.5-6 hours of sleep, stay awake for 30-60 minutes practicing lucid dreaming techniques, then return to sleep.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Combine WBTB with MILD: Use the wake period to practice MILD visualization and intention-setting for maximum effectiveness.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Try WILD during afternoon naps: Wake-Initiated Lucid Dreams work better during naps when you\'re not deeply tired and can maintain awareness during sleep onset.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Remain completely still during WILD: Allow your body to fall asleep while keeping your mind alert - don\'t move even if you feel uncomfortable sensations.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Expect sleep paralysis with WILD: This is normal and harmless - your body naturally paralyzes during REM sleep, and awareness of this paralysis is temporary.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Focus on hypnagogic imagery: During WILD, observe the images that appear behind your eyelids without engaging with them emotionally.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Use SSILD\'s sensory cycling: Practice Senses Initiated Lucid Dreams by cycling attention between vision (darkness behind eyelids), hearing (sounds around you), and touch (body sensations).' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Keep SSILD cycles gentle: Don\'t strain or force sensations - subtle awareness of each sense for 30-60 seconds is more effective than intense focus.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Try FILD finger movements: Upon waking during WBTB, make barely perceptible finger movements as if playing piano while falling back asleep.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Practice DILD through reality checks: Dream-Initiated Lucid Dreams happen when reality checks or dream sign recognition triggers lucidity within an ongoing dream.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Use visualization before sleep: Spend 10-15 minutes visualizing yourself becoming lucid and accomplishing specific dream goals.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Set multiple intentions: Rather than just intending to become lucid, set specific intentions for what you\'ll do once lucid.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Practice during optimal REM periods: Time your induction attempts for early morning hours when REM sleep is longest and most frequent.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Use the counting method: Count slowly from 1 to 100 while maintaining awareness during sleep onset, which can trigger WILD experiences.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Try the rope climbing technique: Visualize climbing an invisible rope above your body while falling asleep to maintain consciousness during transition.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Practice dream re-entry: If you wake from a non-lucid dream, immediately try to fall back asleep and re-enter the same dream with lucidity.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Use mantras during techniques: Repeat phrases like "I am dreaming" or "Next time I\'m dreaming, I\'ll remember I\'m dreaming" during induction attempts.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Experiment with different sleep positions: Some people find certain positions (back, side) more conducive to specific techniques like WILD.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Practice the wake-back-to-bed variation: Try staying awake for just 5-15 minutes during WBTB for a gentler approach that\'s less disruptive to sleep.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Use prospective memory training: Practice remembering to do specific actions during the day to strengthen the memory skills needed for MILD.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Try technique rotation: Use different induction methods on different nights to prevent habituation and maintain effectiveness.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Focus on dream signs during MILD: Identify specific elements from your dream journal and practice recognizing them as triggers for lucidity.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Use emotional involvement: Add genuine excitement and anticipation to your intention-setting rather than just mechanical repetition.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Practice the reflection technique: During wake periods, ask yourself "How did I get here?" to strengthen critical thinking skills for dreams.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Try micro-WBTB sessions: Wake briefly several times during the night and set lucid dreaming intentions without fully getting up.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Use the alarm clock method: Set an alarm for early morning REM periods, but place it across the room so you must get up to turn it off.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Practice the elevator technique: Visualize ascending in an elevator while falling asleep, which can trigger feelings of floating into lucid dreams.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Combine techniques strategically: Use WBTB for timing, MILD for intention-setting, and reality checks throughout the day for comprehensive coverage.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Try the spinning technique: If you feel yourself waking during a dream, spin around in the dream to stabilize and maintain lucidity.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Use external cues: Place sticky notes or objects around your room to remind you to question reality throughout the day.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Practice the CAT technique: The Cycle Adjustment Technique involves gradually shifting your sleep schedule to align with optimal REM timing.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Try all-day awareness: Maintain heightened awareness of your mental states throughout waking hours to strengthen metacognitive abilities.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Use the SSILD plateau: After several SSILD cycles, allow yourself to fall asleep naturally without forcing the technique.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Practice dream yoga techniques: Incorporate traditional Tibetan dream yoga methods like maintaining awareness across all states of consciousness.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Try the phantom limb technique: Focus on imaginary sensations in your limbs while falling asleep to maintain body awareness during sleep onset.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Use the doorway technique: Visualize walking through doorways in your dreams as triggers for lucidity checks.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Practice the breathing focus method: Maintain attention on your breath during sleep onset while allowing the body to relax completely.' },
        { category: 'Induction Techniques (MILD, WILD, DILD, WBTB, etc.)', text: 'Try the temperature technique: Use slight temperature changes (cooler or warmer room) during WBTB periods to increase cortical activation.' }
    ];
    
    // Goals pagination constants
    const GOALS_PER_PAGE = 5;


    // ===================================================================================
    // SECTION 2: GLOBAL APPLICATION STATE
    // ===================================================================================

    // Voice recording variables
    let mediaRecorder = null;
    let audioChunks = [];
    let recordingStartTime = null;
    let recordingTimer = null;
    let currentPlayingAudio = null;
    
    // Speech recognition variables
    let speechRecognition = null;
    let recognitionResults = '';
    let isTranscribing = false;
    
    // Performance optimization: Debouncing utilities
    let searchDebounceTimer = null;
    let filterDebounceTimer = null;
    
    // Mutex/Semaphore system for preventing race conditions
    const asyncMutex = {
        displayDreams: { locked: false, queue: [] },
        saveDreams: { locked: false, queue: [] },
        saveGoals: { locked: false, queue: [] },
        voiceOperations: { locked: false, queue: [] },
        deleteOperations: { locked: false, queue: [] }
    };
    
    // Generic mutex implementation
    async function withMutex(mutexName, operation) {
        const mutex = asyncMutex[mutexName];
        if (!mutex) {
            console.error(`Unknown mutex: ${mutexName}`);
            return operation();
        }
        
        return new Promise((resolve, reject) => {
            const executeOperation = async () => {
                if (mutex.locked) {
                    mutex.queue.push({ operation, resolve, reject });
                    return;
                }
                
                mutex.locked = true;
                try {
                    const result = await operation();
                    resolve(result);
                } catch (error) {
                    reject(error);
                } finally {
                    mutex.locked = false;
                    
                    // Process next item in queue
                    if (mutex.queue.length > 0) {
                        const next = mutex.queue.shift();
                        setTimeout(() => executeOperation.call(next), 0);
                    }
                }
            };
            
            executeOperation();
        });
    }
    
    // Endless scroll variables (with proper state management)
    const endlessScrollState = {
        enabled: false,
        loaded: 0,
        loading: false,
        lastScrollTime: 0
    };
    
    let scrollDebounceTimer = null;
    
    // In-memory fallback for when storage isn't available
    let memoryStorage = [];
    let memoryVoiceNotes = [];
    
    // UI state variables
    let currentPage = 1;
    let deleteTimeouts = {}; // Track delete confirmation timeouts
    let voiceDeleteTimeouts = {}; // Track voice note delete confirmation timeouts
    
    // PIN protection state
    let isUnlocked = false;
    let failedPinAttempts = 0;
    
    // UI form state
    let isDreamFormCollapsed = false;
    
    // Voice tab state
    let activeVoiceTab = 'record';
    
    // Main app tab state
    let activeAppTab = 'journal';
    let isAppLocked = false;
    
    // Tips navigation state
    let currentTipIndex = 0;
    
    // Goals data state
    let allGoals = [];
    
    // Goals pagination state
    let activeGoalsPage = 1;
    let completedGoalsPage = 1;


    // ===================================================================================
    // SECTION 3: DOM & UI HELPERS
    // ===================================================================================

    // DOM Helper Functions (defined early to be available everywhere)

    // Create action button with consistent data attributes
    function createActionButton(action, id, text, className = 'btn', extraAttrs = {}) {
        const attrs = Object.entries(extraAttrs)
            .map(([key, value]) => `${key}="${escapeAttr(value)}"`)
            .join(' ');
        
        const idAttr = id ? `data-${action.includes('dream') ? 'dream' : 'voice-note'}-id="${escapeAttr(id)}"` : '';
        
        return `<button data-action="${action}" ${idAttr} class="${className}" ${attrs}>${text}</button>`;
    }

    // Create inline message with consistent styling
    function createInlineMessage(type, text, options = {}) {
        const {
            container = null,
            position = 'top', // 'top' or 'bottom'
            autoHide = true,
            duration = type === 'success' ? 3000 : 5000,
            className = ''
        } = options;
        
        const msg = document.createElement('div');
        msg.className = `message-base message-${type} ${className}`.trim();
        msg.textContent = text;
        
        if (container) {
            if (position === 'top') {
                container.insertBefore(msg, container.firstChild);
            } else {
                container.appendChild(msg);
            }
            
            if (autoHide) {
                setTimeout(() => {
                    if (msg && msg.parentNode) {
                        msg.remove();
                    }
                }, duration);
            }
        }
        
        return msg;
    }

    // Create meta information display
    function createMetaDisplay(items) {
        return items
            .filter(item => item && item.value)
            .map(item => {
                if (item.label) {
                    return `<span class="meta-item">${escapeHtml(item.label)}: ${escapeHtml(item.value)}</span>`;
                } else {
                    return `<span class="meta-item">${escapeHtml(item.value)}</span>`;
                }
            })
            .join(' • ');
    }

    // HTML escape function to prevent XSS
    function escapeHtml(text) {
        if (text == null) return '';
        const div = document.createElement('div');
        div.textContent = String(text);
        return div.innerHTML;
    }

    // HTML escape for attributes (quotes and special chars)
    function escapeAttr(text) {
        if (text == null) return '';
        return String(text).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    }

    // Create pagination HTML
    function createPaginationHTML(currentPage, totalPages, actionPrefix) {
        if (totalPages <= 1) return '';
        
        let paginationHTML = '<div class="pagination">';
        
        // Previous button
        if (currentPage > 1) {
            paginationHTML += `<button data-action="${actionPrefix}" data-page="${currentPage - 1}" class="btn btn-outline btn-small">‹ Previous</button>`;
        }
        
        // Page numbers
        const maxVisiblePages = 5;
        let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
        let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
        
        // Adjust start page if we're near the end
        if (endPage - startPage < maxVisiblePages - 1) {
            startPage = Math.max(1, endPage - maxVisiblePages + 1);
        }
        
        // First page and ellipsis
        if (startPage > 1) {
            paginationHTML += `<button data-action="${actionPrefix}" data-page="1" class="btn btn-outline btn-small">1</button>`;
            if (startPage > 2) {
                paginationHTML += '<span class="pagination-ellipsis">...</span>';
            }
        }
        
        // Page number buttons
        for (let i = startPage; i <= endPage; i++) {
            const isCurrentPage = i === currentPage;
            const buttonClass = isCurrentPage ? 'btn btn-primary btn-small' : 'btn btn-outline btn-small';
            paginationHTML += `<button data-action="${actionPrefix}" data-page="${i}" class="${buttonClass}" ${isCurrentPage ? 'disabled' : ''}>${i}</button>`;
        }
        
        // Last page and ellipsis
        if (endPage < totalPages) {
            if (endPage < totalPages - 1) {
                paginationHTML += '<span class="pagination-ellipsis">...</span>';
            }
            paginationHTML += `<button data-action="${actionPrefix}" data-page="${totalPages}" class="btn btn-outline btn-small">${totalPages}</button>`;
        }
        
        // Next button
        if (currentPage < totalPages) {
            paginationHTML += `<button data-action="${actionPrefix}" data-page="${currentPage + 1}" class="btn btn-outline btn-small">Next ›</button>`;
        }
        
        paginationHTML += '</div>';
        return paginationHTML;
    }

    // ADVICE TAB FUNCTIONS
    function displayTip(index) {
        const tipTextElement = document.getElementById('tipText');
        const tipCounterElement = document.getElementById('tipCounter');

        if (tipTextElement && tipCounterElement && dailyTips && dailyTips.length > 0) {
            // Ensure index is within bounds and handle negative numbers
            const safeIndex = ((index % dailyTips.length) + dailyTips.length) % dailyTips.length;

            const tip = dailyTips[safeIndex];
            tipTextElement.innerHTML = `<h4 class="text-primary mb-md">${escapeHtml(tip.category)}</h4><p class="line-height-loose">${escapeHtml(tip.text)}</p>`;
            tipCounterElement.textContent = `${safeIndex + 1} / ${dailyTips.length}`;
            currentTipIndex = safeIndex;
        }
    }

    function handleTipNavigation(direction) {
        let newIndex = currentTipIndex;
        if (direction === 'next') {
            newIndex++;
        } else {
            newIndex--;
        }
        displayTip(newIndex);
    }

    // THEME MANAGEMENT SYSTEM

    // Get current theme from storage or default to dark
    function getCurrentTheme() {
        if (isLocalStorageAvailable()) {
            return localStorage.getItem('dreamJournalTheme') || 'dark';
        }
        return 'dark';
    }

    // Store theme preference
    function storeTheme(theme) {
        if (isLocalStorageAvailable()) {
            try {
                localStorage.setItem('dreamJournalTheme', theme);
            } catch (error) {
                console.warn('Failed to store theme preference:', error);
            }
        }
    }

    // Apply theme to document
    function applyTheme(theme) {
        if (!theme || !['light', 'dark'].includes(theme)) {
            theme = 'dark';
        }
        
        document.documentElement.setAttribute('data-theme', theme);
        
        // Update theme select if it exists
        const themeSelect = document.getElementById('themeSelect');
        if (themeSelect) {
            themeSelect.value = theme;
        }
        
        storeTheme(theme);
    }

    // Switch theme
    function switchTheme(newTheme) {
        if (!newTheme || !['light', 'dark'].includes(newTheme)) {
            return;
        }
        
        applyTheme(newTheme);
        
        // Update any visible theme selects
        const themeSelects = document.querySelectorAll('#themeSelect');
        themeSelects.forEach(select => {
            if (select.value !== newTheme) {
                select.value = newTheme;
            }
        });
        
        // Show feedback specifically in the Appearance settings section
        const appearanceSection = document.querySelector('.settings-section h3');
        let targetContainer = null;
        
        if (appearanceSection && appearanceSection.textContent.includes('Appearance')) {
            targetContainer = appearanceSection.parentElement;
        }
        
        // Fallback to active tab if appearance section not found
        if (!targetContainer) {
            targetContainer = document.querySelector('.tab-panel.active');
        }
        
        if (targetContainer) {
            // Remove any existing theme messages first
            const existingMsg = targetContainer.querySelector('.theme-feedback-message');
            if (existingMsg) {
                existingMsg.remove();
            }
            
            // Create the message element directly for precise placement
            const msgDiv = document.createElement('div');
            msgDiv.className = 'theme-feedback-message';
            msgDiv.style.cssText = `
                background: var(--notification-success-bg);
                color: var(--success-color);
                padding: 10px 15px;
                border-radius: var(--border-radius);
                margin: 10px 0;
                font-weight: var(--font-weight-semibold);
                text-align: center;
                font-size: 14px;
            `;
            msgDiv.textContent = `Switched to ${newTheme} theme!`;
            
            // Find the appearance section and insert after it
            if (appearanceSection && appearanceSection.textContent.includes('Appearance')) {
                const appearanceDiv = appearanceSection.parentElement;
                appearanceDiv.insertBefore(msgDiv, appearanceDiv.children[1]);
            } else {
                // Fallback to inserting at the top
                targetContainer.insertBefore(msgDiv, targetContainer.firstChild);
            }
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                if (msgDiv && msgDiv.parentNode) {
                    msgDiv.remove();
                }
            }, 3000);
        }
    }

    // Switch main app tabs
    function switchAppTab(tabName) {
        if (!tabName || !['journal', 'goals', 'stats', 'advice', 'settings', 'lock'].includes(tabName)) return;
        
        // Handle lock screen transitions
        if (tabName === 'lock') {
            // Switching TO lock screen
            if (!isAppLocked) {
                preLockActiveTab = activeAppTab; // Remember current tab
                isAppLocked = true;
                hideAllTabButtons();
            }
        } else {
            // Switching FROM lock screen to another tab
            if (isAppLocked) {
                isAppLocked = false;
                showAllTabButtons();
            }
        }
        
        // Update the lock tab button visibility based on app state
        const lockTabButton = document.querySelector('.app-tab[data-tab="lock"]');
        if (lockTabButton) {
            if (tabName === 'lock') {
                // Show lock tab button when on lock screen
                lockTabButton.style.display = 'block';
            } else {
                // Hide lock tab button when not on lock screen (users should use lock button instead)
                lockTabButton.style.display = 'none';
            }
        }
        
        // CRITICAL FIX: Ensure tab container exists with robust fallback
        let tabContainer = document.querySelector('.tab-content-container');
        if (!tabContainer) {
            console.warn('Tab container not found during switchAppTab, attempting to create it');
            
            const containerDiv = document.querySelector('.container');
            const appTabs = document.querySelector('.app-tabs');
            
            if (containerDiv && appTabs) {
                tabContainer = document.createElement('div');
                tabContainer.className = 'tab-content-container';
                tabContainer.style.cssText = `
                    background: var(--bg-primary);
                    min-height: 400px;
                    overflow-x: hidden;
                `;
                
                appTabs.parentNode.insertBefore(tabContainer, appTabs.nextSibling);
                console.log('Tab container created during switchAppTab');
            } else {
                console.error('Cannot create tab container - missing DOM elements');
                return;
            }
        }
        
        // Ensure all tab panels exist
        const requiredTabs = ['journalTab', 'goalsTab', 'statsTab', 'adviceTab', 'settingsTab', 'lockTab'];
        requiredTabs.forEach(tabId => {
            if (!document.getElementById(tabId)) {
                const tabPanel = document.createElement('div');
                tabPanel.id = tabId;
                tabPanel.className = 'tab-panel';
                
                if (tabId === 'goalsTab') {
                    tabPanel.innerHTML = `
                        <div class="settings-section">
                            <div class="flex-between mb-lg">
                                <h3>🎯 Your Dream Goals</h3>
                                <button data-action="create-goal" class="btn btn-primary btn-small">➕ New Goal</button>
                            </div>
                            <div id="activeGoalsContainer">
                                <!-- Active goals will be populated here -->
                            </div>
                            <div id="activeGoalsPagination" class="pagination-container" style="display: none;">
                                <!-- Active goals pagination will be populated here -->
                            </div>
                            <div id="noGoalsMessage" class="card-md text-center" style="display: none;">
                                <div class="icon-lg mb-md">🎯</div>
                                <h4 class="mb-sm">No Active Goals</h4>
                                <p class="text-secondary mb-md">Create your first goal to start tracking your lucid dreaming progress!</p>
                                <button data-action="create-goal" class="btn btn-primary">Create Your First Goal</button>
                            </div>
                        </div>
                        
                        <div class="settings-section">
                            <h3>📈 Quick Goal Templates</h3>
                            <div class="grid-auto">
                                <div class="stats-card hover-card" data-action="create-template-goal" data-template="lucid-monthly">
                                    <div class="icon-lg">✨</div>
                                    <div class="stats-label">Monthly Lucid Goals</div>
                                    <div class="stats-detail">Track lucid dreams per month</div>
                                    <button class="btn btn-outline btn-small mt-sm">Use Template</button>
                                </div>
                                <div class="stats-card hover-card" data-action="create-template-goal" data-template="recall-streak">
                                    <div class="icon-lg">🧠</div>
                                    <div class="stats-label">Dream Recall Streak</div>
                                    <div class="stats-detail">Remember dreams daily</div>
                                    <button class="btn btn-outline btn-small mt-sm">Use Template</button>
                                </div>
                                <div class="stats-card hover-card" data-action="create-template-goal" data-template="journal-habit">
                                    <div class="icon-lg">📝</div>
                                    <div class="stats-label">Journaling Habit</div>
                                    <div class="stats-detail">Write consistently</div>
                                    <button class="btn btn-outline btn-small mt-sm">Use Template</button>
                                </div>
                                <div class="stats-card hover-card" data-action="create-template-goal" data-template="dream-signs">
                                    <div class="icon-lg">🔍</div>
                                    <div class="stats-label">Dream Signs Tracking</div>
                                    <div class="stats-detail">Identify recurring patterns</div>
                                    <button class="btn btn-outline btn-small mt-sm">Use Template</button>
                                </div>
                                <div class="stats-card hover-card" data-action="create-template-goal" data-template="custom">
                                    <div class="icon-lg">⭐</div>
                                    <div class="stats-label">Custom Goal</div>
                                    <div class="stats-detail">Manual progress tracking</div>
                                    <button class="btn btn-outline btn-small mt-sm">Use Template</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="settings-section">
                            <h3>🏆 Completed Goals</h3>
                            <div id="completedGoalsContainer">
                                <!-- Completed goals will be populated here -->
                            </div>
                            <div id="completedGoalsPagination" class="pagination-container" style="display: none;">
                                <!-- Completed goals pagination will be populated here -->
                            </div>
                            <div id="noCompletedGoalsMessage" class="text-center text-secondary p-lg" style="display: none;">
                                <div class="icon-lg mb-sm">🏆</div>
                                <p>Your completed goals will appear here</p>
                            </div>
                        </div>
                    `;
                } else if (tabId === 'statsTab') {
                    tabPanel.innerHTML = `
                        <div id="statsContainer">
                            <div id="calendarContainer" class="card-md mb-lg">
                                <!-- Calendar will be generated here -->
                                <div class="loading-state">Loading calendar...</div>
                            </div>
                            
                            <!-- Stats Tabs Navigation -->
                            <div class="stats-tabs">
                                <button class="stats-tab active" data-action="switch-stats-tab" data-tab="month">
                                    📅 Month
                                </button>
                                <button class="stats-tab" data-action="switch-stats-tab" data-tab="year">
                                    📆 Year
                                </button>
                                <button class="stats-tab" data-action="switch-stats-tab" data-tab="lifetime">
                                    🏆 Lifetime
                                </button>
                                <button class="stats-tab" data-action="switch-stats-tab" data-tab="dream-signs">
                                    ⚡ Dream Signs
                                </button>
                            </div>
                            
                            <!-- Stats Tab Content -->
                            <div class="stats-tab-content">
                                <!-- Month Tab -->
                                <div id="statsTabMonth" class="stats-tab-panel active">
                                    <div class="stats-grid">
                                        <div id="monthlyStatsContainer" class="card-md">
                                            <!-- Monthly stats will be generated here -->
                                            <h3 class="text-primary mb-md">Monthly Stats</h3>
                                            <div class="loading-state">Loading stats...</div>
                                        </div>
                                        <div id="pieChartContainer" class="card-md">
                                            <!-- Pie chart will be generated here -->
                                            <h3 class="text-primary mb-md">Dream Types</h3>
                                            <div class="loading-state">Loading chart...</div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Year Tab -->
                                <div id="statsTabYear" class="stats-tab-panel" style="display: none;">
                                    <div class="stats-grid">
                                        <div id="yearlyStatsContainer" class="card-md">
                                            <!-- Yearly stats will be generated here -->
                                            <h3 class="text-primary mb-md">Yearly Stats</h3>
                                            <div class="loading-state">Loading yearly stats...</div>
                                        </div>
                                        <div id="yearlyPieChartContainer" class="card-md">
                                            <!-- Yearly pie chart will be generated here -->
                                            <h3 class="text-primary mb-md">Year Dream Types</h3>
                                            <div class="loading-state">Loading yearly chart...</div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Lifetime Tab -->
                                <div id="statsTabLifetime" class="stats-tab-panel" style="display: none;">
                                    <div class="stats-grid">
                                        <div id="lifetimeStatsContainer" class="card-md">
                                            <!-- Lifetime stats will be generated here -->
                                            <h3 class="text-primary mb-md">Lifetime Stats</h3>
                                            <div class="loading-state">Loading lifetime stats...</div>
                                        </div>
                                        <div id="lifetimePieChartContainer" class="card-md">
                                            <!-- Lifetime pie chart will be generated here -->
                                            <h3 class="text-primary mb-md">All-Time Dream Types</h3>
                                            <div class="loading-state">Loading lifetime chart...</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Dream Signs Tab -->
                                <div id="statsTabDreamSigns" class="stats-tab-panel" style="display: none;">
                                    <div id="dreamSignWordCloudContainer" class="card-md mb-lg">
                                        <!-- Word cloud will be generated here -->
                                        <h3 class="text-primary mb-md">Dream Sign Word Cloud</h3>
                                        <div class="loading-state">Loading word cloud...</div>
                                    </div>
                                    <div id="dreamSignListContainer" class="card-md">
                                        <!-- Dream sign list will be generated here -->
                                        <h3 class="text-primary mb-md">Dream Sign Lucidity Rate</h3>
                                        <div class="loading-state">Loading list...</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (tabId === 'adviceTab') {
                    tabPanel.innerHTML = `
                        <div class="settings-section">
                            <h3>💡 Daily Lucid Dreaming Tip</h3>
                            <div id="dailyTipContainer" class="card-elevated card-lg text-center">
                                <p id="tipText" class="text-lg line-height-loose mb-lg" style="height: 180px; overflow-y: auto;">Loading tip...</p>
                                <div class="tip-navigation flex-between">
                                    <button id="prevTip" data-action="prev-tip" class="calendar-nav-btn prev" title="Previous Tip"></button>
                                    <span id="tipCounter" class="font-semibold text-secondary">Tip 1 / 375</span>
                                    <button id="nextTip" data-action="next-tip" class="calendar-nav-btn next" title="Next Tip"></button>
                                </div>
                            </div>
                        </div>

                        <div class="settings-section">
                            <h3 class="mb-lg">📚 Lucid Dreaming Techniques</h3>
                            <div class="grid-auto">
                                <div class="stats-card hover-card">
                                    <h4 class="text-primary mb-sm">🔄 MILD Technique</h4>
                                    <p class="text-secondary text-sm line-height-relaxed">Mnemonic Induction: As you fall asleep, repeat "Next time I'm dreaming, I'll remember I'm dreaming" while visualizing becoming lucid.</p>
                                </div>
                                <div class="stats-card hover-card">
                                    <h4 class="text-primary mb-sm">⏰ WBTB Method</h4>
                                    <p class="text-secondary text-sm line-height-relaxed">Wake-Back-to-Bed: Wake up 4-6 hours after sleep, stay awake for 20-30 minutes thinking about lucid dreaming, then return to sleep.</p>
                                </div>
                                <div class="stats-card hover-card">
                                    <h4 class="text-primary mb-sm">✋ Reality Checks</h4>
                                    <p class="text-secondary text-sm line-height-relaxed">Daily Habit: Check your hands, read text twice, or look at digital clocks. In dreams, these often appear distorted.</p>
                                </div>
                            </div>
                        </div>

                        <div class="settings-section">
                            <h3 class="mb-lg">💡 General Advice</h3>
                            <div class="grid-auto">
                                <div class="stats-card hover-card">
                                    <h4 class="text-primary mb-sm">🧘 Sleep Optimization</h4>
                                    <p class="text-secondary text-sm line-height-relaxed">Maintain consistent sleep and wake times to improve REM sleep quality and dream recall. Avoid screens 1 hour before bed. Blue light can disrupt melatonin production and dream intensity.</p>
                                </div>
                                <div class="stats-card hover-card">
                                    <h4 class="text-primary mb-sm">📝 Dream Journaling</h4>
                                    <p class="text-secondary text-sm line-height-relaxed">Keep a dream journal by your bed. Write down your dreams as soon as you wake up. This improves dream recall and helps you identify recurring dream signs.</p>
                                </div>
                                <div class="stats-card hover-card">
                                    <h4 class="text-primary mb-sm">🥗 Supplements & Nutrition</h4>
                                    <p class="text-secondary text-sm line-height-relaxed">Certain supplements like Vitamin B6 can enhance dream vividness. A balanced diet supports overall brain health, which is crucial for dreaming.</p>
                                </div>
                                <div class="stats-card hover-card">
                                    <h4 class="text-primary mb-sm">🤔 Troubleshooting</h4>
                                    <p class="text-secondary text-sm line-height-relaxed">If you're struggling, focus on improving dream recall first. Don't get discouraged by dry spells; consistency is key.</p>
                                </div>
                            </div>
                        </div>

                        <div class="settings-section">
                            <p class="text-secondary text-sm text-center line-height-relaxed">
                                <strong>Disclaimer:</strong> This application is for entertainment and personal journaling purposes only. It is not intended to provide medical, psychological, or therapeutic advice. If you have concerns about your sleep, dreams, or mental health, please consult a qualified healthcare professional.
                            </p>
                        </div>
                    `;
                } else if (tabId === 'settingsTab') {
                    // Get current theme to set correct option as selected
                    const currentTheme = getCurrentTheme();
                    const lightSelected = currentTheme === 'light' ? 'selected' : '';
                    const darkSelected = currentTheme === 'dark' ? 'selected' : '';
                    
                    tabPanel.innerHTML = `
                        <div class="settings-section">
                            <h3>🎨 Appearance</h3>
                            <div class="settings-row">
                                <div>
                                    <div class="settings-label">Theme</div>
                                    <div class="settings-description">Choose your preferred color theme</div>
                                </div>
                                <div class="settings-controls">
                                    <select id="themeSelect" class="filter-select" style="min-width: 120px;">
                                        <option value="light" ${lightSelected}>🌞 Light</option>
                                        <option value="dark" ${darkSelected}>🌙 Dark</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>🔐 Security</h3>
                            <div class="settings-row">
                                <div>
                                    <div class="settings-label">PIN Protection</div>
                                    <div class="settings-description">Secure your dreams with a PIN code</div>
                                </div>
                                <div class="settings-controls">
                                    <button data-action="setup-pin" id="setupPinBtnSettings" class="btn btn-secondary">⚙️ Setup PIN</button>
                                </div>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>💾 Data Management</h3>
                            
                            <!-- Dreams Only Export/Import -->
                            <div class="settings-row">
                                <div>
                                    <div class="settings-label">Dreams Export/Import</div>
                                    <div class="settings-description">Export or import your dreams as text files</div>
                                </div>
                                <div class="settings-controls export-import-controls">
                                    <button data-action="export-dreams" class="btn btn-secondary">Export Dreams</button>
                                    <button data-action="import-dreams" class="btn btn-secondary">Import Dreams</button>
                                    <div class="encryption-option flex-center gap-sm">
                                        <input type="checkbox" id="encryptionEnabled" class="form-checkbox">
                                        <label for="encryptionEnabled" class="form-label-inline text-primary">🔐 Password Protected</label>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Complete Data Export/Import -->
                            <div class="settings-row">
                                <div>
                                    <div class="settings-label">Complete Data Export/Import</div>
                                    <div class="settings-description">Export or import ALL data (dreams, goals, settings) as JSON files</div>
                                </div>
                                <div class="settings-controls export-import-controls">
                                    <button data-action="export-all-data" class="btn btn-primary">Export All Data</button>
                                    <button data-action="import-all-data" class="btn btn-primary">Import All Data</button>
                                    <div class="encryption-option flex-center gap-sm">
                                        <input type="checkbox" id="fullDataEncryption" class="form-checkbox">
                                        <label for="fullDataEncryption" class="form-label-inline text-primary">🔐 Password Protected</label>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- AI Analysis Export -->
                            <div class="settings-row">
                                <div>
                                    <div class="settings-label">AI Analysis Export</div>
                                    <div class="settings-description">Export a prompt for analysis by an AI model</div>
                                </div>
                                <div class="settings-controls">
                                    <button data-action="export-ai" class="btn btn-success">Export for AI Analysis</button>
                                </div>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>🏷️ Autocomplete Management</h3>
                            <p class="settings-description" style="margin-bottom: 20px;">Manage the suggestions that appear when you type tags and dream signs. Add your own items, or delete any you don't use.</p>
                            
                            <div class="settings-row">
                                <div>
                                    <div class="settings-label">Tags & Themes</div>
                                    <div class="settings-description">Add a new custom tag or theme.</div>
                                </div>
                                <div style="flex: 1; min-width: 300px;">
                                    <div id="tagsManagementList" class="autocomplete-management-list">
                                        <div class="loading-state">Loading tags...</div>
                                    </div>
                                    <div class="form-group mt-sm" style="display: flex; justify-content: flex-end;">
                                        <div class="flex-center gap-sm" style="width: 100%; max-width: 300px;">
                                            <input type="text" id="newTagInput" class="form-control" placeholder="e.g., recurring-nightmare">
                                            <button data-action="add-custom-tag" class="btn btn-primary btn-small">Add</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="settings-row">
                                <div>
                                    <div class="settings-label">⚡ Dream Signs</div>
                                    <div class="settings-description">Add a new custom dream sign.</div>
                                </div>
                                <div style="flex: 1; min-width: 300px;">
                                    <div id="dreamSignsManagementList" class="autocomplete-management-list">
                                        <div class="loading-state">Loading dream signs...</div>
                                    </div>
                                    <div class="form-group mt-sm" style="display: flex; justify-content: flex-end;">
                                        <div class="flex-center gap-sm" style="width: 100%; max-width: 300px;">
                                            <input type="text" id="newDreamSignInput" class="form-control" placeholder="e.g., extra-fingers">
                                            <button data-action="add-custom-dream-sign" class="btn btn-primary btn-small">Add</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (tabId === 'lockTab') {
                    // Check if there's an active timer to show instructional text
                    const resetTime = getResetTime();
                    let timerInstructions = '';
                    
                    if (resetTime) {
                        const remainingTime = resetTime - Date.now();
                        if (remainingTime > 0) {
                            const hours = Math.ceil(remainingTime / (1000 * 60 * 60));
                            const days = Math.ceil(hours / 24);
                            
                            let timeDisplay = '';
                            if (days > 1) {
                                timeDisplay = `${days} days`;
                            } else if (hours > 1) {
                                timeDisplay = `${hours} hours`;
                            } else {
                                timeDisplay = 'Less than 1 hour';
                            }
                            
                            timerInstructions = `
                                <div class="message-base message-info mb-md text-sm">
                                    ⏰ Recovery timer active (${timeDisplay} remaining)<br>
                                    <span class="text-sm font-normal">Press "Forgot PIN?" again when timer expires to unlock</span>
                                </div>
                            `;
                        }
                    }
                    
                    tabPanel.innerHTML = `
                        <div class="flex-center" style="min-height: 400px;">
                            <div class="card-elevated card-lg text-center max-w-sm w-full shadow-lg">
                                <div class="text-4xl mb-lg">🔒</div>
                                <h2 class="text-primary mb-md text-xl">Journal Locked</h2>
                                <p class="text-secondary mb-lg line-height-relaxed">
                                    Your dream journal is protected with a PIN. Enter your PIN to access your dreams and all app features.
                                </p>
                                ${timerInstructions}
                                <input type="password" id="lockScreenPinInput" placeholder="Enter PIN" maxlength="6" class="input-pin w-full mb-lg">
                                <div class="flex-center gap-sm flex-wrap">
                                    <button data-action="verify-lock-screen-pin" class="btn btn-primary">🔓 Unlock Journal</button>
                                    <button data-action="show-lock-screen-forgot-pin" class="btn btn-secondary">Forgot PIN?</button>
                                </div>
                                <div id="lockScreenFeedback" class="mt-md p-sm feedback-container"></div>
                            </div>
                        </div>
                    `;
                }
                
                tabContainer.appendChild(tabPanel);
            }
        });
        
        // Update tab panels
        const tabs = document.querySelectorAll('.tab-panel');
        
        tabs.forEach(tab => {
            const expectedId = tabName + 'Tab';
            if (tab.id === expectedId) {
                tab.classList.add('active');
            } else {
                tab.classList.remove('active');
            }
        });
        
        // Update tab buttons
        const tabButtons = document.querySelectorAll('.app-tab');
        tabButtons.forEach(button => {
            const buttonTab = button.dataset.tab;
            if (buttonTab === tabName) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
        });
        
        // Show/hide footer based on active tab
        const footer = document.querySelector('footer');
        if (footer) {
            if (tabName === 'journal' && !isAppLocked) {
                footer.style.display = 'block';
            } else {
                footer.style.display = 'none';
            }
        }
        
        activeAppTab = tabName;
        
        // Auto-focus PIN input on lock screen
        if (tabName === 'lock') {
            setTimeout(() => {
                const lockScreenPinInput = document.getElementById('lockScreenPinInput');
                if (lockScreenPinInput) {
                    lockScreenPinInput.focus();
                }
            }, CONSTANTS.FOCUS_DELAY_MS);
        }
        
        // Update security controls when switching to journal tab (for consistency)
        if (tabName === 'journal') {
            updateSecurityControls();
        }
        
        // Initialize calendar if stats tab is selected
        if (tabName === 'stats') {
            initCalendar();
        }
        
        // Display goals if goals tab is selected
        if (tabName === 'goals') {
            // Refresh goals from storage when switching to goals tab
            // This ensures we always have the latest data
            initGoals().catch(error => {
                console.error('Error refreshing goals:', error);
                displayGoals(); // Fallback to just displaying current goals
            });
        }

        // ALWAYS update settings when switching to settings tab (whether new or existing)
        if (tabName === 'settings') {
            setTimeout(() => {
                updateSecurityControls();
                
                // Always update theme select - this fixes the tab switching issue
                const themeSelect = document.getElementById('themeSelect');
                if (themeSelect) {
                    const currentTheme = getCurrentTheme();
                    
                    // Update the select value
                    themeSelect.value = currentTheme;
                    
                    // Also update the selected attribute in the DOM
                    themeSelect.querySelectorAll('option').forEach(option => {
                        if (option.value === currentTheme) {
                            option.selected = true;
                            option.setAttribute('selected', 'selected');
                        } else {
                            option.selected = false;
                            option.removeAttribute('selected');
                        }
                    });
                    
                    // Add event listener if not already added
                    if (!themeSelect.hasAttribute('data-listener-added')) {
                        themeSelect.addEventListener('change', function() {
                            switchTheme(this.value);
                        });
                        themeSelect.setAttribute('data-listener-added', 'true');
                    }
                }

                // Render autocomplete management lists
                renderAutocompleteManagementList('tags');
                renderAutocompleteManagementList('dreamSigns');
            }, CONSTANTS.FOCUS_DELAY_MS);
        }

        // Initialize advice tab when switched to
        if (tabName === 'advice') {
            initializeAdviceTab();
        }
    }

    // Hide all tab buttons (when locked)
        function hideAllTabButtons() {
            const tabButtons = document.querySelectorAll('.app-tab');
            tabButtons.forEach(button => {
                if (button.dataset.tab !== 'lock') {
                    button.style.display = 'none';
                }
            });
            console.log('Hid all tab buttons except lock tab');
        }
        
        // Show all tab buttons (when unlocked)
        function showAllTabButtons() {
            const tabButtons = document.querySelectorAll('.app-tab');
            tabButtons.forEach(button => {
                if (button.dataset.tab !== 'lock') {
                    button.style.display = 'block';
                }
            });
            console.log('Showed all tab buttons');
        }


    // ===================================================================================
    // SECTION 4: DATABASE & STORAGE
    // ===================================================================================

    // Database Constants and Setup
    const DB_NAME = 'DreamJournal';
    const DB_VERSION = CONSTANTS.DB_VERSION; // Increment for voice notes support
    const STORE_NAME = 'dreams';
    const VOICE_STORE_NAME = 'voiceNotes';
    let db = null;
    let storageType = 'memory'; // Track which storage is being used

    // Database Initialization
    async function initDB() {
        return new Promise((resolve, reject) => {
            try {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => {
                    console.error('IndexedDB error:', request.error);
                    resolve(null); // Resolve with null to allow fallback
                };
                
                request.onsuccess = () => {
                    db = request.result;
                    storageType = 'indexeddb';
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const database = event.target.result;
                    const oldVersion = event.oldVersion;
                    
                    if (oldVersion < 1) {
                        // Initial database setup
                        const objectStore = database.createObjectStore(STORE_NAME, { keyPath: 'id' });
                        
                        // Create indexes for common queries
                        objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                        objectStore.createIndex('isLucid', 'isLucid', { unique: false });
                        objectStore.createIndex('title', 'title', { unique: false });
                    }
                    
                    if (oldVersion < 2) {
                        // Add voice notes store
                        const voiceStore = database.createObjectStore(VOICE_STORE_NAME, { keyPath: 'id' });
                        voiceStore.createIndex('timestamp', 'timestamp', { unique: false });
                    }
                    
                    if (oldVersion < 3) {
                        // Add goals store
                        const goalsStore = database.createObjectStore('goals', { keyPath: 'id' });
                        goalsStore.createIndex('createdAt', 'createdAt', { unique: false });
                        goalsStore.createIndex('status', 'status', { unique: false });
                        goalsStore.createIndex('type', 'type', { unique: false });
                    }
                    
                    if (oldVersion < 4) {
                        // Add user-defined tags and dream signs stores
                        database.createObjectStore('userTags', { keyPath: 'id' });
                        database.createObjectStore('userDreamSigns', { keyPath: 'id' });
                        database.createObjectStore('deletedDefaults', { keyPath: 'id' });
                    }

                    if (oldVersion < 5) {
                        // Create a new unified store for autocomplete items and migrate data
                        const autocompleteStore = database.createObjectStore('autocomplete', { keyPath: 'id' });
                        const transaction = event.target.transaction;

                        const getAllFromStore = (storeName) => {
                            return new Promise((resolve, reject) => {
                                if (!database.objectStoreNames.contains(storeName)) {
                                    resolve([]);
                                    return;
                                }
                                try {
                                    const store = transaction.objectStore(storeName);
                                    const request = store.getAll();
                                    request.onsuccess = () => resolve(request.result || []);
                                    request.onerror = () => {
                                        console.error(`Error getting all from ${storeName}:`, request.error);
                                        reject(request.error);
                                    };
                                } catch (error) {
                                    console.error(`Error accessing store ${storeName}:`, error);
                                    // If store is somehow gone, resolve with empty to not block migration
                                    resolve([]);
                                }
                            });
                        };

                        Promise.all([
                            getAllFromStore('userTags'),
                            getAllFromStore('userDreamSigns'),
                            getAllFromStore('deletedDefaults')
                        ]).then(([userTags, userDreamSigns, deletedDefaults]) => {
                            const deletedSet = new Set((deletedDefaults || []).map(item => item.id));

                            // Process Tags
                            const tagsMap = new Map();
                            commonTags.forEach(tag => tagsMap.set(tag.toLowerCase(), tag));
                            (userTags || []).forEach(tag => tagsMap.set(tag.id, tag.value));
                            const finalTags = Array.from(tagsMap.values()).filter(tag => !deletedSet.has(tag.toLowerCase()));

                            // Process Dream Signs
                            const signsMap = new Map();
                            commonDreamSigns.forEach(sign => signsMap.set(sign.toLowerCase(), sign));
                            (userDreamSigns || []).forEach(sign => signsMap.set(sign.id, sign.value));
                            const finalDreamSigns = Array.from(signsMap.values()).filter(sign => !deletedSet.has(sign.toLowerCase()));

                            // Save to new store
                            autocompleteStore.put({ id: 'tags', items: finalTags });
                            autocompleteStore.put({ id: 'dreamSigns', items: finalDreamSigns });

                            // Set a flag in localStorage to indicate migration is complete
                            try {
                                localStorage.setItem('autocompleteMigrationV5Done', 'true');
                            } catch(e) {
                                console.warn("Could not set autocomplete migration flag in localStorage.");
                            }

                        }).catch(err => {
                            console.error("Autocomplete migration failed:", err);
                        });
                    }
                    
                    // Future migrations can be added here
                    if (oldVersion < 6) {
                        // TODO: In a future version (e.g., v6+), remove the old stores after giving users time to migrate.
                        // This prevents breaking the app for users who open an old version and then a new one.
                        // if (database.objectStoreNames.contains('userTags')) {
                        //     database.deleteObjectStore('userTags');
                        // }
                        // if (database.objectStoreNames.contains('userDreamSigns')) {
                        //     database.deleteObjectStore('userDreamSigns');
                        // }
                        // if (database.objectStoreNames.contains('deletedDefaults')) {
                        //     database.deleteObjectStore('deletedDefaults');
                        // }
                    }
                };
            } catch (error) {
                console.error('Failed to open IndexedDB:', error);
                resolve(null);
            }
        });
    }

    // Storage Utilities
    function generateUniqueId() {
        return `${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
    }

    // Check if localStorage is available
    function isLocalStorageAvailable() {
        try {
            const test = '__localStorage_test__';
            localStorage.setItem(test, test);
            localStorage.removeItem(test);
            return true;
        } catch (e) {
            return false;
        }
    }

    // Check if IndexedDB is available and working
    function isIndexedDBAvailable() {
        return db !== null;
    }

    // Main Data Loading and Saving Functions
    
    // Load dreams with fallback chain: IndexedDB -> localStorage -> memory
    async function loadDreams() {
        // Try IndexedDB first
        if (isIndexedDBAvailable()) {
            const indexedDBDreams = await loadFromIndexedDB();
            if (indexedDBDreams !== null && Array.isArray(indexedDBDreams)) {
                storageType = 'indexeddb';
                return indexedDBDreams;
            }
        }
        
        // Fallback to localStorage
        if (isLocalStorageAvailable()) {
            try {
                const dreams = localStorage.getItem('dreamJournalEntries');
                if (dreams) {
                    const parsedDreams = JSON.parse(dreams);
                    if (Array.isArray(parsedDreams)) {
                        storageType = 'localstorage';
                        return parsedDreams;
                    }
                }
            } catch (error) {
                console.error('Failed to load from localStorage:', error);
            }
        }
        
        // Final fallback to memory
        storageType = 'memory';
        return Array.isArray(memoryStorage) ? memoryStorage : [];
    }

    // Save dreams with fallback chain: IndexedDB -> localStorage -> memory (with mutex protection)
    async function saveDreams(dreams) {
        return withMutex('saveDreams', async () => {
            // Try IndexedDB first
            if (isIndexedDBAvailable()) {
                const saved = await saveToIndexedDB(dreams);
                if (saved) {
                    storageType = 'indexeddb';
                    // localStorage backup is automatically updated by saveToIndexedDB
                    return;
                }
            }
            
            // Fallback to localStorage
            if (isLocalStorageAvailable()) {
                try {
                    localStorage.setItem('dreamJournalEntries', JSON.stringify(dreams));
                    storageType = 'localstorage';
                    return;
                } catch (error) {
                    console.error('Failed to save to localStorage:', error);
                }
            }
            
            // Final fallback to memory
            memoryStorage = dreams;
            storageType = 'memory';
            
            // Show warning about data persistence if using memory only
            if (!document.getElementById('storageWarning')) {
                showStorageWarning();
            }
        });
    }

    // Goals Data Storage Functions
    
    // Load goals from storage
    async function loadGoals() {
        // Try IndexedDB first
        if (isIndexedDBAvailable() && db) {
            const goals = await loadGoalsFromIndexedDB();
            if (goals) return goals;
        }
        
        // Fallback to localStorage
        if (isLocalStorageAvailable()) {
            try {
                const stored = localStorage.getItem('dreamJournalGoals');
                return stored ? JSON.parse(stored) : [];
            } catch (error) {
                console.error('Error loading goals from localStorage:', error);
            }
        }
        
        return [];
    }
    
    // Save goals to storage
    async function saveGoals(goals) {
        return withMutex('saveGoals', async () => {
            console.log('saveGoals called with', goals.length, 'goals');

            try {
                // Try IndexedDB first
                if (isIndexedDBAvailable() && db) {
                    console.log('Attempting to save to IndexedDB');
                    const saved = await saveGoalsToIndexedDB(goals);
                    if (saved) {
                        console.log('Successfully saved to IndexedDB');
                        // Also backup to localStorage
                        if (isLocalStorageAvailable()) {
                            try {
                                localStorage.setItem('dreamJournalGoals', JSON.stringify(goals));
                                console.log('Backup saved to localStorage');
                            } catch (error) {
                                console.warn('Could not backup goals to localStorage:', error);
                            }
                        }
                        return;
                    } else {
                        console.warn('IndexedDB save failed, falling back to localStorage');
                    }
                }
                
                // Fallback to localStorage only
                if (isLocalStorageAvailable()) {
                    console.log('Saving to localStorage only');
                    try {
                        localStorage.setItem('dreamJournalGoals', JSON.stringify(goals));
                        console.log('Successfully saved to localStorage');
                        return;
                    } catch (error) {
                        console.error('Failed to save goals to localStorage:', error);
                        throw error;
                    }
                } else {
                    console.error('No storage available for goals');
                    throw new Error('No storage available for goals');
                }
            } catch (error) {
                console.error('Error in saveGoals:', error);
                throw error;
            }
        });
    }

    // IndexedDB-specific functions
    
    // Load from IndexedDB
    async function loadFromIndexedDB() {
        if (!isIndexedDBAvailable()) return null;
        
        return new Promise((resolve) => {
            try {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                
                request.onsuccess = () => {
                    const dreams = request.result || [];
                    resolve(dreams);
                };
                
                request.onerror = () => {
                    console.error('Error loading from IndexedDB:', request.error);
                    resolve(null);
                };
            } catch (error) {
                console.error('IndexedDB load error:', error);
                resolve(null);
            }
        });
    }

    // Save to IndexedDB
    async function saveToIndexedDB(dreams) {
        if (!isIndexedDBAvailable()) return false;
        
        return new Promise((resolve) => {
            try {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                
                // Clear and repopulate store for bulk save
                store.clear();
                
                transaction.onerror = () => {
                    console.error('IndexedDB transaction error:', transaction.error);
                    resolve(false);
                };
                
                transaction.oncomplete = async () => {
                    // Update localStorage backup after successful IndexedDB operation
                    if (isLocalStorageAvailable()) {
                        try {
                            localStorage.setItem('dreamJournalEntries', JSON.stringify(dreams));
                        } catch (error) {
                            console.warn('Could not update localStorage backup:', error);
                        }
                    }
                    resolve(true);
                };
                
                // Use put() which updates existing or adds new records
                for (const dream of dreams) {
                    store.put(dream);
                }
            } catch (error) {
                console.error('Error creating bulk save transaction:', error);
                resolve(false);
            }
        });
    }

    // Load goals from IndexedDB
    async function loadGoalsFromIndexedDB() {
        return new Promise((resolve) => {
            try {
                const transaction = db.transaction(['goals'], 'readonly');
                const store = transaction.objectStore('goals');
                const request = store.getAll();
                
                request.onsuccess = () => {
                    const goals = request.result || [];
                    resolve(goals);
                };
                
                request.onerror = () => {
                    console.error('Error loading goals from IndexedDB:', request.error);
                    resolve(null);
                };
            } catch (error) {
                console.error('IndexedDB goals load error:', error);
                resolve(null);
            }
        });
    }
    
    // Save goals to IndexedDB
    async function saveGoalsToIndexedDB(goals) {
        return new Promise((resolve) => {
            try {
                console.log('Starting IndexedDB transaction for goals');
                const transaction = db.transaction(['goals'], 'readwrite');
                const store = transaction.objectStore('goals');
                
                // Clear existing goals
                const clearRequest = store.clear();
                
                clearRequest.onsuccess = () => {
                    console.log('Cleared existing goals from IndexedDB');
                    
                    // Add all goals
                    goals.forEach(goal => {
                        store.add(goal);
                    });
                };
                
                clearRequest.onerror = () => {
                    console.error('Error clearing goals from IndexedDB:', clearRequest.error);
                    resolve(false);
                };
                
                transaction.oncomplete = () => {
                    console.log('Goals transaction completed successfully');
                    resolve(true);
                };
                
                transaction.onerror = () => {
                    console.error('Goals transaction failed:', transaction.error);
                    resolve(false);
                };
                
                transaction.onabort = () => {
                    console.error('Goals transaction aborted');
                    resolve(false);
                };
                
            } catch (error) {
                console.error('Error in saveGoalsToIndexedDB:', error);
                resolve(false);
            }
        });
    }

    // Storage warning display
    function showStorageWarning() {
        const warningDiv = document.createElement('div');
        warningDiv.id = 'storageWarning';
        warningDiv.className = 'storage-warning';
        warningDiv.innerHTML = `
            <div class="warning-content">
                <p><strong>⚠️ Storage Warning</strong></p>
                <p>Your browser doesn't support persistent storage. Dreams are only stored in memory and will be lost when you close the tab.</p>
                <button onclick="this.parentElement.parentElement.remove()">Dismiss</button>
            </div>
        `;
        document.body.appendChild(warningDiv);
    }

    // Voice Notes Storage Functions
    
    // Load voice notes
    async function loadVoiceNotes() {
        if (isIndexedDBAvailable()) {
            const notes = await loadVoiceNotesFromIndexedDB();
            if (notes !== null) return notes;
        }
        
        // Fallback to localStorage
        if (isLocalStorageAvailable()) {
            try {
                const stored = localStorage.getItem('dreamJournalVoiceNotes');
                return stored ? JSON.parse(stored) : [];
            } catch (error) {
                console.error('Error loading voice notes from localStorage:', error);
            }
        }
        
        return [];
    }

    // Save voice note
    async function saveVoiceNote(voiceNote) {
        return withMutex('saveVoiceNote', async () => {
            // Try IndexedDB first
            if (isIndexedDBAvailable()) {
                const saved = await saveVoiceNoteToIndexedDB(voiceNote);
                if (saved) return;
            }
            
            // Fallback to localStorage
            if (isLocalStorageAvailable()) {
                try {
                    const existingNotes = await loadVoiceNotes();
                    const updatedNotes = [...existingNotes, voiceNote];
                    localStorage.setItem('dreamJournalVoiceNotes', JSON.stringify(updatedNotes));
                } catch (error) {
                    console.error('Failed to save voice note to localStorage:', error);
                }
            }
        });
    }

    // Load voice notes from IndexedDB
    async function loadVoiceNotesFromIndexedDB() {
        if (!isIndexedDBAvailable()) return null;
        
        return new Promise((resolve) => {
            try {
                const transaction = db.transaction([VOICE_STORE_NAME], 'readonly');
                const store = transaction.objectStore(VOICE_STORE_NAME);
                const request = store.getAll();
                
                request.onsuccess = () => {
                    const notes = request.result || [];
                    resolve(notes);
                };
                
                request.onerror = () => {
                    console.error('Error loading voice notes from IndexedDB:', request.error);
                    resolve(null);
                };
            } catch (error) {
                console.error('Voice notes IndexedDB load error:', error);
                resolve(null);
            }
        });
    }

    // Save voice note to IndexedDB
    async function saveVoiceNoteToIndexedDB(voiceNote) {
        if (!isIndexedDBAvailable()) return false;
        
        return new Promise((resolve) => {
            try {
                const transaction = db.transaction([VOICE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(VOICE_STORE_NAME);
                
                const request = store.put(voiceNote);
                
                request.onsuccess = () => {
                    resolve(true);
                };
                
                request.onerror = () => {
                    console.error('Error saving voice note to IndexedDB:', request.error);
                    resolve(false);
                };
            } catch (error) {
                console.error('Voice note IndexedDB save error:', error);
                resolve(false);
            }
        });
    }

    // Delete voice note
    function deleteVoiceNote(voiceNoteId) {
        return withMutex('deleteVoiceNote', async () => {
            // Try IndexedDB first
            if (isIndexedDBAvailable()) {
                const deleted = await deleteVoiceNoteFromIndexedDB(voiceNoteId);
                if (deleted) return;
            }
            
            // Fallback to localStorage
            if (isLocalStorageAvailable()) {
                try {
                    const existingNotes = await loadVoiceNotes();
                    const updatedNotes = existingNotes.filter(note => note.id !== voiceNoteId);
                    localStorage.setItem('dreamJournalVoiceNotes', JSON.stringify(updatedNotes));
                } catch (error) {
                    console.error('Failed to delete voice note from localStorage:', error);
                }
            }
        });
    }

    // Delete voice note from IndexedDB
    async function deleteVoiceNoteFromIndexedDB(voiceNoteId) {
        if (!isIndexedDBAvailable()) return false;
        
        return new Promise((resolve) => {
            try {
                const transaction = db.transaction([VOICE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(VOICE_STORE_NAME);
                
                const request = store.delete(voiceNoteId);
                
                request.onsuccess = () => {
                    resolve(true);
                };
                
                request.onerror = () => {
                    console.error('Error deleting voice note from IndexedDB:', request.error);
                    resolve(false);
                };
            } catch (error) {
                console.error('Voice note IndexedDB delete error:', error);
                resolve(false);
            }
        });
    }


    // ===================================================================================
    // SECTION 5: CORE LOGIC (Subdivided by Feature)
    // ===================================================================================

    // --- 5.1 Dream CRUD ---
    // --- All functions related to creating, reading, updating, and deleting dreams --- //

    // Save a new dream entry - optimized to use individual operations
    // MOVED FROM: Main functions area - Dream creation and editing // Also affects UI (SECTION 3), database (SECTION 4)
    async function saveDream() {
        const titleElement = document.getElementById('dreamTitle');
        const contentElement = document.getElementById('dreamContent');
        const dreamDateElement = document.getElementById('dreamDate');
        const isLucidElement = document.getElementById('isLucid');
        const emotionsElement = document.getElementById('dreamEmotions');
        const tagsElement = document.getElementById('dreamTags');
        const dreamSignsElement = document.getElementById('dreamSigns');
        
        // Safety checks for form elements
        if (!titleElement || !contentElement || !dreamDateElement || !isLucidElement || !emotionsElement || !tagsElement || !dreamSignsElement) {
            return;
        }
        
        const title = titleElement.value.trim();
        const content = contentElement.value.trim();
        const dreamDate = dreamDateElement.value;
        const isLucid = isLucidElement.checked;
        const emotions = emotionsElement.value.trim();
        const tags = parseTagsFromInput(tagsElement.value);
        const dreamSigns = parseTagsFromInput(dreamSignsElement.value);

        // Learn new tags and dream signs from user input
        await learnAutocompleteItems(tags, 'tags');
        await learnAutocompleteItems(dreamSigns, 'dreamSigns');
        
        if (!content) {
            // Show error message inline instead of alert
            contentElement.style.borderColor = 'var(--error-color)';
            const errorMsg = document.createElement('div');
            errorMsg.className = 'message-error text-sm mt-sm';
            errorMsg.textContent = 'Please enter a dream description before saving.';
            contentElement.parentElement.appendChild(errorMsg);
            
            setTimeout(() => {
                try {
                    if (contentElement) {
                        contentElement.style.borderColor = 'var(--border-color)';
                    }
                    if (errorMsg && errorMsg.parentNode) {
                        errorMsg.remove();
                    }
                } catch (e) {
                    // Ignore cleanup errors
                }
            }, 3000);
            return;
        }
        
        // Use custom date if provided, otherwise current time
        let timestamp, dateForDisplay;
        
        if (dreamDate) {
            try {
                dateForDisplay = new Date(dreamDate);
                if (isNaN(dateForDisplay.getTime())) {
                    // Invalid date, fallback to current time
                    dateForDisplay = new Date();
                }
                timestamp = dateForDisplay.toISOString();
            } catch (error) {
                // Error parsing date, fallback to current time
                dateForDisplay = new Date();
                timestamp = dateForDisplay.toISOString();
            }
        } else {
            dateForDisplay = new Date();
            timestamp = dateForDisplay.toISOString();
        }
        
        const newDream = {
            id: generateUniqueId(),
            title: title || 'Untitled Dream',
            content: content,
            emotions: emotions, // Add emotions to the dream data
            tags: tags, // Add tags array
            dreamSigns: dreamSigns, // Add dream signs array
            timestamp: timestamp,
            isLucid: isLucid,
            dateString: dateForDisplay.toLocaleDateString('en-AU', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            })
        };
        
        // Try to add directly to IndexedDB first for better performance
        let saveSuccess = false;
        if (isIndexedDBAvailable()) {
            saveSuccess = await addDreamToIndexedDB(newDream);
        }
        
        // If IndexedDB failed or unavailable, fall back to loading all and saving
        if (!saveSuccess) {
            const dreams = await loadDreams();
            dreams.unshift(newDream);
            await saveDreams(dreams);
        }
        
        // Clear form
        if (titleElement) titleElement.value = '';
        if (contentElement) contentElement.value = '';
        if (dreamDateElement) dreamDateElement.value = '';
        if (isLucidElement) isLucidElement.checked = false;
        if (emotionsElement) emotionsElement.value = '';
        if (tagsElement) tagsElement.value = '';
        if (dreamSignsElement) dreamSignsElement.value = '';
        
        // Reset date to current time for next entry
        if (dreamDateElement) {
        const now = new Date();

        const year = now.getFullYear();
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');

        const localDatetimeString = `${year}-${month}-${day}T${hours}:${minutes}`;

        dreamDateElement.value = localDatetimeString;
    }
        
        // Reset to page 1 to show the new dream
        currentPage = 1;
        
        // Show success message
        const form = document.querySelector('.entry-form');
        if (form) {
            createInlineMessage('success', 'Dream saved successfully!', {
                container: form,
                position: 'bottom',
                duration: CONSTANTS.MESSAGE_DURATION_SHORT
            });
        }
        
        // Refresh display
        await displayDreams();
        await initializeAutocomplete();
    }

    // Display dreams in the container with pagination (Refactored and Optimized)
    // MOVED FROM: Main functions area - Dream display management // Also affects UI (SECTION 3)
    async function displayDreams() {
        return withMutex('displayDreams', displayDreamsInternal);
    }
    
    // Internal display dreams function (called with mutex protection)
    async function displayDreamsInternal() {
        try {
            // Note: PIN protection is now handled by lock screen tab
            // No need to check isUnlocked here since locked users can't access this tab
            
            // Get filter values
            const { searchTerm, filterType, sortType, limitValue, startDate, endDate } = getFilterValues();
            const dreams = await loadDreams();
            const container = document.getElementById('entriesContainer');
            
            if (!container) return;
            
            // Show loading for large datasets
            if (Array.isArray(dreams) && dreams.length > CONSTANTS.LARGE_DATASET_THRESHOLD) {
                showLoadingMessage(container, dreams.length);
                await new Promise(resolve => setTimeout(resolve, 0)); // Give UI a chance to update
            }
            
            // Filter and sort dreams
            let filteredDreams = filterDreams(dreams, searchTerm, filterType, startDate, endDate);
            filteredDreams = sortDreams(filteredDreams, sortType);
            
            // Handle no results
            if (filteredDreams.length === 0) {
                showNoResultsMessage(container, filterType, searchTerm);
                clearPagination();
                return;
            }
            
            // Calculate pagination
            const { paginatedDreams, totalPages, totalDreams } = calculatePagination(filteredDreams, limitValue);
            
            // Render dreams
            container.innerHTML = paginatedDreams.map(renderDreamHTML).filter(html => html).join('');
            
            // Render pagination
            renderPaginationHTML(limitValue, totalPages, totalDreams, paginatedDreams);
            
        } finally {
            hideSearchLoading();
        }
    }

    // Edit a dream entry (Updated for Event Delegation)
    // MOVED FROM: Main functions area - Dream editing functionality
    async function editDream(dreamId) {
        try {
            const dreams = await loadDreams();
            // Handle both string and numeric IDs for backward compatibility
            const dream = dreams.find(d => d.id === dreamId || d.id === dreamId.toString() || d.id === Number(dreamId));
            if (!dream) {
                console.error('Dream not found for ID:', dreamId);
                return;
            }
            
            const entryElement = document.getElementById(`entry-${dreamId}`);
            if (!entryElement) {
                console.error('Required DOM elements not found for dream:', dreamId);
                return;
            }
            
            // Convert stored timestamp back to datetime-local format
            let datetimeLocalValue = '';
            try {
                const dreamDateTime = new Date(dream.timestamp);
                let dateToFormat;
                if (!isNaN(dreamDateTime.getTime())) {
                    dateToFormat = dreamDateTime;
                } else {
                    dateToFormat = new Date(); // Fallback to now
                }
                const year = dateToFormat.getFullYear();
                const month = (dateToFormat.getMonth() + 1).toString().padStart(2, '0');
                const day = dateToFormat.getDate().toString().padStart(2, '0');
                const hours = dateToFormat.getHours().toString().padStart(2, '0');
                const minutes = dateToFormat.getMinutes().toString().padStart(2, '0');
                datetimeLocalValue = `${year}-${month}-${day}T${hours}:${minutes}`;
            } catch (error) {
                // If timestamp is invalid, use current time
                const now = new Date();
                const year = now.getFullYear();
                const month = (now.getMonth() + 1).toString().padStart(2, '0');
                const day = now.getDate().toString().padStart(2, '0');
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                datetimeLocalValue = `${year}-${month}-${day}T${hours}:${minutes}`;
            }
            
            // Add a new class for the edit mode and clear existing content
            entryElement.classList.add('entry-form', 'dream-entry-edit-mode');
            entryElement.innerHTML = ''; // Clear the element
            
            const safeDreamId = escapeAttr(dreamId.toString());
            const safeTitle = escapeAttr(dream.title || '');
            const safeEmotions = escapeAttr(dream.emotions || '');
            const safeTags = Array.isArray(dream.tags) ? escapeAttr(dream.tags.join(', ')) : '';
            const safeDreamSigns = Array.isArray(dream.dreamSigns) ? escapeAttr(dream.dreamSigns.join(', ')) : '';
            const safeContent = escapeAttr(dream.content || '');

            entryElement.innerHTML = `
                <div class="form-group">
                    <label for="edit-title-${safeDreamId}">Dream Title</label>
                    <input type="text" class="form-control" id="edit-title-${safeDreamId}" value="${safeTitle}">
                </div>
                <div class="form-group">
                    <label for="edit-date-${safeDreamId}">Dream Date & Time</label>
                    <input type="datetime-local" class="form-control" value="${datetimeLocalValue}" id="edit-date-${safeDreamId}">
                </div>
                <div class="form-group">
                    <label for="edit-emotions-${safeDreamId}">Emotions Experienced</label>
                    <input type="text" class="form-control" id="edit-emotions-${safeDreamId}" placeholder="e.g., happy, anxious, excited, confused" value="${safeEmotions}">
                </div>
                <div class="form-group">
                    <label for="edit-tags-${safeDreamId}">Tags & Themes</label>
                    <input type="text" class="form-control" id="edit-tags-${safeDreamId}" placeholder="e.g., family, flying, school, animals" value="${safeTags}">
                </div>
                <div class="form-group">
                    <label for="edit-dreamsigns-${safeDreamId}">⚡ Dream Signs</label>
                    <input type="text" class="form-control" id="edit-dreamsigns-${safeDreamId}" placeholder="e.g., flying, text-changing, deceased-alive" value="${safeDreamSigns}">
                </div>
                <div class="lucid-checkbox">
                    <input type="checkbox" id="edit-lucid-${safeDreamId}" ${dream.isLucid ? 'checked' : ''}>
                    <label for="edit-lucid-${safeDreamId}">This was a lucid dream ✨</label>
                </div>
                <div class="form-group">
                    <label for="edit-content-${safeDreamId}">Dream Description</label>
                    <textarea class="form-control" id="edit-content-${safeDreamId}">${safeContent}</textarea>
                </div>
                <div class="edit-actions" style="margin-top: 15px; display: flex; gap: 10px;">
                    <button data-action="save-edit" data-dream-id="${safeDreamId}" class="btn btn-primary btn-small">Save Changes</button>
                    <button data-action="cancel-edit" data-dream-id="${safeDreamId}" class="btn btn-secondary btn-small">Cancel</button>
                </div>
            `;
            
            // Focus on the title input after DOM is updated
            setTimeout(() => {
                const titleInputElement = document.getElementById(`edit-title-${safeDreamId}`);
                if (titleInputElement) {
                    titleInputElement.focus();
                }
            }, CONSTANTS.FOCUS_DELAY_MS);
            
        } catch (error) {
            console.error('Error editing dream:', error);
            
            createInlineMessage('error', 'Error editing dream. Please try again.', {
                container: document.querySelector('.main-content'),
                position: 'top',
                duration: 3000
            });
        }
    }

    // Save dream edit - optimized to use individual update
    async function saveDreamEdit(dreamId) {
        try {
            const newTitleElement = document.getElementById(`edit-title-${dreamId}`);
            const newContentElement = document.getElementById(`edit-content-${dreamId}`);
            const newDateElement = document.getElementById(`edit-date-${dreamId}`);
            const newIsLucidElement = document.getElementById(`edit-lucid-${dreamId}`);
            const newEmotionsElement = document.getElementById(`edit-emotions-${dreamId}`);
            const newTagsElement = document.getElementById(`edit-tags-${dreamId}`);
            const newDreamSignsElement = document.getElementById(`edit-dreamsigns-${dreamId}`);
            
            if (!newTitleElement || !newContentElement || !newDateElement || !newIsLucidElement || 
                !newEmotionsElement || !newTagsElement || !newDreamSignsElement) {
                throw new Error('Required form elements not found');
            }
            
            const newTitle = newTitleElement.value.trim();
            const newContent = newContentElement.value.trim();
            const newDate = newDateElement.value;
            const newIsLucid = newIsLucidElement.checked;
            const newEmotions = newEmotionsElement.value.trim();
            const newTags = parseTagsFromInput(newTagsElement.value);
            const newDreamSigns = parseTagsFromInput(newDreamSignsElement.value);

            // Learn new tags and dream signs from user input
            await learnAutocompleteItems(newTags, 'tags');
            await learnAutocompleteItems(newDreamSigns, 'dreamSigns');
            
            if (!newContent) {
                // Show error inline in the edit area
                const contentField = newContentElement;
                contentField.style.borderColor = 'var(--error-color)';
                const existingError = contentField.parentElement.querySelector('.edit-error');
                if (!existingError) {
                    const errorMsg = document.createElement('div');
                    errorMsg.className = 'edit-error message-error text-sm mt-sm';
                    errorMsg.textContent = 'Dream description cannot be empty.';
                    contentField.parentElement.appendChild(errorMsg);
                }
                
                setTimeout(() => {
                    contentField.style.borderColor = 'var(--border-color)';
                    const error = contentField.parentElement.querySelector('.edit-error');
                    if (error) error.remove();
                }, 3000);
                return;
            }
            
            const dreams = await loadDreams();
            // Handle both string and numeric IDs for backward compatibility
            const dreamIndex = dreams.findIndex(d => 
                d.id === dreamId || 
                d.id === dreamId.toString() || 
                d.id === Number(dreamId)
            );
            
            if (dreamIndex === -1) {
                throw new Error('Dream not found in database');
            }
            
            // Update timestamp and dateString if date was changed
            let timestamp, dateForDisplay;
            try {
                if (newDate) {
                    dateForDisplay = new Date(newDate);
                    if (isNaN(dateForDisplay.getTime())) {
                        dateForDisplay = new Date(dreams[dreamIndex].timestamp);
                    }
                    timestamp = dateForDisplay.toISOString();
                } else {
                    timestamp = dreams[dreamIndex].timestamp;
                    dateForDisplay = new Date(timestamp);
                }
            } catch (dateError) {
                console.warn('Error parsing date, using original:', dateError);
                timestamp = dreams[dreamIndex].timestamp;
                dateForDisplay = new Date(timestamp);
            }
            
            const updatedDream = {
                ...dreams[dreamIndex],
                title: newTitle || 'Untitled Dream',
                content: newContent,
                emotions: newEmotions,
                tags: newTags,
                dreamSigns: newDreamSigns,
                isLucid: newIsLucid,
                timestamp: timestamp,
                dateString: dateForDisplay.toLocaleDateString('en-AU', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                }),
                lastModified: new Date().toISOString()
            };
            
            // Try to update directly in IndexedDB first
            let updateSuccess = false;
            if (isIndexedDBAvailable()) {
                updateSuccess = await updateDreamInIndexedDB(updatedDream);
            }
            
            // If IndexedDB failed, fall back to updating all
            if (!updateSuccess) {
                dreams[dreamIndex] = updatedDream;
                await saveDreams(dreams);
            }
            
            await displayDreams();
            await initializeAutocomplete();
            
        } catch (error) {
            console.error('Error saving dream edit:', error);
            
            createInlineMessage('error', 'Error saving changes: ' + error.message, {
                container: document.querySelector('.main-content'),
                position: 'top',
                duration: 5000
            });
        }
    }

    // Cancel dream edit
    async function cancelDreamEdit(dreamId) {
        await displayDreams();
    }

    // Show delete confirmation button (Updated for Event Delegation)
    // MOVED FROM: Main functions area - Dream deletion initiation
    function deleteDream(dreamId) {
        // Clear any existing timeout for this dream
        if (deleteTimeouts[dreamId]) {
            clearTimeout(deleteTimeouts[dreamId]);
            delete deleteTimeouts[dreamId];
        }
        
        const entryElement = document.getElementById(`entry-${dreamId}`);
        if (!entryElement) return; // Safety check
        
        const actionsElement = entryElement.querySelector('.entry-actions');
        if (!actionsElement) return; // Safety check
        
        // Add pending delete styling
        entryElement.classList.add('delete-pending');
        
        // Replace delete button with confirm button
        const deleteBtn = actionsElement.querySelector(`button[data-dream-id="${dreamId}"][data-action="delete-dream"]`);
        if (deleteBtn) {
            deleteBtn.outerHTML = `<button data-action="confirm-delete" data-dream-id="${dreamId}" class="btn btn-confirm-delete btn-small">Confirm Delete</button>`;
        }
        
        // Set timeout to revert after specified time
        deleteTimeouts[dreamId] = setTimeout(() => {
            cancelDelete(dreamId);
        }, CONSTANTS.MESSAGE_DURATION_EXTENDED);
    }

    // Actually delete the dream after confirmation - optimized for IndexedDB (with mutex protection)
    async function confirmDelete(dreamId) {
        return withMutex('deleteOperations', async () => {
            try {
                // Clear the timeout
                if (deleteTimeouts[dreamId]) {
                    clearTimeout(deleteTimeouts[dreamId]);
                    delete deleteTimeouts[dreamId];
                }
                
                const dreams = await loadDreams();
                // Handle both string and numeric IDs for backward compatibility
                const dream = dreams.find(d => 
                    d.id === dreamId || 
                    d.id === dreamId.toString() || 
                    d.id === Number(dreamId)
                );
                
                if (!dream) {
                    // Show error inline
                    const entryElement = document.getElementById(`entry-${dreamId}`);
                    if (entryElement) {
                        const errorMsg = document.createElement('div');
                        errorMsg.style.cssText = `
                            background: #fee2e2;
                            color: #dc2626;
                            padding: 10px;
                            border-radius: 6px;
                            margin-top: 10px;
                            font-weight: 600;
                        `;
                        errorMsg.textContent = 'Error: Dream not found.';
                        entryElement.appendChild(errorMsg);
                        
                        setTimeout(() => {
                            errorMsg.remove();
                            cancelDelete(dreamId);
                        }, 3000);
                    }
                    return;
                }
                
                // Try to delete directly from IndexedDB first
                let deleteSuccess = false;
                if (isIndexedDBAvailable()) {
                    deleteSuccess = await deleteDreamFromIndexedDB(dream.id);
                }
                
                // If IndexedDB delete failed or unavailable, fall back to filtering
                if (!deleteSuccess) {
                    const filteredDreams = dreams.filter(d => d.id !== dream.id);
                    await saveDreams(filteredDreams);
                }
                
                // Reset to page 1 in case current page becomes empty
                currentPage = 1;
                await displayDreams();
            } catch (error) {
                createInlineMessage('error', 'Error deleting dream: ' + error.message, {
                    container: document.querySelector('.main-content'),
                    position: 'top',
                    duration: 5000
                });
            }
        });
    }

    // Cancel delete and revert to normal state (Updated for Event Delegation)
    function cancelDelete(dreamId) {
        // Clear the timeout
        if (deleteTimeouts[dreamId]) {
            clearTimeout(deleteTimeouts[dreamId]);
            delete deleteTimeouts[dreamId];
        }
        
        const entryElement = document.getElementById(`entry-${dreamId}`);
        if (entryElement) {
            const actionsElement = entryElement.querySelector('.entry-actions');
            
            // Remove pending delete styling
            entryElement.classList.remove('delete-pending');
            
            // Replace confirm button with original delete button
            const confirmBtn = actionsElement.querySelector(`button[data-dream-id="${dreamId}"][data-action="confirm-delete"]`);
            if (confirmBtn) {
                confirmBtn.outerHTML = `<button data-action="delete-dream" data-dream-id="${dreamId}" class="btn btn-delete btn-small">Delete</button>`;
            }
        }
    }

    // === HELPER FUNCTIONS FOR DREAM CRUD ===
    
    // Get current filter values from UI
    function getFilterValues() {
        const searchBox = document.getElementById('searchBox');
        const filterSelect = document.getElementById('filterSelect');
        const sortSelect = document.getElementById('sortSelect');
        const limitSelect = document.getElementById('limitSelect');
        const startDateInput = document.getElementById('startDateFilter');
        const endDateInput = document.getElementById('endDateFilter');
        
        return {
            searchTerm: (searchBox ? searchBox.value : '').toLowerCase(),
            filterType: filterSelect ? filterSelect.value : 'all',
            sortType: sortSelect ? sortSelect.value : 'newest',
            limitValue: limitSelect ? limitSelect.value : '10',
            startDate: startDateInput ? startDateInput.value : '',
            endDate: endDateInput ? endDateInput.value : ''
        };
    }
    
    // Helper function to show loading message
    function showLoadingMessage(container, dreamCount) {
        container.innerHTML = `
            <div class="loading-state large">
                <div>🌙</div>
                <div>Loading ${dreamCount} dreams...</div>
            </div>
        `;
    }
    
    // Helper function to show no results message
    function showNoResultsMessage(container, filterType, searchTerm) {
        const filterText = filterType === 'all' ? '' : 
            filterType === 'lucid' ? ' lucid' : ' non-lucid';
        
        let message;
        if (searchTerm) {
            message = `No${filterText} dreams found matching your search.`;
        } else if (filterType === 'lucid') {
            message = 'No lucid dreams recorded yet. Mark dreams as lucid when you achieve lucidity!';
        } else if (filterType === 'non-lucid') {
            message = 'No non-lucid dreams found.';
        } else {
            message = 'No dreams recorded yet. Start by adding your first dream above!';
        }
        
        container.innerHTML = `<div class="no-entries">${message}</div>`;
    }
    
    // Helper function to clear pagination
    function clearPagination() {
        const paginationContainer = document.getElementById('paginationContainer');
        if (paginationContainer) {
            paginationContainer.innerHTML = '';
        }
    }

    // Calculate pagination based on filter values and setup endless scroll if needed
    function calculatePagination(filteredDreams, limitValue) {
        if (!Array.isArray(filteredDreams)) {
            return { paginatedDreams: [], totalPages: 1, totalDreams: 0, itemsPerPage: 1 };
        }
        
        const totalDreams = Math.max(0, filteredDreams.length);
        let itemsPerPage, totalPages, paginatedDreams;
        
        try {
            if (limitValue === 'endless') {
                endlessScrollState.enabled = true;
                if (!endlessScrollState.loading) {
                    endlessScrollState.loaded = Math.max(CONSTANTS.ENDLESS_SCROLL_INCREMENT, endlessScrollState.loaded || CONSTANTS.ENDLESS_SCROLL_INCREMENT);
                    setupEndlessScroll();
                }
                const safeLoaded = Math.min(endlessScrollState.loaded, totalDreams);
                paginatedDreams = filteredDreams.slice(0, safeLoaded);
                totalPages = 1;
                itemsPerPage = safeLoaded;
            } else if (limitValue === 'all') {
                endlessScrollState.enabled = false;
                removeEndlessScroll();
                itemsPerPage = Math.max(1, totalDreams);
                totalPages = 1;
                currentPage = 1;
                paginatedDreams = filteredDreams;
            } else {
                endlessScrollState.enabled = false;
                removeEndlessScroll();
                itemsPerPage = Math.max(1, Math.min(parseInt(limitValue) || 10, 1000)); // Cap at 1000 for safety
                totalPages = Math.max(1, Math.ceil(totalDreams / itemsPerPage));
                
                // Validate and fix current page with safety bounds
                currentPage = Math.max(1, Math.min(currentPage, totalPages));
                
                const startIndex = Math.max(0, (currentPage - 1) * itemsPerPage);
                const endIndex = Math.min(startIndex + itemsPerPage, totalDreams);
                paginatedDreams = filteredDreams.slice(startIndex, endIndex);
            }
            
            return { paginatedDreams, totalPages, totalDreams, itemsPerPage };
        } catch (error) {
            console.error('Error calculating pagination:', error);
            return { 
                paginatedDreams: filteredDreams.slice(0, 10), 
                totalPages: 1, 
                totalDreams: filteredDreams.length, 
                itemsPerPage: 10 
            };
        }
    }
    
    // Render dream HTML safely
    function renderDreamHTML(dream) {
        if (!dream || typeof dream !== 'object' || !dream.id) return '';
        
        try {
            const safeTitle = escapeHtml((dream.title || 'Untitled Dream').toString());
            const safeContent = escapeHtml((dream.content || '').toString());
            const safeDateString = escapeHtml((dream.dateString || 'Unknown Date').toString());
            const safeEmotions = escapeHtml((dream.emotions || '').toString());
            const isLucid = Boolean(dream.isLucid);
            
            // Format emotions for display
            const emotionsDisplay = safeEmotions ? 
                `<div class="entry-emotions">
                    <span>Emotions:</span> ${safeEmotions}
                </div>` : '';
            
            // Format tags and dream signs for display
            const tags = Array.isArray(dream.tags) ? dream.tags : [];
            const dreamSigns = Array.isArray(dream.dreamSigns) ? dream.dreamSigns : [];
            
            let tagsDisplay = '';
            if (tags.length > 0 || dreamSigns.length > 0) {
                tagsDisplay = '<div class="entry-tags">';
                
                if (tags.length > 0) {
                    tagsDisplay += `<div class="tag-section">
                        <span class="tag-label">Tags:</span>
                        ${formatTagsForDisplay(tags)}
                    </div>`;
                }
                
                if (dreamSigns.length > 0) {
                    tagsDisplay += `<div class="tag-section">
                        <span class="tag-label">Dream Signs:</span>
                        ${formatDreamSignsForDisplay(dreamSigns)}
                    </div>`;
                }
                
                tagsDisplay += '</div>';
            }
            
            const safeDreamId = escapeAttr(dream.id.toString());
            
            // Create action buttons using helper
            const actionButtons = `<div class="entry-actions">
                ${createActionButton('edit-dream', safeDreamId, 'Edit', 'btn btn-edit btn-small')}
                ${createActionButton('delete-dream', safeDreamId, 'Delete', 'btn btn-delete btn-small')}
            </div>`;
            
            return `
                <div class="entry ${isLucid ? 'lucid' : ''}" id="entry-${safeDreamId}">
                    <div class="entry-header">
                        <div class="entry-title" id="title-${safeDreamId}">${safeTitle}</div>
                        <div class="entry-meta">
                            <div class="entry-date">${safeDateString}</div>
                            ${actionButtons}
                        </div>
                    </div>
                    ${emotionsDisplay}
                    ${tagsDisplay}
                    <div class="entry-content" id="content-${safeDreamId}">${safeContent}</div>
                </div>
            `;
        } catch (error) {
            console.error('Error rendering dream HTML:', error);
            return `<div class="entry error">Error displaying dream</div>`;
        }
    }
    
    // Helper function to render pagination HTML
    function renderPaginationHTML(limitValue, totalPages, totalDreams, paginatedDreams) {
        const paginationContainer = document.getElementById('paginationContainer');
        if (!paginationContainer) return;
        
        if (endlessScrollState.enabled) {
            const remainingDreams = totalDreams - endlessScrollState.loaded;
            if (remainingDreams > 0) {
                paginationContainer.innerHTML = `
                    <div class="pagination-info">
                        Showing ${endlessScrollState.loaded} of ${totalDreams} dreams
                        <br><span style="font-size: 14px;">Scroll down to load ${Math.min(5, remainingDreams)} more...</span>
                    </div>
                `;
            } else {
                paginationContainer.innerHTML = `
                    <div class="pagination-info">
                        All ${totalDreams} dreams loaded
                    </div>
                `;
            }
        } else if (limitValue !== 'all' && totalPages > 1) {
            paginationContainer.innerHTML = renderPagination(currentPage, totalPages, totalDreams, paginatedDreams.length);
        } else {
            paginationContainer.innerHTML = '';
        }
    }


    // --- 5.2 Voice Notes System ---
    // --- All functions related to voice recording, playback, and storage --- //

    // === RECORDING OPERATIONS ===
    
    // Start voice recording
    // MOVED FROM: Main functions area - Voice recording control
    async function startRecording() {
        try {
            if (!isVoiceRecordingSupported()) {
                updateVoiceStatus('Voice recording not supported in this browser', 'error');
                return;
            }
            
            // Check storage limit
            const voiceNotes = await loadVoiceNotes();
            if (voiceNotes.length >= CONSTANTS.VOICE_STORAGE_LIMIT) {
                updateVoiceStatus(`Cannot record: Storage full (${CONSTANTS.VOICE_STORAGE_LIMIT}/${CONSTANTS.VOICE_STORAGE_LIMIT}). Delete a recording first.`, 'error');
                return;
            }
            
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            
            // Determine the best MIME type
            const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' :
                           MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' :
                           MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' :
                           'audio/webm'; // fallback
            
            mediaRecorder = new MediaRecorder(stream, { mimeType });
            
            audioChunks = [];
            recordingStartTime = Date.now();
            recognitionResults = '';
            
            // Setup speech recognition if supported
            if (isSpeechRecognitionSupported()) {
                speechRecognition = setupSpeechRecognition();
                if (speechRecognition) {
                    try {
                        isTranscribing = true;
                        speechRecognition.start();
                    } catch (speechError) {
                        console.error('Failed to start speech recognition:', speechError);
                        isTranscribing = false;
                    }
                }
            }
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data && event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = async () => {
                try {
                    if (audioChunks.length > 0) {
                        const audioBlob = new Blob(audioChunks, { type: mimeType });
                        if (audioBlob.size > 0) {
                            await saveRecording(audioBlob);
                        } else {
                            updateVoiceStatus('Recording failed: No audio data captured', 'error');
                        }
                    } else {
                        updateVoiceStatus('Recording failed: No audio data', 'error');
                    }
                } catch (saveError) {
                    console.error('Error processing recording:', saveError);
                    updateVoiceStatus('Failed to save recording', 'error');
                }
                
                // Stop all tracks to release microphone
                if (stream) {
                    stream.getTracks().forEach(track => {
                        try {
                            track.stop();
                        } catch (e) {
                            console.error('Error stopping track:', e);
                        }
                    });
                }
            };
            
            mediaRecorder.onerror = (event) => {
                console.error('MediaRecorder error:', event);
                updateVoiceStatus('Recording error occurred', 'error');
                stopRecording();
            };
            
            mediaRecorder.start();
            
            // Update UI to recording state
            const recordBtn = document.getElementById('recordBtn');
            const recordIcon = document.getElementById('recordIcon');
            const recordText = document.getElementById('recordText');
            const timerElement = document.getElementById('recordingTimer');
            
            if (recordBtn) recordBtn.className = 'record-btn recording';
            if (recordIcon) recordIcon.textContent = '⏹️';
            if (recordText) recordText.textContent = 'Stop Recording';
            if (timerElement) timerElement.style.display = 'block';
            
            if (isSpeechRecognitionSupported()) {
                updateVoiceStatus('Recording with transcription... Speak clearly for best results', 'info');
            } else {
                updateVoiceStatus('Recording... (transcription not available in this browser)', 'info');
            }
            
            // Start timer
            recordingTimer = setInterval(updateRecordingTimer, 100);
            
        } catch (error) {
            console.error('Error starting recording:', error);
            
            // Handle specific permission errors
            if (error.name === 'NotAllowedError') {
                updateVoiceStatus('Microphone access denied. Please allow microphone access and try again.', 'error');
            } else if (error.name === 'NotFoundError') {
                updateVoiceStatus('No microphone found. Please check your audio devices.', 'error');
            } else if (error.name === 'NotSupportedError') {
                updateVoiceStatus('Audio recording not supported in this browser.', 'error');
            } else {
                updateVoiceStatus('Failed to start recording. Check microphone permissions.', 'error');
            }
            
            // Ensure UI is reset on error
            await updateRecordButtonState();
        }
    }

    // Stop voice recording
    // MOVED FROM: Main functions area - Voice recording control
    function stopRecording() {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }
        
        // Stop speech recognition
        if (speechRecognition && isTranscribing) {
            speechRecognition.stop();
            isTranscribing = false;
        }
        
        // Clear timer
        if (recordingTimer) {
            clearInterval(recordingTimer);
            recordingTimer = null;
        }
        
        // Reset UI elements
        const recordBtn = document.getElementById('recordBtn');
        const recordIcon = document.getElementById('recordIcon');
        const recordText = document.getElementById('recordText');
        const timerElement = document.getElementById('recordingTimer');
        
        // Reset button to ready state
        if (recordBtn) recordBtn.className = 'record-btn ready';
        if (recordIcon) recordIcon.textContent = '🎤';
        if (recordText) recordText.textContent = 'Start Recording';
        
        // Hide and reset timer
        if (timerElement) {
            timerElement.style.display = 'none';
            timerElement.textContent = '0:00';
        }
        
        recordingStartTime = null;
    }

    // Toggle recording state
    // MOVED FROM: Main functions area - Voice recording toggle
    async function toggleRecording() {
        console.log('Toggle recording called'); // Debug log
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            stopRecording();
        } else {
            await startRecording();
        }
    }

    // Save completed recording
    async function saveRecording(audioBlob) {
        try {
            if (!audioBlob || audioBlob.size === 0) {
                throw new Error('Invalid audio data');
            }
            
            const now = new Date();
            const duration = recordingStartTime ? (Date.now() - recordingStartTime) / 1000 : 0;
            
            const voiceNote = {
                id: `voice_${now.getTime()}_${Math.random().toString(36).slice(2, 11)}`,
                audioBlob: audioBlob,
                timestamp: now.toISOString(),
                duration: Math.round(Math.max(0, duration)),
                title: `Voice Note ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`,
                dateString: now.toLocaleDateString('en-AU', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                }),
                size: audioBlob.size,
                transcription: (recognitionResults && recognitionResults.trim()) || null // Store transcribed text
            };
            
            await saveVoiceNote(voiceNote);
            await updateRecordButtonState();
            await displayVoiceNotes();
            
            // Switch to stored notes tab to show the new recording
            switchVoiceTab('stored');
            
            // Show different success messages based on transcription
            if (recognitionResults && recognitionResults.trim()) {
                updateVoiceStatus(`Recording saved with transcription! Duration: ${formatDuration(duration)}`, 'info');
                
                // Show option to create dream entry
                const container = document.querySelector('.voice-recording-section');
                if (container) {
                    const successMsg = document.createElement('div');
                    successMsg.className = 'message-success mt-md';
                    successMsg.innerHTML = `
                        Voice note saved with transcription! (${formatDuration(duration)})<br>
                        <button data-action="create-from-transcription" data-voice-note-id="${voiceNote.id}" class="btn btn-primary btn-small mt-sm">
                            📝 Create Dream Entry
                        </button>
                    `;
                    container.appendChild(successMsg);
                    
                    setTimeout(() => {
                        if (successMsg.parentNode) {
                            successMsg.remove();
                        }
                    }, CONSTANTS.MESSAGE_DURATION_EXTENDED);
                }
            } else {
                updateVoiceStatus(`Recording saved! Duration: ${formatDuration(duration)}`, 'success');
            }
            
        } catch (error) {
            console.error('Error saving recording:', error);
            updateVoiceStatus('Failed to save recording', 'error');
        }
    }

    // === PLAYBACK & MANAGEMENT ===
    
    // Play voice note (Updated for Event Delegation)
    // MOVED FROM: Main functions area - Voice playback control
    async function playVoiceNote(voiceNoteId) {
        try {
            const voiceNotes = await loadVoiceNotes();
            const voiceNote = voiceNotes.find(n => n.id === voiceNoteId);
            
            if (!voiceNote) {
                updateVoiceStatus('Voice note not found', 'error');
                return;
            }
            
            const playBtn = document.getElementById(`play-btn-${voiceNoteId}`);
            const progressContainer = document.getElementById(`progress-container-${voiceNoteId}`);
            
            // Stop any currently playing audio
            if (currentPlayingAudio) {
                currentPlayingAudio.pause();
                currentPlayingAudio = null;
                
                // Reset all play buttons and hide progress bars
                document.querySelectorAll('.voice-btn.pause').forEach(btn => {
                    btn.className = 'voice-btn play';
                    btn.innerHTML = '▶️ Play';
                    btn.dataset.action = 'play-voice';
                });
                document.querySelectorAll('[id^="progress-container-"]').forEach(container => {
                    container.style.display = 'none';
                });
            }
            
            // Create audio element
            const audio = new Audio();
            const audioURL = URL.createObjectURL(voiceNote.audioBlob);
            audio.src = audioURL;
            
            // Update button to pause state and show progress bar
            if (playBtn) {
                playBtn.className = 'voice-btn pause';
                playBtn.innerHTML = '⏸️ Pause';
                playBtn.dataset.action = 'pause-voice';
            }
            
            if (progressContainer) {
                progressContainer.style.display = 'flex';
            }
            
            // Set up audio event listeners for progress tracking
            audio.ontimeupdate = () => {
                updateAudioProgress(voiceNoteId, audio.currentTime, audio.duration);
            };
            
            audio.onloadedmetadata = () => {
                // Update total time display when metadata loads
                const totalTimeEl = document.getElementById(`time-total-${voiceNoteId}`);
                if (totalTimeEl) {
                    totalTimeEl.textContent = formatDuration(audio.duration);
                }
            };
            
            audio.onended = () => {
                try {
                    URL.revokeObjectURL(audioURL);
                } catch (e) {
                    console.warn('Failed to revoke audio URL:', e);
                }
                currentPlayingAudio = null;
                
                // Reset button to play state and hide progress bar
                if (playBtn) {
                    playBtn.className = 'voice-btn play';
                    playBtn.innerHTML = '▶️ Play';
                    playBtn.dataset.action = 'play-voice';
                }
                
                if (progressContainer) {
                    progressContainer.style.display = 'none';
                }
                
                // Reset progress bar
                const progressFill = document.getElementById(`progress-fill-${voiceNoteId}`);
                if (progressFill) {
                    progressFill.style.width = '0%';
                }
                
                // Reset time displays
                const currentTimeEl = document.getElementById(`time-current-${voiceNoteId}`);
                if (currentTimeEl) {
                    currentTimeEl.textContent = '0:00';
                }
            };
            
            audio.onerror = () => {
                try {
                    URL.revokeObjectURL(audioURL);
                } catch (e) {
                    console.warn('Failed to revoke audio URL on error:', e);
                }
                currentPlayingAudio = null;
                updateVoiceStatus('Error playing voice note', 'error');
                
                // Reset button state
                if (playBtn) {
                    playBtn.className = 'voice-btn play';
                    playBtn.innerHTML = '▶️ Play';
                    playBtn.dataset.action = 'play-voice';
                }
                
                if (progressContainer) {
                    progressContainer.style.display = 'none';
                }
            };
            
            // Start playing
            currentPlayingAudio = audio;
            await audio.play();
            
        } catch (error) {
            console.error('Error playing voice note:', error);
            updateVoiceStatus('Failed to play voice note', 'error');
        }
    }


    // --- 5.3 Goal Management ---
    // --- All functions related to goals (init, display, save, calculate) --- //

    // Goal system initialization
    async function initGoals() {
        allGoals = await loadGoals();
        if (document.getElementById('goalsTab')) {
            await displayGoals();
        }
    }
    
    // Display goals in the goals tab
    async function displayGoals() {
        const activeContainer = document.getElementById('activeGoalsContainer');
        const completedContainer = document.getElementById('completedGoalsContainer');
        const noGoalsMessage = document.getElementById('noGoalsMessage');
        const noCompletedMessage = document.getElementById('noCompletedGoalsMessage');
        const activePagination = document.getElementById('activeGoalsPagination');
        const completedPagination = document.getElementById('completedGoalsPagination');
        
        if (!activeContainer || !completedContainer) {
            console.warn('Goals containers not found - goals tab may not be initialized yet');
            return;
        }
        
        const activeGoals = allGoals.filter(goal => goal.status === 'active');
        const completedGoals = allGoals.filter(goal => goal.status === 'completed')
            .sort((a, b) => new Date(b.completedAt || b.createdAt) - new Date(a.completedAt || a.createdAt)); // Sort newest first
        
        // Reset pagination if current page would be empty
        const activeTotalPages = Math.ceil(activeGoals.length / GOALS_PER_PAGE);
        const completedTotalPages = Math.ceil(completedGoals.length / GOALS_PER_PAGE);
        
        if (activeGoalsPage > activeTotalPages && activeTotalPages > 0) {
            activeGoalsPage = activeTotalPages;
        }
        if (completedGoalsPage > completedTotalPages && completedTotalPages > 0) {
            completedGoalsPage = completedTotalPages;
        }
        
        // Show/hide no goals messages
        noGoalsMessage.style.display = activeGoals.length === 0 ? 'block' : 'none';
        noCompletedMessage.style.display = completedGoals.length === 0 ? 'block' : 'none';
        
        // Calculate pagination for active goals
        const activeStartIndex = (activeGoalsPage - 1) * GOALS_PER_PAGE;
        const activeEndIndex = activeStartIndex + GOALS_PER_PAGE;
        const activePage = activeGoals.slice(activeStartIndex, activeEndIndex);
        
        // Render active goals
        activeContainer.innerHTML = '';
        for (const goal of activePage) {
            const progress = await calculateGoalProgress(goal);
            activeContainer.appendChild(createGoalElement(goal, progress));
        }
        
        // Render active goals pagination
        if (activeTotalPages > 1) {
            activePagination.style.display = 'block';
            activePagination.innerHTML = createPaginationHTML(activeGoalsPage, activeTotalPages, 'active-goals-page');
        } else {
            activePagination.style.display = 'none';
        }
        
        // Calculate pagination for completed goals
        const completedStartIndex = (completedGoalsPage - 1) * GOALS_PER_PAGE;
        const completedEndIndex = completedStartIndex + GOALS_PER_PAGE;
        const completedPage = completedGoals.slice(completedStartIndex, completedEndIndex);
        
        // Render completed goals
        completedContainer.innerHTML = '';
        for (const goal of completedPage) {
            const progress = await calculateGoalProgress(goal);
            completedContainer.appendChild(createGoalElement(goal, progress, true));
        }
        
        // Render completed goals pagination
        if (completedTotalPages > 1) {
            completedPagination.style.display = 'block';
            completedPagination.innerHTML = createPaginationHTML(completedGoalsPage, completedTotalPages, 'completed-goals-page');
        } else {
            completedPagination.style.display = 'none';
        }
    }

    // Change active goals page
    function changeActiveGoalsPage(page) {
        if (page < 1) return;
        const activeGoals = allGoals.filter(goal => goal.status === 'active');
        const totalPages = Math.ceil(activeGoals.length / GOALS_PER_PAGE);
        if (page > totalPages) return;
        
        activeGoalsPage = page;
        displayGoals();
    }
    
    // Change completed goals page
    function changeCompletedGoalsPage(page) {
        if (page < 1) return;
        const completedGoals = allGoals.filter(goal => goal.status === 'completed');
        const totalPages = Math.ceil(completedGoals.length / GOALS_PER_PAGE);
        if (page > totalPages) return;
        
        completedGoalsPage = page;
        displayGoals();
    }
    
    // Get clean label for goal type
    function getGoalTypeLabel(type) {
        const labels = {
            'lucid_count': 'lucid dreams',
            'recall_streak': 'day streak',
            'journal_streak': 'day streak',
            'dream_signs_count': 'dream signs',
            'custom': ''
        };
        return labels[type] || '';
    }
    
    // Create goal HTML element
    function createGoalElement(goal, progress, isCompleted = false) {
        const goalDiv = document.createElement('div');
        goalDiv.className = `card-md goal-card mb-md ${isCompleted ? 'completed' : ''}`;
        
        const progressPercent = Math.min((progress.current / goal.target) * 100, 100);
        const statusClass = progressPercent === 100 ? 'success' : progressPercent >= 50 ? 'warning' : 'primary';
        
        goalDiv.innerHTML = `
            <div class="flex-between mb-md">
                <h4>${escapeHtml(goal.icon)} ${escapeHtml(goal.title)}</h4>
                <div class="goal-actions">
                    ${!isCompleted ? `
                        <button data-action="edit-goal" data-goal-id="${goal.id}" class="btn btn-outline btn-small">Edit</button>
                        <button data-action="complete-goal" data-goal-id="${goal.id}" class="btn btn-success btn-small">Complete</button>
                    ` : `
                        <button data-action="reactivate-goal" data-goal-id="${goal.id}" class="btn btn-warning btn-small">Reactivate</button>
                    `}
                    <button data-action="delete-goal" data-goal-id="${goal.id}" class="btn btn-error btn-small">Delete</button>
                </div>
            </div>
            <p class="text-secondary mb-md">${escapeHtml(goal.description)}</p>
            <div class="goal-progress-section">
                <div class="flex-between mb-sm">
                    <span class="font-semibold">Progress:</span>
                    <span class="status-${statusClass}">${progress.current} / ${goal.target} ${getGoalTypeLabel(goal.type)}</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill progress-${statusClass}" style="width: ${progressPercent}%;"></div>
                </div>
                ${progress.message ? `<p class="text-secondary text-sm mt-sm">${progress.message}</p>` : ''}
                ${goal.type === 'custom' && !isCompleted ? `
                    <div class="custom-goal-controls mt-md">
                        <div class="flex-center gap-md">
                            <button data-action="decrease-goal-progress" data-goal-id="${goal.id}" class="btn btn-outline btn-small" ${progress.current <= 0 ? 'disabled' : ''}>➖</button>
                            <span class="font-semibold">Manual Tracking</span>
                            <button data-action="increase-goal-progress" data-goal-id="${goal.id}" class="btn btn-outline btn-small">➕</button>
                        </div>
                    </div>
                ` : ''}
            </div>
            <div class="flex-between text-sm text-secondary">
                <div>
                    <span>Created: ${new Date(goal.createdAt).toLocaleDateString()}</span>
                    ${isCompleted && goal.completedAt ? `<br><span>Completed: ${new Date(goal.completedAt).toLocaleDateString()}</span>` : ''}
                </div>
                <span>${goal.period === 'monthly' ? 'Monthly Goal' : goal.period === 'streak' ? 'Streak Goal' : 'Total Goal'}</span>
            </div>
        `;
        
        return goalDiv;
    }
    
    // Calculate goal progress based on dream data
    async function calculateGoalProgress(goal) {
        const dreams = await loadDreams();
        const now = new Date();
        
        let current = 0;
        let message = '';
        
        switch (goal.type) {
            case 'lucid_count':
                if (goal.period === 'monthly') {
                    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
                    const lucidDreams = dreams.filter(dream => 
                        dream.isLucid && new Date(dream.timestamp) >= startOfMonth
                    );
                    current = lucidDreams.length;
                    message = `${current} lucid dreams this month`;
                }
                break;
                
            case 'recall_streak':
                current = calculateDreamRecallStreak(dreams);
                message = current === 1 ? '1 day streak' : `${current} days streak`;
                break;
                
            case 'journal_streak':
                current = calculateJournalingStreak(dreams);
                message = current === 1 ? '1 day streak' : `${current} days streak`;
                break;
                
            case 'dream_signs_count':
                const dreamSigns = new Set();
                dreams.forEach(dream => {
                    if (dream.dreamSigns && typeof dream.dreamSigns === 'string') {
                        const signs = dream.dreamSigns.split(',').map(s => s.trim().toLowerCase());
                        signs.forEach(sign => {
                            if (sign) dreamSigns.add(sign);
                        });
                    } else if (Array.isArray(dream.dreamSigns)) {
                        // Handle case where dreamSigns might be stored as an array
                        dream.dreamSigns.forEach(sign => {
                            if (sign && typeof sign === 'string') {
                                dreamSigns.add(sign.trim().toLowerCase());
                            }
                        });
                    }
                });
                current = dreamSigns.size;
                message = `${current} unique dream signs identified`;
                break;
                
            case 'custom':
                current = goal.currentProgress || 0;
                message = `${current} completed`;
                break;
        }
        
        return { current, message };
    }

    // Show create goal dialog
    function showCreateGoalDialog(template = null) {
        console.log('showCreateGoalDialog called with template:', template);
        
        const dialog = document.createElement('div');
        dialog.className = 'pin-overlay';
        dialog.style.display = 'flex';
        
        const templateData = template ? GOAL_TEMPLATES[template] : null;
        
        dialog.innerHTML = `
            <div class="pin-container">
                <h3>${template ? 'Create Goal from Template' : 'Create New Goal'}</h3>
                <div class="form-group">
                    <label for="goalTitle">Goal Title</label>
                    <input type="text" id="goalTitle" class="form-control" value="${templateData?.title || ''}" required>
                </div>
                <div class="form-group">
                    <label for="goalDescription">Description</label>
                    <textarea id="goalDescription" class="form-control" rows="3">${templateData?.description || ''}</textarea>
                </div>
                <div class="form-group">
                    <label for="goalType">Goal Type</label>
                    <select id="goalType" class="form-control">
                        <option value="lucid_count" ${templateData?.type === 'lucid_count' ? 'selected' : ''}>Lucid Dreams Count</option>
                        <option value="recall_streak" ${templateData?.type === 'recall_streak' ? 'selected' : ''}>Dream Recall Streak</option>
                        <option value="journal_streak" ${templateData?.type === 'journal_streak' ? 'selected' : ''}>Journal Writing Streak</option>
                        <option value="dream_signs_count" ${templateData?.type === 'dream_signs_count' ? 'selected' : ''}>Dream Signs Collection</option>
                        <option value="custom" ${templateData?.type === 'custom' ? 'selected' : ''}>Custom (Manual Tracking)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="goalPeriod">Time Period</label>
                    <select id="goalPeriod" class="form-control">
                        <option value="monthly" ${templateData?.period === 'monthly' ? 'selected' : ''}>Monthly</option>
                        <option value="streak" ${templateData?.period === 'streak' ? 'selected' : ''}>Consecutive Days</option>
                        <option value="total" ${templateData?.period === 'total' ? 'selected' : ''}>All Time Total</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="goalTarget">Target Number</label>
                    <input type="number" id="goalTarget" class="form-control" value="${templateData?.target || 1}" min="1" required>
                </div>
                <div class="form-group">
                    <label for="goalIcon">Icon (optional)</label>
                    <input type="text" id="goalIcon" class="form-control" value="${templateData?.icon || '🎯'}" maxlength="2">
                </div>
                <div class="pin-buttons">
                    <button data-action="save-goal" class="btn btn-primary">Create Goal</button>
                    <button data-action="cancel-goal-dialog" class="btn btn-secondary">Cancel</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(dialog);
        document.getElementById('goalTitle').focus();
    }
    
    // Create goal from template
    function createTemplateGoal(templateKey) {
        if (GOAL_TEMPLATES[templateKey]) {
            showCreateGoalDialog(templateKey);
        }
    }
    
    // Save goal
    async function saveGoal() {
        console.log('saveGoal function called');
        
        // Defensive check - ensure allGoals is still an array
        if (!Array.isArray(allGoals)) {
            console.warn('allGoals is not an array, reloading from storage');
            try {
                allGoals = await loadGoals();
                console.log('Reloaded goals from storage:', allGoals.length, 'goals');
            } catch (error) {
                console.error('Failed to reload goals:', error);
                allGoals = [];
            }
        }
        
        const titleElement = document.getElementById('goalTitle');
        const descriptionElement = document.getElementById('goalDescription');
        const typeElement = document.getElementById('goalType');
        const periodElement = document.getElementById('goalPeriod');
        const targetElement = document.getElementById('goalTarget');
        const iconElement = document.getElementById('goalIcon');
        
        if (!titleElement || !descriptionElement || !typeElement || !periodElement || !targetElement || !iconElement) {
            console.error('Goal form elements not found');
            createInlineMessage('error', 'Goal form not properly initialized', {
                container: document.body,
                position: 'top',
                duration: CONSTANTS.MESSAGE_DURATION_SHORT
            });
            return;
        }
        
        const title = titleElement.value.trim();
        const description = descriptionElement.value.trim();
        const type = typeElement.value;
        const period = periodElement.value;
        const target = parseInt(targetElement.value);
        const icon = iconElement.value.trim() || '🎯';
        
        console.log('Goal form values:', { title, description, type, period, target, icon });
        
        if (!title || !target || target < 1) {
            createInlineMessage('error', 'Please fill in all required fields with valid values', {
                container: document.body,
                position: 'top',
                duration: CONSTANTS.MESSAGE_DURATION_SHORT
            });
            return;
        }
        
        if (window.editingGoalId) {
            // Edit existing goal
            const goalIndex = allGoals.findIndex(g => g.id === window.editingGoalId);
            if (goalIndex !== -1) {
                allGoals[goalIndex] = {
                    ...allGoals[goalIndex],
                    title,
                    description,
                    type,
                    period,
                    target,
                    icon,
                    updatedAt: new Date().toISOString(),
                    // Initialize currentProgress for goals being converted to custom
                    currentProgress: type === 'custom' && allGoals[goalIndex].currentProgress === undefined ? 0 : allGoals[goalIndex].currentProgress
                };
                await saveGoals(allGoals);
                await displayGoals();
                cancelGoalDialog();
                createInlineMessage('success', 'Goal updated successfully!', {
                    container: document.body,
                    position: 'top',
                    duration: CONSTANTS.MESSAGE_DURATION_SHORT
                });
                delete window.editingGoalId;
            }
        } else {
            // Create new goal
            const goal = {
                id: generateUniqueId(),
                title,
                description,
                type,
                period,
                target,
                icon,
                status: 'active',
                createdAt: new Date().toISOString(),
                // Add currentProgress field for custom goals
                currentProgress: type === 'custom' ? 0 : undefined
            };
            
            try {
                allGoals.push(goal);
                console.log('Goal added to array, total goals:', allGoals.length);
                
                await saveGoals(allGoals);
                console.log('Goals saved to storage');
                
                await displayGoals();
                console.log('Goals display updated');
                
                cancelGoalDialog();
                createInlineMessage('success', 'Goal created successfully!', {
                    container: document.body,
                    position: 'top',
                    duration: CONSTANTS.MESSAGE_DURATION_SHORT
                });
            } catch (error) {
                console.error('Error creating goal:', error);
                createInlineMessage('error', 'Failed to create goal. Please try again.', {
                    container: document.body,
                    position: 'top',
                    duration: CONSTANTS.MESSAGE_DURATION_SHORT
                });
            }
        }
    }
    
    // Edit goal
    function editGoal(goalId) {
        const goal = allGoals.find(g => g.id === goalId);
        if (!goal) return;
        
        window.editingGoalId = goalId; // Store ID for save function
        showCreateGoalDialog();
        
        // Fill current values
        setTimeout(() => {
            document.getElementById('goalTitle').value = goal.title;
            document.getElementById('goalDescription').value = goal.description;
            document.getElementById('goalType').value = goal.type;
            document.getElementById('goalPeriod').value = goal.period;
            document.getElementById('goalTarget').value = goal.target;
            document.getElementById('goalIcon').value = goal.icon;
            
            // Update dialog title and button text
            const dialog = document.querySelector('.pin-overlay:not(#pinOverlay)');
            const dialogTitle = dialog.querySelector('h3');
            const saveButton = dialog.querySelector('[data-action="save-goal"]');
            if (dialogTitle) dialogTitle.textContent = 'Edit Goal';
            if (saveButton) saveButton.textContent = 'Update Goal';
        }, 10);
    }
    
    // Complete goal
    async function completeGoal(goalId) {
        const goal = allGoals.find(g => g.id === goalId);
        if (!goal) return;
        
        goal.status = 'completed';
        goal.completedAt = new Date().toISOString();
        
        await saveGoals(allGoals);
        await displayGoals();
        createInlineMessage('success', `🎉 Congratulations! Goal "${goal.title}" completed!`, {
            container: document.body,
            position: 'top',
            duration: CONSTANTS.MESSAGE_DURATION_MEDIUM
        });
    }
    
    // Reactivate goal (move back to active from completed)
    async function reactivateGoal(goalId) {
        const goal = allGoals.find(g => g.id === goalId);
        if (!goal || goal.status !== 'completed') return;
        
        goal.status = 'active';
        goal.reactivatedAt = new Date().toISOString();
        // Remove completedAt timestamp
        delete goal.completedAt;
        
        try {
            await saveGoals(allGoals);
            
            // Check if we need to adjust pagination after reactivation
            const remainingCompleted = allGoals.filter(g => g.status === 'completed');
            const completedTotalPages = Math.ceil(remainingCompleted.length / GOALS_PER_PAGE);
            if (completedGoalsPage > completedTotalPages && completedTotalPages > 0) {
                completedGoalsPage = completedTotalPages;
            }
            
            await displayGoals();
            createInlineMessage('success', `🔄 Goal "${goal.title}" reactivated!`, {
                container: document.body,
                position: 'top',
                duration: CONSTANTS.MESSAGE_DURATION_SHORT
            });
        } catch (error) {
            console.error('Error reactivating goal:', error);
            createInlineMessage('error', 'Failed to reactivate goal. Please try again.', {
                container: document.body,
                position: 'top',
                duration: CONSTANTS.MESSAGE_DURATION_SHORT
            });
        }
    }
    
    // Delete goal
    function deleteGoal(goalId) {
        const goal = allGoals.find(g => g.id === goalId);
        if (!goal) return;
        
        showDeleteGoalConfirmation(goal);
    }
    
    // Show delete confirmation
    function showDeleteGoalConfirmation(goal) {
        const dialog = document.createElement('div');
        dialog.className = 'pin-overlay';
        dialog.style.display = 'flex';
        
        dialog.innerHTML = `
            <div class="pin-container">
                <h3>Delete Goal</h3>
                <p>Are you sure you want to delete the goal "${goal.title}"? This action cannot be undone.</p>
                <div class="pin-buttons">
                    <button data-action="confirm-delete-goal" data-goal-id="${goal.id}" class="btn btn-error">Delete</button>
                    <button data-action="cancel-goal-dialog" class="btn btn-secondary">Cancel</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(dialog);
    }
    
    // Confirm delete goal
    async function confirmDeleteGoal(goalId) {
        allGoals = allGoals.filter(g => g.id !== goalId);
        await saveGoals(allGoals);
        await displayGoals();
        cancelGoalDialog();
        createInlineMessage('success', 'Goal deleted successfully', {
            container: document.body,
            position: 'top',
            duration: CONSTANTS.MESSAGE_DURATION_SHORT
        });
    }
    
    // Cancel goal dialog
    function cancelGoalDialog() {
        const dialog = document.querySelector('.pin-overlay:not(#pinOverlay)');
        if (dialog) {
            document.body.removeChild(dialog);
        }
        // Clean up editing state
        if (window.editingGoalId) {
            delete window.editingGoalId;
        }
    }
    
    // Increase goal progress (for custom goals)
    async function increaseGoalProgress(goalId) {
        const goal = allGoals.find(g => g.id === goalId);
        if (!goal || goal.type !== 'custom') return;
        
        // Increase progress, but don't exceed target
        const newProgress = Math.min((goal.currentProgress || 0) + 1, goal.target);
        goal.currentProgress = newProgress;
        goal.lastUpdated = new Date().toISOString();
        
        try {
            await saveGoals(allGoals);
            await displayGoals();
            
            // Auto-complete the goal if target reached
            if (newProgress >= goal.target && goal.status !== 'completed') {
                setTimeout(() => {
                    createInlineMessage('success', `🎉 Goal "${goal.title}" completed! Great job!`, {
                        container: document.body,
                        position: 'top',
                        duration: 3000
                    });
                }, 100);
            }
        } catch (error) {
            console.error('Error updating goal progress:', error);
            createInlineMessage('error', 'Failed to update goal progress', {
                container: document.body,
                position: 'top',
                duration: CONSTANTS.MESSAGE_DURATION_SHORT
            });
        }
    }
    
    // Decrease goal progress (for custom goals)
    async function decreaseGoalProgress(goalId) {
        const goal = allGoals.find(g => g.id === goalId);
        if (!goal || goal.type !== 'custom') return;
        
        // Decrease progress, but don't go below 0
        const newProgress = Math.max((goal.currentProgress || 0) - 1, 0);
        goal.currentProgress = newProgress;
        goal.lastUpdated = new Date().toISOString();
        
        try {
            await saveGoals(allGoals);
            await displayGoals();
        } catch (error) {
            console.error('Error updating goal progress:', error);
            createInlineMessage('error', 'Failed to update goal progress', {
                container: document.body,
                position: 'top',
                duration: CONSTANTS.MESSAGE_DURATION_SHORT
            });
        }
    }


    // --- 5.4 Stats & Calendar ---
    // --- All functions related to the stats tab and calendar --- //

    // Streak calculation utilities
    function calculateDreamRecallStreak(dreams) {
        const today = new Date();
        let streak = 0;
        
        for (let i = 0; i < 365; i++) {
            const checkDate = new Date(today);
            checkDate.setDate(today.getDate() - i);
            checkDate.setHours(0, 0, 0, 0);
            
            const nextDay = new Date(checkDate);
            nextDay.setDate(checkDate.getDate() + 1);
            
            const hasDream = dreams.some(dream => {
                const dreamDate = new Date(dream.timestamp);
                return dreamDate >= checkDate && dreamDate < nextDay;
            });
            
            if (hasDream) {
                streak++;
            } else if (i === 0) {
                // If no dream today, check if there's one yesterday to start counting
                continue;
            } else {
                break;
            }
        }
        
        return streak;
    }
    
    // Journaling streak calculation
    function calculateJournalingStreak(dreams) {
        return calculateDreamRecallStreak(dreams); // Same logic for now
    }

    // Goal statistics calculations
    
    // Calculate goal completion stats for a specific time period
    function calculateGoalStats(goals, startDate = null, endDate = null) {
        if (!Array.isArray(goals)) {
            return { total: 0, completed: 0, active: 0, completionRate: 0 };
        }
        
        let filteredGoals = goals;
        
        // Filter goals by date range if provided
        if (startDate || endDate) {
            filteredGoals = goals.filter(goal => {
                if (!goal.completedAt && !goal.createdAt) return false;
                
                // For completed goals, check completion date
                if (goal.status === 'completed' && goal.completedAt) {
                    const completionDate = new Date(goal.completedAt);
                    if (startDate && completionDate < startDate) return false;
                    if (endDate && completionDate > endDate) return false;
                    return true;
                }
                
                // For active goals, check creation date to see if they were active during the period
                if (goal.status === 'active' && goal.createdAt) {
                    const creationDate = new Date(goal.createdAt);
                    if (startDate && creationDate > endDate) return false; // Created after the period
                    return true;
                }
                
                return false;
            });
        }
        
        const total = filteredGoals.length;
        const completed = filteredGoals.filter(goal => goal.status === 'completed').length;
        const active = filteredGoals.filter(goal => goal.status === 'active').length;
        const completionRate = total > 0 ? ((completed / total) * 100).toFixed(1) : 0;
        
        return { total, completed, active, completionRate };
    }
    
    // Get goal completion stats for a specific month
    function getMonthlyGoalStats(goals, year, month) {
        const startDate = new Date(year, month, 1);
        const endDate = new Date(year, month + 1, 0, 23, 59, 59, 999);
        return calculateGoalStats(goals, startDate, endDate);
    }
    
    // Get goal completion stats for a specific year
    function getYearlyGoalStats(goals, year) {
        const startDate = new Date(year, 0, 1);
        const endDate = new Date(year, 11, 31, 23, 59, 59, 999);
        return calculateGoalStats(goals, startDate, endDate);
    }
    
    // Get lifetime goal completion stats
    function getLifetimeGoalStats(goals) {
        return calculateGoalStats(goals);
    }

    // Statistics display management
    async function updateStatsDisplay() {
        try {
            const dreams = await loadDreams();
            const voiceNotes = await loadVoiceNotes();
            
            // Basic counts
            const totalDreams = dreams.length;
            const lucidDreams = dreams.filter(d => d.isLucid).length;
            const lucidPercentage = totalDreams > 0 ? ((lucidDreams / totalDreams) * 100).toFixed(1) : 0;
            
            // Recent dreams (last 7 days)
            const weekAgo = new Date();
            weekAgo.setDate(weekAgo.getDate() - 7);
            const recentDreams = dreams.filter(d => new Date(d.timestamp) > weekAgo).length;
            
            // Most common emotion
            const emotions = dreams
                .map(d => d.emotions)
                .filter(e => e && e.trim())
                .flatMap(e => e.split(',').map(em => em.trim().toLowerCase()));
            
            const emotionCounts = {};
            emotions.forEach(emotion => {
                emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
            });
            
            const topEmotion = Object.keys(emotionCounts).length > 0 ? 
                Object.entries(emotionCounts).sort((a, b) => b[1] - a[1])[0] : null;
            
            // Most common tag
            const tags = dreams
                .flatMap(d => Array.isArray(d.tags) ? d.tags : [])
                .filter(t => t && t.trim());
            
            const tagCounts = {};
            tags.forEach(tag => {
                tagCounts[tag] = (tagCounts[tag] || 0) + 1;
            });
            
            const topTag = Object.keys(tagCounts).length > 0 ? 
                Object.entries(tagCounts).sort((a, b) => b[1] - a[1])[0] : null;
            
            // Update display elements
            const totalElement = document.getElementById('totalDreamsCount');
            const lucidElement = document.getElementById('lucidDreamsCount');
            const lucidPercentageElement = document.getElementById('lucidPercentage');
            const voiceElement = document.getElementById('voiceNotesCount');
            const voiceDetailElement = document.getElementById('voiceNotesDetail');
            const recentElement = document.getElementById('recentDreamsCount');
            const topEmotionElement = document.getElementById('topEmotionDisplay');
            const topEmotionDetailElement = document.getElementById('topEmotionDetail');
            const topTagElement = document.getElementById('topTagDisplay');
            const topTagDetailElement = document.getElementById('topTagDetail');
            
            if (totalElement) totalElement.textContent = totalDreams;
            if (lucidElement) lucidElement.textContent = lucidDreams;
            if (lucidPercentageElement) lucidPercentageElement.textContent = `${lucidPercentage}% of all dreams`;
            if (voiceElement) voiceElement.textContent = voiceNotes.length;
            if (voiceDetailElement) {
                const voiceLimit = CONSTANTS.VOICE_STORAGE_LIMIT;
                voiceDetailElement.textContent = `${voiceNotes.length}/${voiceLimit} storage slots used`;
            }
            if (recentElement) recentElement.textContent = recentDreams;
            
            if (topEmotionElement && topEmotionDetailElement) {
                if (topEmotion) {
                    topEmotionElement.textContent = topEmotion[0];
                    topEmotionDetailElement.textContent = `Appears in ${topEmotion[1]} dreams`;
                } else {
                    topEmotionElement.textContent = '😴';
                    topEmotionDetailElement.textContent = 'No emotions recorded yet';
                }
            }
            
            if (topTagElement && topTagDetailElement) {
                if (topTag) {
                    topTagElement.textContent = `#${topTag[0]}`;
                    topTagDetailElement.textContent = `Used in ${topTag[1]} dreams`;
                } else {
                    topTagElement.textContent = '#dreams';
                    topTagDetailElement.textContent = 'No tags recorded yet';
                }
            }
            
        } catch (error) {
            console.error('Error updating stats display:', error);
        }
    }

    // Calendar initialization
    async function initCalendar() {
        await updateCalendarData();
        const currentDate = new Date();
        await renderCalendar(currentDate.getFullYear(), currentDate.getMonth());
    }

    // Calendar rendering
    async function renderCalendar(year, month) {
        const calendarContainer = document.getElementById('calendarContainer');
        if (!calendarContainer) return;

        calendarState.date = new Date(year, month, 1);
        const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

        let header = `
            <div class="calendar-header">
                <button data-action="prev-month" class="calendar-nav-btn prev" title="Previous Month"></button>
                <div class="calendar-nav">
                    <select id="monthSelect" class="filter-select" data-action="select-month">
                        ${monthNames.map((m, i) => `<option value="${i}" ${i === month ? 'selected' : ''}>${m}</option>`).join('')}
                    </select>
                    <select id="yearSelect" class="filter-select" data-action="select-year">
                        ${getYearOptions(year)}
                    </select>
                </div>
                <button data-action="next-month" class="calendar-nav-btn next" title="Next Month"></button>
            </div>
        `;

        let calendarHTML = header + '<table class="calendar-grid"><thead><tr>';
        const weekDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        weekDays.forEach(day => calendarHTML += `<th>${day}</th>`);
        calendarHTML += '</tr></thead><tbody>';

        const firstDay = new Date(year, month).getDay();
        const daysInMonth = 32 - new Date(year, month, 32).getDate();

        let date = 1;
        for (let i = 0; i < 6; i++) {
            calendarHTML += '<tr>';
            for (let j = 0; j < 7; j++) {
                if (i === 0 && j < firstDay) {
                    const prevMonth = new Date(year, month, 0);
                    const prevMonthDays = prevMonth.getDate();
                    const day = prevMonthDays - firstDay + j + 1;
                    calendarHTML += `<td><div class="calendar-day other-month"><div class="day-number">${day}</div></div></td>`;
                } else if (date > daysInMonth) {
                    const nextMonthDay = date - daysInMonth;
                    calendarHTML += `<td><div class="calendar-day other-month"><div class="day-number">${nextMonthDay}</div></div></td>`;
                    date++;
                } else {
                    const currentDate = new Date(year, month, date);
                    const today = new Date();
                    const isToday = today.getDate() === date && today.getMonth() === month && today.getFullYear() === year;

                    // Manually format date string to avoid timezone issues with toISOString()
                    const y = currentDate.getFullYear();
                    const m = String(currentDate.getMonth() + 1).padStart(2, '0');
                    const d = String(currentDate.getDate()).padStart(2, '0');
                    const dateStr = `${y}-${m}-${d}`;

                    const dreamData = calendarState.dreamsByDate[dateStr];

                    calendarHTML += `
                        <td>
                            <div class="calendar-day ${isToday ? 'today' : ''}" data-action="go-to-date" data-date="${dateStr}">
                                <div class="day-number">${date}</div>
                                ${dreamData ? `<div class="dream-indicator" title="${dreamData.count} dream(s), ${dreamData.lucid} lucid">${dreamData.lucid > 0 ? '✨ ' : ''}${dreamData.count}</div>` : ''}
                            </div>
                        </td>
                    `;
                    date++;
                }
            }
            calendarHTML += '</tr>';
            if (date > daysInMonth && i >= 4) { // ensure at least 5 rows, but break if done
                break;
            }
        }

        calendarHTML += '</tbody></table>';
        calendarContainer.innerHTML = calendarHTML;

        await updateMonthlyStats(year, month);
        await renderPieChart(year, month);
        await updateYearlyStats(year);
        await renderYearlyPieChart(year);
        await updateLifetimeStats();
        await renderLifetimePieChart();
    }

    // Chart rendering functionality
    async function renderPieChart(year, month) {
        const pieChartContainer = document.getElementById('pieChartContainer');
        if (!pieChartContainer) return;

        pieChartContainer.innerHTML = `<h3 class="text-primary mb-md">Dream Types</h3><div class="loading-state">Loading chart...</div>`;

        try {
            const dreams = await loadDreams();

            const dreamsInMonth = dreams.filter(dream => {
                const dreamDate = new Date(dream.timestamp);
                return dreamDate.getFullYear() === year && dreamDate.getMonth() === month;
            });

            const totalDreams = dreamsInMonth.length;
            const lucidDreams = dreamsInMonth.filter(d => d.isLucid).length;
            const regularDreams = totalDreams - lucidDreams;

            if (totalDreams === 0) {
                pieChartContainer.innerHTML = `
                    <h3 class="text-primary mb-md">Dream Types</h3>
                    <div class="no-entries" style="padding: 20px;">No dreams recorded for this month to create a chart.</div>
                `;
                return;
            }

            const lucidPercentage = (lucidDreams / totalDreams) * 100;
            const regularPercentage = 100 - lucidPercentage;

            const lucidColor = 'var(--success-color)';
            const regularColor = 'var(--info-color)';

            const gradient = `conic-gradient(${lucidColor} 0% ${lucidPercentage.toFixed(2)}%, ${regularColor} ${lucidPercentage.toFixed(2)}% 100%)`;

            const chartHTML = `
                <h3 class="text-primary mb-md">Dream Types</h3>
                <div class="pie-chart-container">
                    <div class="pie-chart" style="background: ${gradient};">
                        <div class="pie-chart-center">
                            <div class="pie-chart-total">${totalDreams}</div>
                            <div class="pie-chart-label">Dreams</div>
                        </div>
                    </div>
                    <div class="pie-chart-legend">
                        <div class="legend-item">
                            <div class="legend-color-box" style="background: ${lucidColor};"></div>
                            <span>Lucid (${lucidDreams}) - ${lucidPercentage.toFixed(1)}%</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color-box" style="background: ${regularColor};"></div>
                            <span>Regular (${regularDreams}) - ${regularPercentage.toFixed(1)}%</span>
                        </div>
                    </div>
                </div>
            `;

            pieChartContainer.innerHTML = chartHTML;

        } catch (error) {
            console.error('Error rendering pie chart:', error);
            pieChartContainer.innerHTML = `<h3 class="text-primary mb-md">Dream Types</h3><div class="message-error">Failed to load chart.</div>`;
        }
    }


    // --- 5.5 Import, Export & Data Management ---
    
    // Export dreams to text file (with optional encryption)
    async function exportEntries() {
        // Check if app is locked
        if (isAppLocked || (isPinSetup() && !isUnlocked)) {
            switchAppTab('lock');
            setTimeout(() => {
                showLockScreenMessage('error', 'Please unlock your journal first to export your dreams.');
            }, 500);
            return;
        }
        
        const dreams = await loadDreams();
        
        if (dreams.length === 0) {
            createInlineMessage('error', 'No dreams to export yet. Add some dreams first!', {
                container: document.querySelector('.main-content'),
                position: 'top',
                duration: 3000
            });
            return;
        }
        
        try {
            const exportText = dreams.map(dream => {
                // Safety checks for dream properties
                const safeTitle = dream && dream.title ? dream.title : 'Untitled Dream';
                const safeTimestamp = dream && dream.timestamp ? dream.timestamp : new Date().toISOString();
                const safeContent = dream && dream.content ? dream.content : 'No content';
                const safeIsLucid = dream && dream.isLucid ? 'Lucid Dream ✨' : 'Regular Dream';
                const safeEmotions = dream && dream.emotions ? dream.emotions : '';
                const safeTags = Array.isArray(dream.tags) && dream.tags.length > 0 ? dream.tags.join(', ') : '';
                const safeDreamSigns = Array.isArray(dream.dreamSigns) && dream.dreamSigns.length > 0 ? dream.dreamSigns.join(', ') : '';
                
                let exportEntry = `Title: ${safeTitle}\n` +
                       `Timestamp: ${safeTimestamp}\n` +
                       `Type: ${safeIsLucid}\n`;
                
                // Add emotions if they exist
                if (safeEmotions) {
                    exportEntry += `Emotions: ${safeEmotions}\n`;
                }
                
                // Add tags if they exist
                if (safeTags) {
                    exportEntry += `Tags: ${safeTags}\n`;
                }
                
                // Add dream signs if they exist
                if (safeDreamSigns) {
                    exportEntry += `Dream Signs: ${safeDreamSigns}\n`;
                }
                
                exportEntry += `Content: ${safeContent}\n` +
                             `${'='.repeat(50)}\n`;
                
                return exportEntry;
            }).join('\n');
            
            if (!exportText || exportText.trim().length === 0) {
                throw new Error('No valid dream data found to export');
            }
            
            // Check if encryption is enabled
            const encryptionEnabled = document.getElementById('encryptionEnabled').checked;
            let finalData = exportText;
            let fileName = `dream-journal-${new Date().toISOString().split('T')[0]}.txt`;
            let mimeType = 'text/plain';
            
            if (encryptionEnabled) {
                // Show password dialog
                const password = await showPasswordDialog({
                    type: 'export',
                    title: '🔐 Set Export Password',
                    description: 'Choose a password to encrypt your dream export. This password is not stored - remember it for importing!',
                    requireConfirm: true,
                    primaryButtonText: 'Encrypt & Export'
                });
                
                if (!password) {
                    // User cancelled
                    return;
                }
                
                // Encrypt the data
                const encryptedData = await encryptData(exportText, password);
                finalData = encryptedData;
                fileName = `dream-journal-${new Date().toISOString().split('T')[0]}.enc`;
                mimeType = 'application/octet-stream';
            }
            
            // Create and download file
            const blob = new Blob([finalData], { type: mimeType });
            
            if (blob.size === 0) {
                throw new Error('Export file is empty - no data to export');
            }
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.style.display = 'none';
            
            document.body.appendChild(a);
            
            // Mobile browsers need direct click without setTimeout
            try {
                a.click();
                
                // Clean up after a longer delay to ensure download starts
                setTimeout(() => {
                    if (document.body.contains(a)) {
                        document.body.removeChild(a);
                    }
                    URL.revokeObjectURL(url);
                }, CONSTANTS.DOWNLOAD_CLEANUP_DELAY_MS); // longer delay instead of 100ms
                
            } catch (clickError) {
                console.error('Click error:', clickError);
                // Clean up on error
                if (document.body.contains(a)) {
                    document.body.removeChild(a);
                }
                URL.revokeObjectURL(url);
                throw new Error('Failed to initiate download');
            }
            
            // Show success message
            const successMessage = encryptionEnabled ? 
                'Encrypted dream export created successfully!' : 
                'Dream export created successfully!';
                
            createInlineMessage('success', successMessage, {
                container: document.querySelector('.main-content'),
                position: 'top',
                duration: 3000
            });
            
        } catch (error) {
            console.error('Export error:', error);
            
            createInlineMessage('error', 'Error creating export: ' + error.message, {
                container: document.querySelector('.main-content'),
                position: 'top',
                duration: 5000
            });
        }
    }

    // Import dreams from text file (with optional decryption)
    async function importEntries(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        try {
            // Check if encryption is enabled
            const encryptionEnabled = document.getElementById('encryptionEnabled').checked;
            const isEncryptedFile = file.name.endsWith('.enc');
            
            // Read file as appropriate type
            const fileData = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                
                if (encryptionEnabled || isEncryptedFile) {
                    reader.readAsArrayBuffer(file);
                } else {
                    reader.readAsText(file);
                }
            });
            
            let text = '';
            
            // Handle encrypted files
            if (encryptionEnabled || isEncryptedFile) {
                if (typeof fileData === 'string') {
                    throw new Error('Selected file appears to be unencrypted. Uncheck encryption or select an encrypted (.enc) file.');
                }
                
                // Show password dialog
                const password = await showPasswordDialog({
                    type: 'import',
                    title: '🔓 Enter Import Password',
                    description: 'Enter the password used to encrypt this dream export file.',
                    requireConfirm: false,
                    primaryButtonText: 'Decrypt & Import'
                });
                
                if (!password) {
                    // User cancelled
                    event.target.value = ''; // Clear file input
                    return;
                }
                
                try {
                    // Decrypt the data
                    text = await decryptData(new Uint8Array(fileData), password);
                } catch (decryptError) {
                    throw new Error('Failed to decrypt file. Please check your password and try again.');
                }
            } else {
                // Handle unencrypted files
                if (typeof fileData !== 'string') {
                    throw new Error('Selected file appears to be encrypted. Check encryption option or select a text (.txt) file.');
                }
                text = fileData;
            }
            
            // Process the decrypted/plain text
            const dreams = await loadDreams();
            
            // Simple parsing - this could be enhanced based on export format
            const entriesRaw = text.split('='.repeat(50));
            let importedCount = 0;
            let skippedCount = 0;
            
            entriesRaw.forEach((entry, index) => {
                try {
                    const lines = entry.trim().split('\n').filter(line => line.trim()); // Remove empty lines
                    if (lines.length < 3) return; // Not enough data
                    
                    const title = lines[0].replace('Title: ', '').trim();
                    if (!title) return; // Skip entries without titles
                    
                    // Check if this is new format (timestamp) or old format (date string)
                    let timestamp = null;
                    let typeLineIndex = 2;
                    
                    if (lines[1] && lines[1].startsWith('Timestamp: ')) {
                        // New format - extract timestamp directly
                        timestamp = lines[1].replace('Timestamp: ', '').trim();
                        typeLineIndex = 2;
                    } else if (lines[1] && lines[1].startsWith('Date: ')) {
                        // Old format - try to parse the display date
                        const dateStr = lines[1].replace('Date: ', '').trim();
                        try {
                            const parsed = new Date(dateStr);
                            if (!isNaN(parsed.getTime())) {
                                timestamp = parsed.toISOString();
                            }
                        } catch (e) {
                            // Continue with fallback
                        }
                        
                        // Check if there's also a timestamp line (mixed format)
                        if (lines[2] && lines[2].startsWith('Timestamp: ')) {
                            timestamp = lines[2].replace('Timestamp: ', '').trim();
                            typeLineIndex = 3;
                        }
                    }
                    
                    // Fallback to current time if no valid timestamp
                    if (!timestamp) {
                        timestamp = new Date().toISOString();
                    }
                    
                    // Validate timestamp
                    const testDate = new Date(timestamp);
                    if (isNaN(testDate.getTime())) {
                        timestamp = new Date().toISOString();
                    }
                    
                    // Check for lucid status, emotions, tags, and dream signs
                    let isLucid = false;
                    let emotions = '';
                    let tags = [];
                    let dreamSigns = [];
                    let contentStartIndex = typeLineIndex;
                    
                    // Look for Type line
                    if (lines[typeLineIndex] && lines[typeLineIndex].includes('Type:')) {
                        isLucid = lines[typeLineIndex].includes('Lucid Dream') || lines[typeLineIndex].includes('✨');
                        contentStartIndex = typeLineIndex + 1;
                    }
                    
                    // Look for Emotions line
                    if (lines[contentStartIndex] && lines[contentStartIndex].startsWith('Emotions:')) {
                        emotions = lines[contentStartIndex].replace('Emotions:', '').trim();
                        contentStartIndex = contentStartIndex + 1;
                    }
                    
                    // Look for Tags line
                    if (lines[contentStartIndex] && lines[contentStartIndex].startsWith('Tags:')) {
                        const tagsText = lines[contentStartIndex].replace('Tags:', '').trim();
                        tags = parseTagsFromInput(tagsText);
                        contentStartIndex = contentStartIndex + 1;
                    }
                    
                    // Look for Dream Signs line
                    if (lines[contentStartIndex] && lines[contentStartIndex].startsWith('Dream Signs:')) {
                        const dreamSignsText = lines[contentStartIndex].replace('Dream Signs:', '').trim();
                        dreamSigns = parseTagsFromInput(dreamSignsText);
                        contentStartIndex = contentStartIndex + 1;
                    }
                    
                    const content = lines.slice(contentStartIndex)
                        .join('\n')
                        .replace(/^Content:\s*/, '') // Remove "Content:" prefix
                        .trim();
                    
                    if (!title || !content) return; // Skip entries without required data
                    
                    // Generate display date from timestamp
                    const timestampDate = new Date(timestamp);
                    const dateString = timestampDate.toLocaleDateString('en-AU', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    
                    const newDream = {
                        id: generateUniqueId(),
                        title: title,
                        content: content,
                        emotions: emotions, // Include emotions in imported dreams
                        tags: tags, // Include tags in imported dreams
                        dreamSigns: dreamSigns, // Include dream signs in imported dreams
                        isLucid: Boolean(isLucid),
                        timestamp: timestamp,
                        dateString: dateString
                    };
                    
                    // Validate the dream data before proceeding
                    if (validateDreamData(newDream)) {
                        // Check for duplicates before adding
                        if (isDreamDuplicate(dreams, newDream)) {
                            skippedCount++;
                        } else {
                            dreams.unshift(newDream);
                            importedCount++;
                        }
                    }
                } catch (entryError) {
                    // Skip invalid entries silently
                }
            });
            
            try {
                await saveDreams(dreams);
                await displayDreams();
                
                // Show success message with import stats
                const container = document.querySelector('.main-content');
                if (container) {
                    const msg = document.createElement('div');
                    msg.className = importedCount > 0 ? 'message-success' : 'message-error';
                    
                    let messageText = '';
                    const fileType = encryptionEnabled || isEncryptedFile ? 'encrypted' : 'standard';
                    
                    if (importedCount > 0 && skippedCount > 0) {
                        messageText = `${fileType === 'encrypted' ? 'Encrypted import' : 'Import'} complete! Added ${importedCount} new dreams, skipped ${skippedCount} duplicates.`;
                    } else if (importedCount > 0) {
                        messageText = `Successfully imported ${importedCount} dreams from ${fileType} file!`;
                    } else if (skippedCount > 0) {
                        messageText = `Import complete! All ${skippedCount} dreams were already in your journal.`;
                    } else {
                        messageText = 'No valid dreams found in the file.';
                    }
                    
                    msg.textContent = messageText;
                    container.insertBefore(msg, container.firstChild);
                    
                    setTimeout(() => {
                        try {
                            if (msg && msg.parentNode) {
                                msg.remove();
                            }
                        } catch (e) {
                            // Ignore cleanup errors
                        }
                    }, 5000);
                }
            } catch (error) {
                throw new Error('Failed to save imported dreams: ' + error.message);
            }
        } catch (error) {
            console.error('Import error:', error);
            
            createInlineMessage('error', 'Import error: ' + error.message, {
                container: document.querySelector('.main-content'),
                position: 'top',
                duration: 5000
            });
        } finally {
            // Clear the file input
            event.target.value = '';
        }
    }

    // Export ALL application data to JSON file (with optional password protection)
    async function exportAllData() {
        // Check if app is locked
        if (isAppLocked || (isPinSetup() && !isUnlocked)) {
            switchAppTab('lock');
            setTimeout(() => {
                showLockScreenMessage('error', 'Please unlock your journal first to export all data.');
            }, 500);
            return;
        }
        
        try {
            // Collect all data from all sources
            const [dreams, voiceNotes, goals] = await Promise.all([
                loadDreams(),
                loadVoiceNotes(), 
                loadGoals()
            ]);
            
            // Collect settings from localStorage
            const settings = {
                theme: getCurrentTheme(),
                storageType: storageType,
                // Note: PIN data is intentionally NOT exported for security
            };
            
            // Create comprehensive export object
            const exportData = {
                version: "v1.43.10", // Updated version
                exportDate: new Date().toISOString(),
                exportType: "complete",
                data: {
                    dreams: dreams || [],
                    voiceNotes: (voiceNotes || []).map(note => ({
                        // Convert voice notes to exportable format (without blob data)
                        id: note.id,
                        timestamp: note.timestamp,
                        duration: note.duration,
                        transcription: note.transcription || '',
                        // Note: Audio blob data is not exported due to size and format limitations
                        hasAudio: !!note.audioBlob
                    })),
                    goals: goals || [],
                    settings: settings,
                    metadata: {
                        totalDreams: (dreams || []).length,
                        totalVoiceNotes: (voiceNotes || []).length,
                        totalGoals: (goals || []).length,
                        lucidDreams: (dreams || []).filter(d => d.isLucid).length,
                    }
                }
            };
            
            if (exportData.data.dreams.length === 0 && exportData.data.goals.length === 0) {
                createInlineMessage('error', 'No data to export yet. Create some dreams or goals first!', {
                    container: document.querySelector('.main-content'),
                    position: 'top',
                    duration: 3000
                });
                return;
            }
            
            const jsonData = JSON.stringify(exportData, null, 2);
            
            // Check if encryption is enabled
            const encryptionEnabled = document.getElementById('fullDataEncryption').checked;
            let finalData = jsonData;
            let fileName = `dream-journal-complete-${new Date().toISOString().split('T')[0]}.json`;
            let mimeType = 'application/json';
            
            if (encryptionEnabled) {
                // Show password dialog
                const password = await showPasswordDialog({
                    type: 'export',
                    title: '🔐 Set Complete Export Password',
                    description: 'Choose a password to encrypt your complete data export. This includes all dreams, goals, and settings. Remember this password for importing!',
                    requireConfirm: true,
                    primaryButtonText: 'Encrypt & Export'
                });
                
                if (!password) {
                    return; // User cancelled
                }
                
                // Encrypt the data
                const encryptedData = await encryptData(jsonData, password);
                finalData = encryptedData;
                fileName = `dream-journal-complete-${new Date().toISOString().split('T')[0]}.enc`;
                mimeType = 'application/octet-stream';
            }
            
            // Create and download file
            const blob = new Blob([finalData], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.style.display = 'none';
            
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                if (document.body.contains(a)) {
                    document.body.removeChild(a);
                }
                URL.revokeObjectURL(url);
            }, CONSTANTS.DOWNLOAD_CLEANUP_DELAY_MS);
            
            // Show success message with export stats
            const stats = exportData.data.metadata;
            const successMessage = encryptionEnabled ? 
                `Encrypted complete export created! (${stats.totalDreams} dreams, ${stats.totalGoals} goals)` : 
                `Complete export created! (${stats.totalDreams} dreams, ${stats.totalGoals} goals)`;
                
            createInlineMessage('success', successMessage, {
                container: document.querySelector('.main-content'),
                position: 'top',
                duration: 4000
            });
            
        } catch (error) {
            console.error('Complete export error:', error);
            createInlineMessage('error', 'Error creating complete export: ' + error.message, {
                container: document.querySelector('.main-content'),
                position: 'top',
                duration: 5000
            });
        }
    }

    // Import ALL application data from JSON file (with merge/overwrite options)
    async function importAllData(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        try {
            // Check if encryption is enabled
            const encryptionEnabled = document.getElementById('fullDataEncryption').checked;
            const isEncryptedFile = file.name.endsWith('.enc');
            
            // Read file
            const fileData = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                
                if (encryptionEnabled || isEncryptedFile) {
                    reader.readAsArrayBuffer(file);
                } else {
                    reader.readAsText(file);
                }
            });
            
            let text = '';
            
            // Handle encrypted files
            if (encryptionEnabled || isEncryptedFile) {
                if (typeof fileData === 'string') {
                    throw new Error('Selected file appears to be unencrypted. Uncheck encryption or select an encrypted (.enc) file.');
                }
                
                // Show password dialog
                const password = await showPasswordDialog({
                    type: 'import',
                    title: '🔓 Enter Complete Import Password',
                    description: 'Enter the password used to encrypt this complete data export file.',
                    requireConfirm: false,
                    primaryButtonText: 'Decrypt & Import'
                });
                
                if (!password) {
                    event.target.value = '';
                    return;
                }
                
                try {
                    text = await decryptData(new Uint8Array(fileData), password);
                } catch (decryptError) {
                    throw new Error('Failed to decrypt file. Please check your password and try again.');
                }
            } else {
                if (typeof fileData !== 'string') {
                    throw new Error('Selected file appears to be encrypted. Check encryption option or select a JSON (.json) file.');
                }
                text = fileData;
            }
            
            // Parse JSON data
            const importData = JSON.parse(text);
            
            // Validate import data structure
            if (!importData.data || (!importData.data.dreams && !importData.data.goals)) {
                throw new Error('Invalid import file format. No dreams or goals data found.');
            }
            
            const stats = { importedDreams: 0, importedGoals: 0, skippedDreams: 0, skippedGoals: 0 };
            
            // Import dreams with duplicate checking
            if (importData.data.dreams && Array.isArray(importData.data.dreams)) {
                const currentDreams = await loadDreams();
                const importDreams = importData.data.dreams;
                
                // Filter out duplicates based on title and content similarity
                const newDreams = importDreams.filter(importDream => {
                    const isDuplicate = currentDreams.some(existingDream => {
                        return existingDream.title === importDream.title &&
                               existingDream.content === importDream.content;
                    });
                    
                    if (isDuplicate) {
                        stats.skippedDreams++;
                        return false;
                    } else {
                        stats.importedDreams++;
                        // Ensure imported dream has required fields
                        if (!importDream.id) importDream.id = generateUniqueId();
                        if (!importDream.timestamp) importDream.timestamp = new Date().toISOString();
                        if (!importDream.dateString) {
                            const date = new Date(importDream.timestamp);
                            importDream.dateString = date.toLocaleDateString('en-AU', {
                                year: 'numeric',
                                month: 'long', 
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                        }
                        return true;
                    }
                });
                
                // Add new dreams
                if (newDreams.length > 0) {
                    const mergedDreams = [...currentDreams, ...newDreams];
                    await saveDreams(mergedDreams);
                }
            }
            
            // Import goals with duplicate checking
            if (importData.data.goals && Array.isArray(importData.data.goals)) {
                const currentGoals = await loadGoals();
                const importGoals = importData.data.goals;
                
                // Filter out duplicates based on title and description
                const newGoals = importGoals.filter(importGoal => {
                    const isDuplicate = currentGoals.some(existingGoal => {
                        return existingGoal.title === importGoal.title &&
                               existingGoal.description === importGoal.description;
                    });
                    
                    if (isDuplicate) {
                        stats.skippedGoals++;
                        return false;
                    } else {
                        stats.importedGoals++;
                        // Ensure imported goal has required fields
                        if (!importGoal.id) importGoal.id = generateUniqueId();
                        if (!importGoal.createdAt) importGoal.createdAt = new Date().toISOString();
                        return true;
                    }
                });
                
                // Add new goals
                if (newGoals.length > 0) {
                    const mergedGoals = [...currentGoals, ...newGoals];
                    await saveGoals(mergedGoals);
                }
            }
            
            // Refresh all displays
            await Promise.all([
                displayDreams(),
                displayGoals()
            ]);
            
            // Show success message with import statistics
            const totalImported = stats.importedDreams + stats.importedGoals;
            const totalSkipped = stats.skippedDreams + stats.skippedGoals;
            
            let message = '';
            if (totalImported > 0 && totalSkipped > 0) {
                message = `Complete import finished! Added ${stats.importedDreams} dreams and ${stats.importedGoals} goals, skipped ${totalSkipped} duplicates.`;
            } else if (totalImported > 0) {
                message = `Successfully imported ${stats.importedDreams} dreams and ${stats.importedGoals} goals!`;
            } else if (totalSkipped > 0) {
                message = `Import complete! All ${totalSkipped} items were already in your journal.`;
            } else {
                message = 'No new data found in the import file.';
            }
            
            createInlineMessage('success', message, {
                container: document.querySelector('.main-content'),
                position: 'top',
                duration: 5000
            });
            
        } catch (error) {
            console.error('Complete import error:', error);
            createInlineMessage('error', 'Complete import error: ' + error.message, {
                container: document.querySelector('.main-content'),
                position: 'top',
                duration: 5000
            });
        } finally {
            event.target.value = '';
        }
    }

    // Export dreams formatted for AI analysis
    async function exportForAIAnalysis() {
        // Check if app is locked
        if (isAppLocked || (isPinSetup() && !isUnlocked)) {
            switchAppTab('lock');
            setTimeout(() => {
                showLockScreenMessage('error', 'Please unlock your journal first to export for analysis.');
            }, 500);
            return;
        }
        
        const { searchTerm, filterType, sortType, startDate, endDate } = getFilterValues();
        const allDreams = await loadDreams();
        
        // Apply same filtering as display
        let dreams = filterDreams(allDreams, searchTerm, filterType, startDate, endDate);
        
        // Apply same sorting as display for consistency
        dreams.sort((a, b) => {
            switch (sortType) {
                case 'oldest':
                    return new Date(a.timestamp) - new Date(b.timestamp);
                
                case 'lucid-first':
                    if (a.isLucid && !b.isLucid) return -1;
                    if (!a.isLucid && b.isLucid) return 1;
                    return new Date(b.timestamp) - new Date(a.timestamp);
                
                case 'longest':
                    return b.content.length - a.content.length;
                
                case 'newest':
                default:
                    return new Date(b.timestamp) - new Date(a.timestamp);
            }
        });
        
        if (dreams.length === 0) {
            const filterText = filterType === 'all' ? '' : 
                filterType === 'lucid' ? ' lucid' : ' non-lucid';
            
            const noResultsMessage = `No${filterText} dreams to export for analysis${searchTerm ? ' matching your search' : ''}. ${filterType === 'lucid' ? 'Try recording some lucid dreams first!' : 'Record some dreams first!'}`;
            
            createInlineMessage('error', noResultsMessage, {
                container: document.querySelector('.main-content'),
                position: 'top',
                duration: 5000
            });
            return;
        }
        
        try {
            // Performance optimization: Limit analysis to most recent dreams based on size
            const maxDreams = dreams.length > CONSTANTS.AI_ANALYSIS_THRESHOLD ? CONSTANTS.AI_ANALYSIS_RECENT_LIMIT : CONSTANTS.AI_ANALYSIS_TOTAL_LIMIT;
            const recentDreams = dreams.slice(0, maxDreams);
            
            // Format dreams for AI analysis
            const dreamTexts = recentDreams.map(dream => {
                const lucidStatus = dream.isLucid ? '[LUCID DREAM]' : '[REGULAR DREAM]';
                const date = new Date(dream.timestamp).toLocaleDateString();
                const emotions = dream.emotions ? ` [EMOTIONS: ${dream.emotions}]` : '';
                const tags = Array.isArray(dream.tags) && dream.tags.length > 0 ? ` [TAGS: ${dream.tags.join(', ')}]` : '';
                const dreamSigns = Array.isArray(dream.dreamSigns) && dream.dreamSigns.length > 0 ? ` [DREAM SIGNS: ${dream.dreamSigns.join(', ')}]` : '';
                return `${lucidStatus}${emotions}${tags}${dreamSigns} ${date} - ${dream.title}: ${dream.content}`;
            }).join('\n\n');
            
            const totalDreams = dreams.length;
            const lucidCount = dreams.filter(d => d.isLucid).length;
            const lucidPercentage = totalDreams > 0 ? ((lucidCount / totalDreams) * 100).toFixed(1) : 0;
            
            // Create the full AI analysis prompt
            const aiAnalysisPrompt = `Analyze these dream journal entries for patterns, themes, and insights. The user has ${totalDreams} total dreams with ${lucidCount} lucid dreams (${lucidPercentage}% lucid rate). Each entry includes emotions, general tags/themes, and dream signs (specific lucidity triggers) when available.

${dreamTexts}

Please provide a comprehensive analysis including:

1. **Dream Patterns & Themes**: What recurring elements, settings, characters, or situations appear across dreams? How do the user's tags reveal their most common dream themes?

2. **Dream Signs Analysis**: What specific dream signs appear most frequently? Which dream signs correlate with lucid dreams vs regular dreams? What are the user's strongest personal lucidity triggers?

3. **Emotional Patterns**: What emotional themes emerge across dreams? How do emotions correlate with dream content, lucidity, or timing? Are there emotional triggers or patterns?

4. **Tag-Based Insights**: What do the user's tags reveal about their dream world? Are there tag patterns that correlate with lucidity, emotions, or specific time periods?

5. **Lucid Dream Analysis**: What triggers or signs indicate increased lucidity? How do tagged elements, emotions, and dream signs work together to create lucid experiences?

6. **Symbolic Interpretation**: What symbols or metaphors appear frequently and what might they represent? How do emotions and tags connect to symbolic content?

7. **Practical Recommendations**: Specific techniques to improve dream recall, increase lucidity recognition, or work with recurring themes. How can the user leverage their personal dream signs for better lucidity?

8. **Sleep & Dream Quality**: Any observations about dream complexity, vividness, timing patterns, and emotional intensity based on the available data?

Make the analysis personal, insightful, and actionable. Focus on helping the user understand their unique dream patterns, recurring dream signs, emotional landscapes, and how to enhance their lucid dreaming practice using their personal data.

${recentDreams.length < totalDreams ? `\n(Note: Analysis based on ${recentDreams.length} most recent dreams of ${totalDreams} total)` : ''}`;
            
            // Create and download the analysis prompt file
            const blob = new Blob([aiAnalysisPrompt], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dream-analysis-prompt-${new Date().toISOString().split('T')[0]}.txt`;
            a.style.display = 'none';
            
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                if (document.body.contains(a)) {
                    document.body.removeChild(a);
                }
                URL.revokeObjectURL(url);
            }, 3000);
            
            // Show success message
            const analysisMessage = `AI analysis prompt created! (${recentDreams.length} dreams, ${lucidPercentage}% lucid rate)`;
            
            createInlineMessage('success', analysisMessage, {
                container: document.querySelector('.main-content'),
                position: 'top',
                duration: 4000
            });
            
        } catch (error) {
            console.error('AI analysis export error:', error);
            createInlineMessage('error', 'Error creating AI analysis: ' + error.message, {
                container: document.querySelector('.main-content'),
                position: 'top',
                duration: 5000
            });
        }
    }


    // --- 5.6 Security & PIN Logic ---
    // --- Paste all functions related to PIN setup, verification, recovery, and encryption here --- //


    // ===================================================================================
    // SECTION 6: EVENT HANDLERS & ACTION ROUTING
    // ===================================================================================

    // --- Paste the ACTION_MAP, routeAction, and main event handlers (handleUnifiedClick, etc.) here --- //


    // ===================================================================================
    // SECTION 7: INITIALIZATION
    // ===================================================================================

    // --- Paste the setupEventDelegation function and the 'DOMContentLoaded' event listener here --- //



        // All your existing JavaScript code goes inside here
        
        // Global state variables moved to SECTION 2
        
        
        
        
        
        
        
        // DOM Helper Functions moved to SECTION 3
        
        // Function moved to SECTION 3
        
        // Function moved to SECTION 3
        
        // Function moved to SECTION 3
        
        // HTML escape function to prevent XSS
        function escapeHtml(text) {
            if (text == null) return '';
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }

        // HTML escape for attributes (quotes and special chars)
        function escapeAttr(text) {
            if (text == null) return '';
            return String(text).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        }
        
        // Database constants moved to SECTION 4
        
        let preLockActiveTab = 'journal'; // Remember which tab was active before locking
        

        // MOVE TO: SECTION 1 - Daily tips content array
        // DUPLICATE REMOVED - dailyTips now in SECTION 1
        
        // Duplicate dailyTips array removed - now in SECTION 1
        // Duplicate dailyTips array removed - now properly located in SECTION 1
        
        
        // Function moved to SECTION 5.3
        
        // Function moved to SECTION 5.3
        
        // Function moved to SECTION 3
        
        // Functions moved to SECTION 5.3
        
        // Function moved to SECTION 5.3
        
        // Function moved to SECTION 5.3
        
        // Functions moved to SECTION 5.4
        
        // Functions moved to SECTION 5.4
        
        // Functions moved to SECTION 5.3
        
        // Functions moved to SECTION 5.3

        // Functions moved to SECTION 5.4

        // Functions moved to SECTION 3

        // MOVE TO: SECTION 7 - Advice tab initialization
        function initializeAdviceTab() {
            // Calculate tip of the day using a fixed epoch
            const epoch = new Date('1900-01-01T00:00:00Z');
            const now = new Date();
            const diffTime = now - epoch;
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

            if (dailyTips && dailyTips.length > 0) {
                const tipOfTheDayIndex = diffDays % dailyTips.length;
                displayTip(tipOfTheDayIndex);
            }
        }

        // Functions moved to SECTION 3
        
        // MOVE TO: SECTION 7 - Theme initialization
        // Initialize theme on page load
        function initializeTheme() {
            const savedTheme = getCurrentTheme();
            applyTheme(savedTheme);
        }
        
        // MOVE TO: SECTION 6 - Event handling and action routing
        // CENTRALIZED ACTION SYSTEM & EVENT DELEGATION
        
        // MOVE TO: SECTION 6 - Action context extraction utility
        // Extract action context from clicked element
        function extractActionContext(target) {
            let actionElement = target;
            let action = actionElement.dataset.action;
            
            // Find element with data-action (traverse up to 3 levels)
            if (!action) {
                for (let i = 0; i < CONSTANTS.DOM_TRAVERSAL_LEVELS && actionElement.parentElement; i++) {
                    actionElement = actionElement.parentElement;
                    action = actionElement.dataset.action;
                    if (action) {
                        break;
                    }
                }
            }
            
            if (!action) {
                return null;
            }
            
            // Extract all possible data attributes
            return {
                action,
                element: actionElement,
                dreamId: actionElement.dataset.dreamId,
                voiceNoteId: actionElement.dataset.voiceNoteId,
                goalId: actionElement.dataset.goalId,
                page: actionElement.dataset.page,
                type: actionElement.dataset.type,
                originalTarget: target
            };
        }
        
        // MOVE TO: SECTION 6 - Central action routing map
        // Comprehensive action map - maps all current actions to their handlers
        const ACTION_MAP = {
            // Main container actions
            'export-dreams': () => exportEntries(),
            'import-dreams': () => document.getElementById('importFile').click(),
            'export-all-data': () => exportAllData(),
            'import-all-data': () => document.getElementById('importAllDataFile').click(),
            'export-ai': () => exportForAIAnalysis(),
            'toggle-lock': () => toggleLock(), // Always visible, handles PIN setup if needed
            'setup-pin': () => showPinSetup(),
            'process-pin-setup': () => setupPin(),
            'save-dream': () => saveDream(),
            'toggle-recording': () => toggleRecording(),
            'toggle-dream-form': () => toggleDreamForm(),
            'switch-voice-tab': (ctx) => switchVoiceTab(ctx.element.dataset.tab),
            'switch-app-tab': (ctx) => switchAppTab(ctx.element.dataset.tab),
            'switch-theme': (ctx) => switchTheme(ctx.element.value),
            'show-pin-overlay': () => showPinOverlay(),
            'create-from-transcription': (ctx) => createDreamFromTranscription(ctx.voiceNoteId),
            'cancel-timer': () => cancelResetTimer(),
            
            // Goal management actions
            'create-goal': () => showCreateGoalDialog(),
            'create-template-goal': (ctx) => createTemplateGoal(ctx.element.dataset.template),
            'edit-goal': (ctx) => editGoal(ctx.goalId),
            'complete-goal': (ctx) => completeGoal(ctx.goalId),
            'reactivate-goal': (ctx) => reactivateGoal(ctx.goalId),
            'delete-goal': (ctx) => deleteGoal(ctx.goalId),
            'confirm-delete-goal': (ctx) => confirmDeleteGoal(ctx.goalId),
            'save-goal': () => saveGoal(),
            'cancel-goal-dialog': () => cancelGoalDialog(),
            'increase-goal-progress': (ctx) => increaseGoalProgress(ctx.goalId),
            'decrease-goal-progress': (ctx) => decreaseGoalProgress(ctx.goalId),
            'active-goals-page': (ctx) => changeActiveGoalsPage(parseInt(ctx.page)),
            'completed-goals-page': (ctx) => changeCompletedGoalsPage(parseInt(ctx.page)),
            
            // Password dialog actions (CRITICAL BUG FIX #1)
            'confirm-export-password': () => confirmExportPassword(),
            'cancel-export-password': () => cancelExportPassword(),
            'confirm-import-password': () => confirmImportPassword(),
            'cancel-import-password': () => cancelImportPassword(),
            
            // Voice container actions
            'play-voice': (ctx) => playVoiceNote(ctx.voiceNoteId),
            'pause-voice': (ctx) => pauseVoiceNote(ctx.voiceNoteId),
            'transcribe-voice': (ctx) => transcribeVoiceNote(ctx.voiceNoteId),
            'download-voice': (ctx) => downloadVoiceNote(ctx.voiceNoteId),
            'delete-voice': (ctx) => deleteVoiceNote(ctx.voiceNoteId),
            'confirm-delete-voice': (ctx) => confirmDeleteVoiceNote(ctx.voiceNoteId),
            'seek-audio': (ctx) => seekAudio(ctx.voiceNoteId, ctx.event),
            
            // Entries container actions
            'edit-dream': (ctx) => editDream(ctx.dreamId),
            'delete-dream': (ctx) => deleteDream(ctx.dreamId),
            'confirm-delete': (ctx) => confirmDelete(ctx.dreamId),
            'save-edit': (ctx) => saveDreamEdit(ctx.dreamId),
            'cancel-edit': (ctx) => cancelDreamEdit(ctx.dreamId),
            
            // Pagination actions
            'go-to-page': (ctx) => goToPage(parseInt(ctx.page)),

            // Calendar actions
            'prev-month': () => {
                calendarState.date.setMonth(calendarState.date.getMonth() - 1);
                renderCalendar(calendarState.date.getFullYear(), calendarState.date.getMonth());
            },
            'next-month': () => {
                calendarState.date.setMonth(calendarState.date.getMonth() + 1);
                renderCalendar(calendarState.date.getFullYear(), calendarState.date.getMonth());
            },
            'select-month': (ctx) => {
                const newMonth = parseInt(ctx.element.value);
                renderCalendar(calendarState.date.getFullYear(), newMonth);
            },
            'select-year': (ctx) => {
                const newYear = parseInt(ctx.element.value);
                renderCalendar(newYear, calendarState.date.getMonth());
            },
            'go-to-date': (ctx) => {
                const date = ctx.element.dataset.date;
                if(date) {
                    const startDateInput = document.getElementById('startDateFilter');
                    const endDateInput = document.getElementById('endDateFilter');
                    if(startDateInput && endDateInput) {
                        startDateInput.value = date;
                        endDateInput.value = date;
                        switchAppTab('journal');
                        debouncedFilter();
                    }
                }
            },
            
            // Document-level actions (PIN overlay, password dialogs, etc.)
            'verify-pin': () => verifyPin(),
            'hide-pin-overlay': () => hidePinOverlay(),
            'confirm-password': () => confirmPassword(),
            'cancel-password': () => cancelPassword(),
            'show-pin-setup': () => showPinSetup(),
            'show-remove-pin': () => showRemovePin(),
            'show-forgot-pin': () => showForgotPin(),
            'confirm-remove-pin': () => confirmRemovePin(),
            'execute-pin-removal': () => executePinRemoval(),
            'complete-pin-removal': () => completePinRemoval(),
            'start-title-recovery': () => startTitleRecovery(),
            'verify-dream-titles': () => verifyDreamTitles(),
            'start-timer-recovery': () => startTimerRecovery(),
            'confirm-start-timer': () => confirmStartTimer(),
            'confirm-cancel-timer': () => confirmCancelTimer(),
            'restore-warning-banner': () => restoreWarningBanner(),
            'complete-recovery': () => completeRecovery(),
            'complete-pin-setup': () => completePinSetup(),
            'show-set-new-pin-screen': () => showSetNewPinScreen(),
            'setup-new-pin': () => setupNewPin(),
            'confirm-new-pin': () => confirmNewPin(),
            
            // Lock screen actions
            'verify-lock-screen-pin': () => verifyLockScreenPin(),
            'show-lock-screen-forgot-pin': () => showLockScreenForgotPin(),
            'start-lock-screen-title-recovery': () => startLockScreenTitleRecovery(),
            'start-lock-screen-timer-recovery': () => startLockScreenTimerRecovery(),
            'return-to-lock-screen': () => returnToLockScreen(),
            'verify-lock-screen-dream-titles': () => verifyLockScreenDreamTitles(),
            'confirm-lock-screen-timer': () => confirmLockScreenTimer(),
            
            // Autocomplete management actions
            'add-custom-tag': () => addCustomAutocompleteItem('tags'),
            'add-custom-dream-sign': () => addCustomAutocompleteItem('dreamSigns'),
            'delete-autocomplete-item': (ctx) => deleteAutocompleteItem(ctx.element.dataset.itemType, ctx.element.dataset.itemId),
            'restore-default-item': (ctx) => restoreDefaultItem(ctx.element.dataset.itemType, ctx.element.dataset.itemId),

            // Stats tab actions
            'switch-stats-tab': (ctx) => switchStatsTab(ctx.element.dataset.tab),

            // Advice tab actions
            'prev-tip': () => handleTipNavigation('prev'),
            'next-tip': () => handleTipNavigation('next')
        };
        
        // Function moved to SECTION 5.4
        
        // Sync settings display
        function syncSettingsDisplay() {
            // Sync PIN buttons
            const setupBtnSettings = document.getElementById('setupPinBtnSettings');
            const lockBtnSettings = document.getElementById('lockBtnSettings');
            
            if (setupBtnSettings && lockBtnSettings) {
                if (isPinSetup()) {
                    if (isUnlocked) {
                        lockBtnSettings.style.display = 'inline-block';
                        lockBtnSettings.textContent = '🔒 Lock';
                        setupBtnSettings.textContent = '⚙️ Change/Remove PIN';
                    } else {
                        lockBtnSettings.style.display = 'none';
                        setupBtnSettings.textContent = '⚙️ Change/Remove PIN';
                    }
                } else {
                    lockBtnSettings.style.display = 'none';
                    setupBtnSettings.textContent = '⚙️ Setup PIN';
                }
            }
            
            // Sync encryption checkbox
            const encryptionOriginal = document.getElementById('encryptionEnabled');
            const encryptionSettings = document.getElementById('encryptionEnabledSettings');
            
            if (encryptionOriginal && encryptionSettings) {
                encryptionSettings.checked = encryptionOriginal.checked;
                
                // Add sync event listeners
                encryptionSettings.addEventListener('change', function() {
                    encryptionOriginal.checked = this.checked;
                });
                
                encryptionOriginal.addEventListener('change', function() {
                    encryptionSettings.checked = this.checked;
                });
            }
            
            // Sync theme select - enhanced
            const themeSelect = document.getElementById('themeSelect');
            if (themeSelect) {
                const currentTheme = getCurrentTheme();
                themeSelect.value = currentTheme;
                
                // Double-check the value was set correctly
                if (themeSelect.value !== currentTheme) {
                    console.log('Theme select sync issue, forcing update');
                    setTimeout(() => {
                        const themeSelectDelayed = document.getElementById('themeSelect');
                        if (themeSelectDelayed) {
                            themeSelectDelayed.value = currentTheme;
                        }
                    }, 50);
                }
            }
            
            // Update storage info
            const storageTypeElement = document.getElementById('storageTypeDisplay');
            const storageStatusElement = document.getElementById('storageStatusDisplay');
            
            if (storageTypeElement && storageStatusElement) {
                switch (storageType) {
                    case 'indexeddb':
                        storageTypeElement.textContent = 'Data stored in IndexedDB (recommended)';
                        storageStatusElement.textContent = '💾 IndexedDB';
                        storageStatusElement.style.color = 'var(--success-color)';
                        break;
                    case 'localstorage':
                        storageTypeElement.textContent = 'Data stored in localStorage';
                        storageStatusElement.textContent = '📱 LocalStorage';
                        storageStatusElement.style.color = 'var(--info-color)';
                        break;
                    case 'memory':
                        storageTypeElement.textContent = 'Data stored temporarily in memory only';
                        storageStatusElement.textContent = '⚠️ Memory Only';
                        storageStatusElement.style.color = 'var(--warning-color)';
                        break;
                    default:
                        storageTypeElement.textContent = 'Storage type unknown';
                        storageStatusElement.textContent = '❓ Unknown';
                        storageStatusElement.style.color = 'var(--text-secondary)';
                }
            }
            
            // Update browser compatibility info
            updateBrowserCompatibilityDisplay();
        }
        
        // Update browser compatibility display in settings
        function updateBrowserCompatibilityDisplay() {
            const voiceCapabilities = getVoiceCapabilities();
            
            // Voice Recording Status
            const voiceRecordingCompatibility = document.getElementById('voiceRecordingCompatibility');
            const voiceRecordingStatus = document.getElementById('voiceRecordingStatus');
            
            if (voiceRecordingCompatibility && voiceRecordingStatus) {
                if (voiceCapabilities.canRecord) {
                    voiceRecordingCompatibility.textContent = 'Your browser supports voice recording';
                    voiceRecordingStatus.textContent = '✅ Supported';
                    voiceRecordingStatus.style.color = 'var(--success-color)';
                } else {
                    if (voiceCapabilities.browser.isSafariMobile) {
                        voiceRecordingCompatibility.textContent = 'Safari iOS has limited MediaRecorder support';
                    } else {
                        voiceRecordingCompatibility.textContent = 'Voice recording not supported in this browser';
                    }
                    voiceRecordingStatus.textContent = '❌ Not Supported';
                    voiceRecordingStatus.style.color = 'var(--error-color)';
                }
            }
            
            // Transcription Status
            const transcriptionCompatibility = document.getElementById('transcriptionCompatibility');
            const transcriptionStatus = document.getElementById('transcriptionStatus');
            
            if (transcriptionCompatibility && transcriptionStatus) {
                if (voiceCapabilities.canTranscribe) {
                    transcriptionCompatibility.textContent = 'Your browser supports speech transcription';
                    transcriptionStatus.textContent = '✅ Supported';
                    transcriptionStatus.style.color = 'var(--success-color)';
                } else {
                    if (voiceCapabilities.browser.isFirefox) {
                        transcriptionCompatibility.textContent = 'Firefox does not support Speech Recognition API';
                    } else if (voiceCapabilities.browser.isSafari) {
                        transcriptionCompatibility.textContent = 'Safari does not support Speech Recognition API';
                    } else {
                        transcriptionCompatibility.textContent = 'Speech Recognition API not available in this browser';
                    }
                    transcriptionStatus.textContent = '❌ Not Supported';
                    transcriptionStatus.style.color = 'var(--error-color)';
                }
            }
        }
        
        // Switch voice notes tabs
        function switchVoiceTab(tabName) {
            if (!tabName || (tabName !== 'record' && tabName !== 'stored')) return;
            
            // Update tab buttons
            const tabs = document.querySelectorAll('.voice-tab');
            tabs.forEach(tab => {
                const tabId = tab.dataset.tab;
                if (tabId === tabName) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });
            
            // Update tab panels
            const recordPanel = document.getElementById('voiceTabRecord');
            const storedPanel = document.getElementById('voiceTabStored');
            
            if (recordPanel && storedPanel) {
                if (tabName === 'record') {
                    recordPanel.classList.add('active');
                    recordPanel.style.display = 'block';
                    storedPanel.classList.remove('active');
                    storedPanel.style.display = 'none';
                } else {
                    recordPanel.classList.remove('active');
                    recordPanel.style.display = 'none';
                    storedPanel.classList.add('active');
                    storedPanel.style.display = 'block';
                }
                
                activeVoiceTab = tabName;
            }
        }
        
        // Toggle dream form visibility (collapse/expand)
        function toggleDreamForm() {
            const fullForm = document.getElementById('dreamFormFull');
            const collapsedForm = document.getElementById('dreamFormCollapsed');
            
            if (!fullForm || !collapsedForm) return; // Safety check

            if (isDreamFormCollapsed) {
                // Expand: show full form, hide collapsed
                fullForm.style.display = 'block';
                collapsedForm.style.display = 'none';
                isDreamFormCollapsed = false;
                try { localStorage.setItem(DREAM_FORM_COLLAPSE_KEY, 'false'); } catch (e) {}
            } else {
                // Collapse: hide full form, show collapsed
                fullForm.style.display = 'none';
                collapsedForm.style.display = 'block';
                isDreamFormCollapsed = true;
                try { localStorage.setItem(DREAM_FORM_COLLAPSE_KEY, 'true'); } catch (e) {}
            }
        }
        // MOVE TO: SECTION 6 - Central action dispatcher
        function routeAction(context, event = null) {
            const handler = ACTION_MAP[context.action];
            if (handler) {
                try {
                    // Special case: seek-audio needs the event object
                    if (context.action === 'seek-audio') {
                        context.event = event;
                    }
                    
                    // Handle both sync and async functions
                    const result = handler(context);
                    if (result && typeof result.catch === 'function') {
                        // This is a Promise, handle errors
                        result.catch(error => {
                            console.error(`Error executing async action '${context.action}':`, error);
                        });
                    }
                } catch (error) {
                    console.error(`Error executing action '${context.action}':`, error);
                }
            } else {
                console.error(`No handler found for action: ${context.action}`);
            }
        }
        
        // Unified click handler for all containers
        // MOVE TO: SECTION 6 - Global click event handler
        function handleUnifiedClick(event) {
            // Skip click handling for select elements - they should only use change events
            if (event.target.tagName === 'SELECT') {
                return;
            }
            
            const context = extractActionContext(event.target);
            if (context) {
                routeAction(context, event);
            }
        }
        // Event Delegation System (Unified)
        // MOVE TO: SECTION 7 - Event system initialization
        function setupEventDelegation() {
            // Unified click handler for all containers and document
            document.addEventListener('click', handleUnifiedClick);
            
            // Unified change handler for select elements and other form controls
            document.addEventListener('change', handleUnifiedChange);
            
            // File input change event (not a click action)
            const importFileInput = document.getElementById('importFile');
            if (importFileInput) {
                importFileInput.addEventListener('change', importEntries);
            }
            
            const importAllDataFileInput = document.getElementById('importAllDataFile');
            if (importAllDataFileInput) {
                importAllDataFileInput.addEventListener('change', importAllData);
            }
        }
        
        // Handle change events for form elements with data-action
        // MOVE TO: SECTION 6 - Global change event handler
        function handleUnifiedChange(event) {
            const context = extractActionContext(event.target);
            if (context) {
                routeAction(context, event);
            }
        }
        
        function setupEndlessScroll() {
            // Remove existing scroll listener to prevent duplicates
            removeEndlessScroll();
            
            // Add scroll listener with debouncing
            window.addEventListener('scroll', handleEndlessScroll);
        }
        
        function removeEndlessScroll() {
            window.removeEventListener('scroll', handleEndlessScroll);
        }
        
        function handleEndlessScroll() {
            if (scrollDebounceTimer) {
                clearTimeout(scrollDebounceTimer);
            }
            
            scrollDebounceTimer = setTimeout(async () => {
                if (!endlessScrollState.enabled || endlessScrollState.loading) return;
                
                // Throttle scroll events
                const now = Date.now();
                if (now - endlessScrollState.lastScrollTime < CONSTANTS.DEBOUNCE_SCROLL_MS) return;
                endlessScrollState.lastScrollTime = now;
                
                // Check if user scrolled near bottom
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const windowHeight = window.innerHeight;
                const documentHeight = document.documentElement.scrollHeight;
                
                if (scrollTop + windowHeight >= documentHeight - CONSTANTS.ENDLESS_SCROLL_THRESHOLD_PX) {
                    endlessScrollState.loading = true;
                    
                    try {
                        // Load more dreams
                        const totalDreams = await getFilteredDreamsCount();
                        if (endlessScrollState.loaded < totalDreams) {
                            endlessScrollState.loaded += CONSTANTS.ENDLESS_SCROLL_INCREMENT;
                            await withMutex('displayDreams', () => displayDreamsInternal());
                        }
                    } finally {
                        endlessScrollState.loading = false;
                    }
                }
            }, CONSTANTS.DEBOUNCE_SCROLL_MS);
        }
        
        // UTILITY FUNCTIONS & DOM HELPERS
        function handleMainContainerClick(event) {
            const target = event.target;
            
            // Find the element with data-action (could be the clicked element or a parent)
            let actionElement = target;
            let action = actionElement.dataset.action;
            
            // If clicked element doesn't have data-action, check parents up to 3 levels
            if (!action) {
                for (let i = 0; i < CONSTANTS.DOM_TRAVERSAL_LEVELS && actionElement.parentElement; i++) {
                    actionElement = actionElement.parentElement;
                    action = actionElement.dataset.action;
                    if (action) break;
                }
            }
            
            if (!action) return;
            
            switch (action) {
                case 'export-dreams':
                    exportEntries();
                    break;
                case 'import-dreams':
                    document.getElementById('importFile').click();
                    break;
                case 'export-ai':
                    exportForAIAnalysis();
                    break;
                case 'toggle-lock':
                    toggleLock();
                    break;
                case 'setup-pin':
                    showPinSetup();
                    break;
                case 'save-dream':
                    saveDream();
                    break;
                case 'toggle-recording':
                    toggleRecording();
                    break;
                case 'show-pin-overlay':
                    showPinOverlay();
                    break;
                case 'create-from-transcription':
                    const voiceNoteId = actionElement.dataset.voiceNoteId;
                    if (voiceNoteId) createDreamFromTranscription(voiceNoteId);
                    break;
                case 'cancel-timer':
                    cancelResetTimer();
                    break;
                default:
                    // Unhandled action - silently ignore
            }
        }
        
        // Handle voice container clicks
        function handleVoiceContainerClick(event) {
            const target = event.target;
            
            // Find the element with data-action (could be the clicked element or a parent)
            let actionElement = target;
            let action = actionElement.dataset.action;
            
            if (!action) {
                for (let i = 0; i < CONSTANTS.DOM_TRAVERSAL_LEVELS && actionElement.parentElement; i++) {
                    actionElement = actionElement.parentElement;
                    action = actionElement.dataset.action;
                    if (action) break;
                }
            }
            
            const voiceNoteId = actionElement.dataset.voiceNoteId;
            
            if (!action || !voiceNoteId) return;
            
            switch (action) {
                case 'play-voice':
                    playVoiceNote(voiceNoteId);
                    break;
                case 'pause-voice':
                    pauseVoiceNote(voiceNoteId);
                    break;
                case 'transcribe-voice':
                    transcribeVoiceNote(voiceNoteId);
                    break;
                case 'download-voice':
                    downloadVoiceNote(voiceNoteId);
                    break;
                case 'delete-voice':
                    deleteVoiceNote(voiceNoteId);
                    break;
                case 'seek-audio':
                    seekAudio(voiceNoteId, event);
                    break;
            }
        }
        
        // Handle entries container clicks
        function handleEntriesContainerClick(event) {
            const target = event.target;
            
            // Find the element with data-action (could be the clicked element or a parent)
            let actionElement = target;
            let action = actionElement.dataset.action;
            
            if (!action) {
                for (let i = 0; i < CONSTANTS.DOM_TRAVERSAL_LEVELS && actionElement.parentElement; i++) {
                    actionElement = actionElement.parentElement;
                    action = actionElement.dataset.action;
                    if (action) break;
                }
            }
            
            const dreamId = actionElement.dataset.dreamId;
            
            if (!action) return;
            
            switch (action) {
                case 'edit-dream':
                    if (dreamId) editDream(dreamId);
                    break;
                case 'delete-dream':
                    if (dreamId) deleteDream(dreamId);
                    break;
                case 'confirm-delete':
                    if (dreamId) confirmDelete(dreamId);
                    break;
                case 'save-edit':
                    if (dreamId) saveDreamEdit(dreamId);
                    break;
                case 'cancel-edit':
                    if (dreamId) cancelDreamEdit(dreamId);
                    break;
            }
        }
        
        // Handle pagination clicks
        function handlePaginationClick(event) {
            const target = event.target;
            
            // Find the element with data-action (could be the clicked element or a parent)
            let actionElement = target;
            let action = actionElement.dataset.action;
            
            if (!action) {
                for (let i = 0; i < CONSTANTS.DOM_TRAVERSAL_LEVELS && actionElement.parentElement; i++) {
                    actionElement = actionElement.parentElement;
                    action = actionElement.dataset.action;
                    if (action) break;
                }
            }
            
            if (!action) return;
            
            switch (action) {
                case 'go-to-page':
                    const page = actionElement.dataset.page;
                    if (page) goToPage(parseInt(page));
                    break;
            }
        }
        
        // Handle document-level clicks (for PIN overlay and other global actions)
        function handleDocumentClick(event) {
            const target = event.target;
            
            // Find the element with data-action (could be the clicked element or a parent)
            let actionElement = target;
            let action = actionElement.dataset.action;
            
            if (!action) {
                for (let i = 0; i < CONSTANTS.DOM_TRAVERSAL_LEVELS && actionElement.parentElement; i++) {
                    actionElement = actionElement.parentElement;
                    action = actionElement.dataset.action;
                    if (action) break;
                }
            }
            
            if (!action) return;
            
            switch (action) {
                case 'verify-pin':
                    verifyPin();
                    break;
                case 'hide-pin-overlay':
                    hidePinOverlay();
                    break;
                case 'setup-pin':
                    setupPin();
                    break;
                case 'confirm-password':
                    confirmPassword();
                    break;
                case 'cancel-password':
                    cancelPassword();
                    break;
                case 'show-pin-setup':
                    showPinSetup();
                    break;
                case 'show-remove-pin':
                    showRemovePin();
                    break;
                case 'show-forgot-pin':
                    showForgotPin();
                    break;
                case 'confirm-remove-pin':
                    confirmRemovePin();
                    break;
                case 'complete-pin-removal':
                    completePinRemoval();
                    break;
                case 'start-title-recovery':
                    startTitleRecovery();
                    break;
                case 'verify-dream-titles':
                    verifyDreamTitles();
                    break;
                case 'start-timer-recovery':
                    startTimerRecovery();
                    break;
                case 'confirm-start-timer':
                    confirmStartTimer();
                    break;
                case 'confirm-cancel-timer':
                    confirmCancelTimer();
                    break;
                case 'restore-warning-banner':
                    restoreWarningBanner();
                    break;
                case 'complete-recovery':
                    completeRecovery();
                    break;
                case 'complete-pin-setup':
                    completePinSetup();
                    break;
                case 'setup-new-pin':
                    setupNewPin();
                    break;
                case 'confirm-new-pin':
                    confirmNewPin();
                    break;
            }
        }
        
        function setupEndlessScroll() {
            // Remove existing scroll listener to prevent duplicates
            removeEndlessScroll();
            
            // Add scroll listener with debouncing
            window.addEventListener('scroll', handleEndlessScroll);
        }
        
        function removeEndlessScroll() {
            window.removeEventListener('scroll', handleEndlessScroll);
        }
        
        function handleEndlessScroll() {
            if (scrollDebounceTimer) {
                clearTimeout(scrollDebounceTimer);
            }
            
            scrollDebounceTimer = setTimeout(async () => {
                if (!endlessScrollState.enabled || endlessScrollState.loading) return;
                
                // Throttle scroll events
                const now = Date.now();
                if (now - endlessScrollState.lastScrollTime < CONSTANTS.DEBOUNCE_SCROLL_MS) return;
                endlessScrollState.lastScrollTime = now;
                
                // Check if user scrolled near bottom
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const windowHeight = window.innerHeight;
                const documentHeight = document.documentElement.scrollHeight;
                
                if (scrollTop + windowHeight >= documentHeight - CONSTANTS.ENDLESS_SCROLL_THRESHOLD_PX) {
                    endlessScrollState.loading = true;
                    
                    try {
                        // Load more dreams
                        const totalDreams = await getFilteredDreamsCount();
                        if (endlessScrollState.loaded < totalDreams) {
                            endlessScrollState.loaded += CONSTANTS.ENDLESS_SCROLL_INCREMENT;
                            await withMutex('displayDreams', () => displayDreamsInternal());
                        }
                    } finally {
                        endlessScrollState.loading = false;
                    }
                }
            }, CONSTANTS.DEBOUNCE_SCROLL_MS);
        }
        
        // Generate a random salt
        function generateSalt() {
            return crypto.getRandomValues(new Uint8Array(16));
        }
        
        // Generate a random IV
        function generateIV() {
            return crypto.getRandomValues(new Uint8Array(12));
        }
        
        // Derive key from password using PBKDF2
        async function deriveKey(password, salt) {
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                { name: 'PBKDF2' },
                false,
                ['deriveBits', 'deriveKey']
            );
            
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        }
        
        // Encrypt data with password
        // MOVE TO: SECTION 5.6 - Data encryption functionality
        async function encryptData(data, password) {
            try {
                const encoder = new TextEncoder();
                const salt = generateSalt();
                const iv = generateIV();
                const key = await deriveKey(password, salt);
                
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encoder.encode(data)
                );
                
                // Combine salt, iv, and encrypted data
                const result = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
                result.set(salt, 0);
                result.set(iv, salt.length);
                result.set(new Uint8Array(encrypted), salt.length + iv.length);
                
                return result;
            } catch (error) {
                console.error('Encryption error:', error);
                throw new Error('Failed to encrypt data');
            }
        }
        
        // Decrypt data with password
        // MOVE TO: SECTION 5.6 - Data decryption functionality
        async function decryptData(encryptedData, password) {
            try {
                const salt = encryptedData.slice(0, 16);
                const iv = encryptedData.slice(16, 28);
                const encrypted = encryptedData.slice(28);
                
                const key = await deriveKey(password, salt);
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encrypted
                );
                
                const decoder = new TextDecoder();
                return decoder.decode(decrypted);
            } catch (error) {
                console.error('Decryption error:', error);
                throw new Error('Failed to decrypt data - incorrect password or corrupted file');
            }
        }

        // Password Dialog Functions for Export/Import (defined early to avoid reference errors)
        
        // NEW UNIFIED PASSWORD DIALOG
        function showPasswordDialog(config) {
            return new Promise((resolve) => {
                const existingOverlay = document.getElementById('passwordDialogOverlay');
                if(existingOverlay) existingOverlay.remove();

                const overlay = document.createElement('div');
                overlay.id = 'passwordDialogOverlay';
                overlay.className = 'pin-overlay';
                overlay.style.display = 'flex';

                const confirmInputHTML = config.requireConfirm ? `
                    <input type="password" id="${config.type}PasswordConfirm" class="pin-input" placeholder="Confirm password" maxlength="50" style="margin-top: 10px;">
                ` : '';

                overlay.innerHTML = `
                    <div class="pin-container">
                        <h2>${config.icon || '🔐'} ${escapeHtml(config.title)}</h2>
                        <p>${escapeHtml(config.description)}</p>
                        <input type="password" id="${config.type}Password" class="pin-input" placeholder="Enter password" maxlength="50">
                        ${confirmInputHTML}
                        <div class="pin-buttons">
                            <button data-action="confirm-${config.type}-password" class="btn btn-primary">${escapeHtml(config.primaryButtonText)}</button>
                            <button data-action="cancel-${config.type}-password" class="btn btn-secondary">Cancel</button>
                        </div>
                        <div id="${config.type}PasswordError" class="notification-message error"></div>
                    </div>
                `;
                
                document.body.appendChild(overlay);

                window[`${config.type}PasswordResolve`] = resolve;

                setTimeout(() => {
                    document.getElementById(`${config.type}Password`).focus();
                }, 100);

                overlay.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const action = `confirm-${config.type}-password`;
                        const handler = ACTION_MAP[action];
                        if(handler) handler();
                    }
                });
            });
        }

        // Show password input dialog for export (Updated for Event Delegation)
        function showExportPasswordDialog() {
            return showPasswordDialog({
                type: 'export',
                title: 'Set Export Password',
                description: 'Choose a password to encrypt your dream export. This password is not stored - remember it for importing!',
                requireConfirm: true,
                primaryButtonText: 'Encrypt & Export'
            });
        }
        
        // Confirm export password
        function confirmExportPassword() {
            const password = document.getElementById('exportPassword').value;
            const confirm = document.getElementById('exportPasswordConfirm').value;
            const errorDiv = document.getElementById('exportPasswordError');
            
            if (!password || password.length < 4) {
                errorDiv.textContent = 'Password must be at least 4 characters long';
                errorDiv.style.display = 'block';
                return;
            }
            
            if (password !== confirm) {
                errorDiv.textContent = 'Passwords do not match';
                errorDiv.style.display = 'block';
                return;
            }
            
            // Remove overlay and resolve with password
            const overlay = document.getElementById('passwordDialogOverlay');
            if (overlay) overlay.remove();
            
            if (window.exportPasswordResolve) {
                window.exportPasswordResolve(password);
                delete window.exportPasswordResolve;
            }
        }
        
        // Cancel export password
        function cancelExportPassword() {
            const overlay = document.getElementById('passwordDialogOverlay');
            if (overlay) overlay.remove();
            
            if (window.exportPasswordResolve) {
                window.exportPasswordResolve(null);
                delete window.exportPasswordResolve;
            }
        }
        
        // Show password input dialog for import (Updated for Event Delegation)
        function showImportPasswordDialog() {
            return showPasswordDialog({
                type: 'import',
                title: 'Enter Import Password',
                description: 'Enter the password used to encrypt this dream export file.',
                requireConfirm: false,
                primaryButtonText: 'Decrypt & Import'
            });
        }
        
        // Confirm import password
        function confirmImportPassword() {
            const password = document.getElementById('importPassword').value;
            const errorDiv = document.getElementById('importPasswordError');
            
            if (!password) {
                errorDiv.textContent = 'Please enter the password';
                errorDiv.style.display = 'block';
                return;
            }
            
            // Remove overlay and resolve with password
            const overlay = document.getElementById('passwordDialogOverlay');
            if (overlay) overlay.remove();
            
            if (window.importPasswordResolve) {
                window.importPasswordResolve(password);
                delete window.importPasswordResolve;
            }
        }
        
        // Cancel import password
        function cancelImportPassword() {
            const overlay = document.getElementById('passwordDialogOverlay');
            if (overlay) overlay.remove();
            
            if (window.importPasswordResolve) {
                window.importPasswordResolve(null);
                delete window.importPasswordResolve;
            }
        }

        // VOICE RECORDING & TRANSCRIPTION SYSTEM
        
        // Create dream entry from transcribed voice note
        // Create dream entry from transcribed voice note
        // Transcribe voice note (create dream entry if transcription exists)
        async function transcribeVoiceNote(voiceNoteId) {
            try {
                const voiceNotes = await loadVoiceNotes();
                const voiceNote = voiceNotes.find(n => n.id === voiceNoteId);
                
                if (!voiceNote) {
                    updateVoiceStatus('Voice note not found', 'error');
                    return;
                }
                
                if (voiceNote.transcription && voiceNote.transcription.trim()) {
                    // Transcription already exists, create dream entry
                    await createDreamFromTranscription(voiceNoteId);
                } else {
                    // No transcription available
                    updateVoiceStatus('No transcription available. Transcription happens during recording when supported.', 'error');
                    
                    // Show helpful message
                    const container = document.querySelector('.main-content');
                    if (container) {
                        const msg = document.createElement('div');
                        msg.className = 'message-warning';
                        msg.innerHTML = `
                            <strong>Transcription Tip:</strong> For automatic transcription, speak clearly during recording. 
                            <br>Transcription works best with clear speech in quiet environments.
                        `;
                        container.insertBefore(msg, container.firstChild);
                        
                        setTimeout(() => {
                            if (msg.parentNode) {
                                msg.remove();
                            }
                        }, 7000);
                    }
                }
                
            } catch (error) {
                console.error('Error transcribing voice note:', error);
                updateVoiceStatus('Failed to process transcription', 'error');
            }
        }
        async function createDreamFromTranscription(voiceNoteId) {
            try {
                const voiceNotes = await loadVoiceNotes();
                const voiceNote = voiceNotes.find(n => n.id === voiceNoteId);
                
                if (!voiceNote || !voiceNote.transcription) {
                    updateVoiceStatus('No transcription available for this voice note', 'error');
                    return;
                }
                
                // Set the current date/time as the dream date
                const now = new Date();
                const dreamDateInput = document.getElementById('dreamDate');
                if (dreamDateInput) {
                    dreamDateInput.value = now.toISOString().slice(0, 16);
                }
                
                // Clear other form fields
                const titleInput = document.getElementById('dreamTitle');
                const emotionsInput = document.getElementById('dreamEmotions');
                const tagsInput = document.getElementById('dreamTags');
                const dreamSignsInput = document.getElementById('dreamSigns');
                const lucidCheckbox = document.getElementById('isLucid');
                const contentInput = document.getElementById('dreamContent');
                
                if (titleInput) titleInput.value = '';
                if (emotionsInput) emotionsInput.value = '';
                if (tagsInput) tagsInput.value = '';
                if (dreamSignsInput) dreamSignsInput.value = '';
                if (lucidCheckbox) lucidCheckbox.checked = false;
                
                // Populate with transcribed text
                if (contentInput) {
                    contentInput.value = voiceNote.transcription;
                    contentInput.focus();
                    contentInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                
                // Show success message
                const container = document.querySelector('.main-content');
                if (container) {
                    createInlineMessage('info', 'Dream entry created from transcription! Review and edit as needed, then save.', {
                        container: container,
                        position: 'top',
                        duration: 5000
                    });
                }
                
            } catch (error) {
                console.error('Error creating dream from transcription:', error);
                updateVoiceStatus('Failed to create dream entry', 'error');
            }
        }

        // Transcribe voice note (create dream entry if transcription exists)
        async function transcribeVoiceNote(voiceNoteId) {
            try {
                const voiceNotes = await loadVoiceNotes();
                const voiceNote = voiceNotes.find(n => n.id === voiceNoteId);
                
                if (!voiceNote) {
                    updateVoiceStatus('Voice note not found', 'error');
                    return;
                }
                
                if (voiceNote.transcription && voiceNote.transcription.trim()) {
                    // Transcription already exists, create dream entry
                    await createDreamFromTranscription(voiceNoteId);
                } else {
                    // No transcription available
                    updateVoiceStatus('No transcription available. Transcription happens during recording when supported.', 'error');
                    
                    // Show helpful message
                    const container = document.querySelector('.main-content');
                    if (container) {
                        const msg = document.createElement('div');
                        msg.style.cssText = `
                            background: var(--notification-warning-bg);
                            color: var(--warning-color);
                            padding: 15px;
                            border-radius: var(--border-radius);
                            margin-bottom: 20px;
                            font-weight: var(--font-weight-semibold);
                            text-align: center;
                        `;
                        msg.innerHTML = `
                            <strong>Transcription Tip:</strong> For automatic transcription, speak clearly during recording. 
                            <br>Transcription works best with clear speech in quiet environments.
                        `;
                        container.insertBefore(msg, container.firstChild);
                        
                        setTimeout(() => {
                            if (msg.parentNode) {
                                msg.remove();
                            }
                        }, 7000);
                    }
                }
                
            } catch (error) {
                console.error('Error transcribing voice note:', error);
                updateVoiceStatus('Failed to process transcription', 'error');
            }
        }
        
        // DREAM DISPLAY & MANAGEMENT FUNCTIONS
        
        // Break down the large displayDreams function into smaller helper functions
        
        // Filter dreams based on search and filter criteria
        function filterDreams(dreams, searchTerm, filterType, startDate, endDate) {
            if (!Array.isArray(dreams)) return [];

            const start = startDate ? new Date(startDate) : null;
            if(start) start.setHours(0,0,0,0); // Start of the day
            const end = endDate ? new Date(endDate) : null;
            if(end) end.setHours(23,59,59,999); // End of the day
            
            return dreams.filter(dream => {
                if (!dream || typeof dream !== 'object' || !dream.timestamp) return false;
                
                try {
                    const title = (dream.title || '').toString().toLowerCase();
                    const content = (dream.content || '').toString().toLowerCase();
                    const emotions = (dream.emotions || '').toString().toLowerCase();
                    const tags = Array.isArray(dream.tags) ? dream.tags.join(' ').toLowerCase() : '';
                    const dreamSigns = Array.isArray(dream.dreamSigns) ? dream.dreamSigns.join(' ').toLowerCase() : '';
                    
                    const matchesSearch = !searchTerm || 
                        title.includes(searchTerm) ||
                        content.includes(searchTerm) ||
                        emotions.includes(searchTerm) ||
                        tags.includes(searchTerm) ||
                        dreamSigns.includes(searchTerm);
                    
                    const matchesFilter = filterType === 'all' || 
                        (filterType === 'lucid' && Boolean(dream.isLucid)) ||
                        (filterType === 'non-lucid' && !Boolean(dream.isLucid));

                    const dreamDate = new Date(dream.timestamp);
                    if(isNaN(dreamDate.getTime())) return false; // Invalid dream date

                    let matchesDate = true;
                    if (start && end) {
                        matchesDate = dreamDate >= start && dreamDate <= end;
                    } else if (start) {
                        matchesDate = dreamDate >= start;
                    } else if (end) {
                        matchesDate = dreamDate <= end;
                    }
                    
                    return matchesSearch && matchesFilter && matchesDate;
                } catch (error) {
                    console.error('Error filtering dream:', error, dream);
                    return false;
                }
            });
        }
        
        // Sort dreams based on sort criteria
        function sortDreams(dreams, sortType) {
            if (!Array.isArray(dreams) || dreams.length === 0) return dreams;
            
            try {
                return [...dreams].sort((a, b) => {
                    if (!a || !b) return 0;
                    
                    try {
                        switch (sortType) {
                            case 'oldest':
                                const dateA = new Date(a.timestamp || 0);
                                const dateB = new Date(b.timestamp || 0);
                                if (isNaN(dateA.getTime())) return 1;
                                if (isNaN(dateB.getTime())) return -1;
                                return dateA - dateB;
                            
                            case 'lucid-first':
                                const aLucid = Boolean(a.isLucid);
                                const bLucid = Boolean(b.isLucid);
                                if (aLucid && !bLucid) return -1;
                                if (!aLucid && bLucid) return 1;
                                const dateA2 = new Date(a.timestamp || 0);
                                const dateB2 = new Date(b.timestamp || 0);
                                if (isNaN(dateA2.getTime())) return 1;
                                if (isNaN(dateB2.getTime())) return -1;
                                return dateB2 - dateA2;
                            
                            case 'longest':
                                const contentA = (a.content || '').toString();
                                const contentB = (b.content || '').toString();
                                return contentB.length - contentA.length;
                            
                            case 'newest':
                            default:
                                const dateA3 = new Date(a.timestamp || 0);
                                const dateB3 = new Date(b.timestamp || 0);
                                if (isNaN(dateA3.getTime())) return 1;
                                if (isNaN(dateB3.getTime())) return -1;
                                return dateB3 - dateA3;
                        }
                    } catch (innerError) {
                        console.error('Error in sort comparison:', innerError);
                        return 0;
                    }
                });
            } catch (error) {
                console.error('Sorting error:', error);
                return dreams; // Return unsorted if sorting fails
            }
        }
        
        // Calculate pagination safely
        // calculatePagination, renderDreamHTML, and renderPaginationHTML functions moved to SECTION 5.1

                
        // TAGS & AUTOCOMPLETE SYSTEM

        // Predefined tags database for autocomplete
        const commonTags = [
            // People
            'family', 'friends', 'strangers', 'children', 'elderly', 'celebrities', 'deceased-relatives',
            // Places
            'home', 'school', 'work', 'nature', 'city', 'ocean', 'mountains', 'forest', 'space', 'underground',
            // Objects
            'animals', 'vehicles', 'technology', 'weapons', 'books', 'mirrors', 'doors', 'stairs', 'bridges',
            // Activities
            'flying', 'running', 'swimming', 'dancing', 'singing', 'fighting', 'escaping', 'searching', 'traveling',
            // Themes
            'adventure', 'romance', 'horror', 'fantasy', 'sci-fi', 'mystery', 'spiritual', 'nostalgic', 'surreal'
        ];

        // Dream signs database - specific elements that commonly trigger lucidity
        const commonDreamSigns = [
            // Reality Check Triggers
            'flying', 'impossible-architecture', 'text-changing', 'clocks-wrong', 'hands-distorted', 'light-switches-broken',
            // Impossible Events
            'teleportation', 'shapeshifting', 'breathing-underwater', 'floating-objects', 'gravity-defying',
            // Dead People/Past
            'deceased-alive', 'childhood-home', 'past-relationships', 'extinct-animals', 'historical-figures',
            // Distorted Reality
            'mirror-reflections-wrong', 'phone-not-working', 'doors-lead-nowhere', 'infinite-rooms', 'size-changes',
            // Recurring Personal Signs
            'teeth-falling-out', 'being-chased', 'cant-run-fast', 'naked-in-public', 'late-for-exam', 'lost-vehicle'
        ];

        // HTML escape function to prevent XSS
        function escapeHtml(text) {
            if (text == null) return '';
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }

        // HTML escape for attributes (quotes and special chars)
        function escapeAttr(text) {
            if (text == null) return '';
            return String(text).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        }

        // Debounced search function for performance
        function debouncedSearch(delay = CONSTANTS.DEBOUNCE_SEARCH_MS) {
            if (searchDebounceTimer) {
                clearTimeout(searchDebounceTimer);
            }
            
            // Show loading state immediately for responsive feedback
            showSearchLoading();
            
            searchDebounceTimer = setTimeout(async () => {
                await resetToPageOne();
                hideSearchLoading();
            }, delay);
        }

        // Debounced filter function for performance  
        function debouncedFilter(delay = CONSTANTS.DEBOUNCE_FILTER_MS) {
            if (filterDebounceTimer) {
                clearTimeout(filterDebounceTimer);
            }
            
            showSearchLoading();
            
            filterDebounceTimer = setTimeout(async () => {
                await resetToPageOne();
                hideSearchLoading();
            }, delay);
        }

        // Show loading indicator for search/filter operations
        function showSearchLoading() {
            const container = document.getElementById('entriesContainer');
            if (container && !asyncMutex.displayDreams.locked) {
                const existingLoader = container.querySelector('.loading-state');
                if (!existingLoader) {
                    const loader = document.createElement('div');
                    loader.className = 'loading-state';
                    loader.innerHTML = '🔍 Searching dreams...';
                    container.appendChild(loader);
                }
            }
        }

        // Hide loading indicator
        function hideSearchLoading() {
            const container = document.getElementById('entriesContainer');
            if (container) {
                const loader = container.querySelector('.loading-state');
                if (loader) {
                    loader.remove();
                }
            }
        }

        // Tag management functions
        // Tag management functions
        function parseTagsFromInput(input) {
            if (!input || typeof input !== 'string') return [];
            
            try {
                const tags = input.split(',')
                    .map(tag => tag.trim())
                    .filter(tag => tag.length > 0 && tag.length <= CONSTANTS.MAX_TAG_LENGTH);
                
                // Remove duplicates, case-insensitively, preserving first-seen casing
                const seen = new Set();
                return tags.filter(tag => {
                    const lower = tag.toLowerCase();
                    if (seen.has(lower)) {
                        return false;
                    } else {
                        seen.add(lower);
                        return true;
                    }
                }).slice(0, CONSTANTS.MAX_TAGS_PER_DREAM);
            } catch (error) {
                console.error('Error parsing tags:', error);
                return [];
            }
        }

        function formatTagsForDisplay(tags) {
            if (!Array.isArray(tags) || tags.length === 0) return '';
            return tags.map(tag => 
                `<span class="tag">${escapeHtml(tag)}</span>`
            ).join('');
        }

        function formatDreamSignsForDisplay(dreamSigns) {
            if (!Array.isArray(dreamSigns) || dreamSigns.length === 0) return '';
            return dreamSigns.map(sign => 
                `<span class="dream-sign">${escapeHtml(sign)}</span>`
            ).join('');
        }

        // Setup tag autocomplete for form inputs
        function setupTagAutocomplete(inputId, suggestions) {
            const input = document.getElementById(inputId);
            if (!input || !Array.isArray(suggestions)) return;

            // Remove existing listener to prevent duplicates
            if (input.autocompleteListener) {
                input.removeEventListener('input', input.autocompleteListener);
            }
            if (input.autocompleteDropdown) {
                input.autocompleteDropdown.remove();
            }

            // Create autocomplete dropdown
            const dropdown = document.createElement('div');
            dropdown.className = 'tag-autocomplete-dropdown';
            input.autocompleteDropdown = dropdown;

            // Position container relatively
            if (input.parentElement) {
                input.parentElement.style.position = 'relative';
                input.parentElement.appendChild(dropdown);
            }

            const listener = function() {
                const value = this.value.toLowerCase();
                const lastComma = value.lastIndexOf(',');
                const currentTag = lastComma >= 0 ? value.substring(lastComma + 1).trim() : value.trim();

                if (currentTag.length < CONSTANTS.AUTOCOMPLETE_MIN_CHARS) {
                    dropdown.style.display = 'none';
                    return;
                }

                const matches = suggestions.filter(suggestion => 
                    suggestion.toLowerCase().includes(currentTag) &&
                    !value.toLowerCase().includes(suggestion.toLowerCase())
                ).slice(0, CONSTANTS.AUTOCOMPLETE_MAX_RESULTS);

                if (matches.length === 0) {
                    dropdown.style.display = 'none';
                    return;
                }

                dropdown.innerHTML = matches.map(match => 
                    `<div class="autocomplete-item" data-tag="${escapeAttr(match)}">
                        ${escapeHtml(match)}
                    </div>`
                ).join('');

                dropdown.style.display = 'block';

                // Add click handlers
                dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
                    item.addEventListener('click', function() {
                        const tag = this.dataset.tag;
                        if (tag) {
                            const currentValue = input.value;
                            const lastComma = currentValue.lastIndexOf(',');
                            
                            if (lastComma >= 0) {
                                input.value = currentValue.substring(0, lastComma + 1) + ' ' + tag + ', ';
                            } else {
                                input.value = tag + ', ';
                            }
                            
                            dropdown.style.display = 'none';
                            input.focus();
                        }
                    });
                });
            };
            
            input.autocompleteListener = listener;
            input.addEventListener('input', listener);

            // Hide dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (dropdown && !input.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.style.display = 'none';
                }
            });
        }

        // DATA STORAGE & PERSISTENCE LAYER
        
        // Database functions moved to SECTION 4

        // Migrate data from localStorage to IndexedDB
        async function migrateFromLocalStorage() {
            if (!isLocalStorageAvailable() || !isIndexedDBAvailable()) {
                return false;
            }
            
            // Check migration flag first to avoid unnecessary work
            const alreadyMigrated = localStorage.getItem('dreamJournalMigrated');
            if (alreadyMigrated === 'true') {
                return false; // Exit early
            }
            
            try {
                const localData = localStorage.getItem('dreamJournalEntries');
                if (!localData) return false;
                
                const dreams = JSON.parse(localData);
                if (!dreams || dreams.length === 0) return false;
                
                // Show migration notice
                const notice = document.getElementById('migrationNotice');
                if (notice) {
                    notice.style.display = 'block';
                }
                
                // Check if IndexedDB already has data (double-check)
                const existingCount = await getIndexedDBCount();
                if (existingCount > 0) {
                    // Already migrated but flag wasn't set
                    localStorage.setItem('dreamJournalMigrated', 'true');
                    if (notice) notice.style.display = 'none';
                    return false;
                }
                
                // Migrate dreams to IndexedDB
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                
                for (const dream of dreams) {
                    // Convert old numeric IDs to new string format for consistency
                    if (typeof dream.id === 'number') {
                        dream.id = dream.id.toString();
                    }
                    // Ensure each dream has a valid ID
                    if (!dream.id) {
                        dream.id = generateUniqueId();
                    }
                    store.add(dream);
                }
                
                await new Promise((resolve, reject) => {
                    transaction.oncomplete = resolve;
                    transaction.onerror = reject;
                });
                
                // Keep localStorage as backup but mark as migrated
                localStorage.setItem('dreamJournalMigrated', 'true');
                
                // Hide migration notice
                setTimeout(() => {
                    if (notice) notice.style.display = 'none';
                }, 1000);
                
                return true;
            } catch (error) {
                console.error('Migration error:', error);
                return false;
            }
        }

        // Get count of dreams in IndexedDB
        async function getIndexedDBCount() {
            if (!isIndexedDBAvailable()) return 0;
            
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    // Transaction-level error handling
                    transaction.onabort = () => {
                        console.error('Count dreams transaction aborted');
                        resolve(0);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Count dreams transaction error:', transaction.error);
                        resolve(0);
                    };
                    
                    const request = store.count();
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => {
                        console.error('Failed to count dreams:', request.error);
                        resolve(0);
                    };
                } catch (error) {
                    console.error('Error creating count dreams transaction:', error);
                    resolve(0);
                }
            });
        }

        // Load dreams from IndexedDB
        async function loadFromIndexedDB() {
            if (!isIndexedDBAvailable()) return null;
            
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    // Transaction-level error handling
                    transaction.onabort = () => {
                        console.error('Load dreams transaction aborted');
                        resolve(null);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Load dreams transaction error:', transaction.error);
                        resolve(null);
                    };
                    
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        const dreams = request.result || [];
                        // Sort by timestamp (newest first)
                        dreams.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                        resolve(dreams);
                    };
                    
                    request.onerror = () => {
                        console.error('Failed to load from IndexedDB:', request.error);
                        resolve(null);
                    };
                } catch (error) {
                    console.error('Error creating load dreams transaction:', error);
                    resolve(null);
                }
            });
        }

        // Save dreams to IndexedDB - improved to use put() for efficiency
        async function saveToIndexedDB(dreams) {
            if (!isIndexedDBAvailable()) return false;
            
            // Validate all dreams before saving
            for (const dream of dreams) {
                if (!validateDreamData(dream)) {
                    console.error('Bulk save failed: invalid dream data detected');
                    return false;
                }
            }
            
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    // Transaction-level error handling
                    transaction.onabort = () => {
                        console.error('Bulk save transaction aborted');
                        resolve(false);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Bulk save transaction error:', transaction.error);
                        resolve(false);
                    };
                    
                    transaction.oncomplete = async () => {
                        // Update localStorage backup after successful IndexedDB operation
                        await updateLocalStorageBackup();
                        resolve(true);
                    };
                    
                    // Use put() which updates existing or adds new records
                    for (const dream of dreams) {
                        store.put(dream);
                    }
                } catch (error) {
                    console.error('Error creating bulk save transaction:', error);
                    resolve(false);
                }
            });
        }
        
        // Add individual dream to IndexedDB
        async function addDreamToIndexedDB(dream) {
            if (!isIndexedDBAvailable()) return false;
            
            // Validate dream data before adding
            if (!validateDreamData(dream)) {
                return false;
            }
            
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    // Transaction-level error handling
                    transaction.onabort = () => {
                        console.error('Add dream transaction aborted');
                        resolve(false);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Add dream transaction error:', transaction.error);
                        resolve(false);
                    };
                    
                    const request = store.add(dream);
                    
                    request.onsuccess = async () => {
                        // Update localStorage backup after successful IndexedDB operation
                        await updateLocalStorageBackup();
                        resolve(true);
                    };
                    request.onerror = (event) => {
                        // Handle ID collision specifically
                        if (event.target.error && event.target.error.name === 'ConstraintError') {
                            // ID collision - fallback to put() instead of add()
                            const putRequest = store.put(dream);
                            putRequest.onsuccess = async () => {
                                await updateLocalStorageBackup();
                                resolve(true);
                            };
                            putRequest.onerror = () => {
                                console.error('Failed to update dream after ID collision:', putRequest.error);
                                resolve(false);
                            };
                        } else {
                            console.error('Failed to add dream:', event.target.error);
                            resolve(false);
                        }
                    };
                } catch (error) {
                    console.error('Error creating add dream transaction:', error);
                    resolve(false);
                }
            });
        }
        
        // Update individual dream in IndexedDB
        async function updateDreamInIndexedDB(dream) {
            if (!isIndexedDBAvailable()) return false;
            
            // Validate dream data before updating
            if (!validateDreamData(dream)) {
                return false;
            }
            
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    // Transaction-level error handling
                    transaction.onabort = () => {
                        console.error('Update dream transaction aborted');
                        resolve(false);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Update dream transaction error:', transaction.error);
                        resolve(false);
                    };
                    
                    const request = store.put(dream);
                    
                    request.onsuccess = async () => {
                        // Update localStorage backup after successful IndexedDB operation
                        await updateLocalStorageBackup();
                        resolve(true);
                    };
                    request.onerror = () => {
                        console.error('Failed to update dream:', request.error);
                        resolve(false);
                    };
                } catch (error) {
                    console.error('Error creating update dream transaction:', error);
                    resolve(false);
                }
            });
        }
        
        // Delete individual dream from IndexedDB
        async function deleteDreamFromIndexedDB(dreamId) {
            if (!isIndexedDBAvailable()) return false;
            
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    // Transaction-level error handling
                    transaction.onabort = () => {
                        console.error('Delete dream transaction aborted');
                        resolve(false);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Delete dream transaction error:', transaction.error);
                        resolve(false);
                    };
                    
                    const request = store.delete(dreamId);
                    
                    request.onsuccess = async () => {
                        // Update localStorage backup after successful IndexedDB operation
                        await updateLocalStorageBackup();
                        resolve(true);
                    };
                    request.onerror = () => {
                        console.error('Failed to delete dream:', request.error);
                        resolve(false);
                    };
                } catch (error) {
                    console.error('Error creating delete dream transaction:', error);
                    resolve(false);
                }
            });
        }

        // loadDreams function moved to SECTION 4

        // saveDreams function moved to SECTION 4

        // GOALS STORAGE & MANAGEMENT SYSTEM
        
        // loadGoals function moved to SECTION 4
        
        // saveGoals function moved to SECTION 4
        
        // IndexedDB goals functions moved to SECTION 4

        // VOICE NOTES STORAGE & PLAYBACK SYSTEM
        
        // Voice Notes Storage Functions
        
        // Load voice notes from IndexedDB
        async function loadVoiceNotesFromIndexedDB() {
            if (!isIndexedDBAvailable()) return null;
            
            return new Promise((resolve) => {
                try {
                    // Check if voice notes store exists
                    if (!db.objectStoreNames.contains(VOICE_STORE_NAME)) {
                        resolve([]);
                        return;
                    }
                    
                    const transaction = db.transaction([VOICE_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(VOICE_STORE_NAME);
                    
                    transaction.onabort = () => {
                        console.error('Load voice notes transaction aborted');
                        resolve([]);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Load voice notes transaction error:', transaction.error);
                        resolve([]);
                    };
                    
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        const voiceNotes = request.result || [];
                        // Sort by timestamp (newest first)
                        voiceNotes.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                        resolve(voiceNotes);
                    };
                    
                    request.onerror = () => {
                        console.error('Failed to load voice notes from IndexedDB:', request.error);
                        resolve([]);
                    };
                } catch (error) {
                    console.error('Error creating load voice notes transaction:', error);
                    resolve([]);
                }
            });
        }
        
        // Load voice notes with fallback
        async function loadVoiceNotes() {
            // Try IndexedDB first
            if (isIndexedDBAvailable()) {
                const indexedDBVoiceNotes = await loadVoiceNotesFromIndexedDB();
                if (indexedDBVoiceNotes !== null && Array.isArray(indexedDBVoiceNotes)) {
                    return indexedDBVoiceNotes;
                }
            }
            
            // Fallback to memory
            return Array.isArray(memoryVoiceNotes) ? memoryVoiceNotes : [];
        }
        
        // Save voice note to IndexedDB
        async function saveVoiceNoteToIndexedDB(voiceNote) {
            if (!isIndexedDBAvailable()) return false;
            
            return new Promise((resolve) => {
                try {
                    // Check if voice notes store exists
                    if (!db.objectStoreNames.contains(VOICE_STORE_NAME)) {
                        resolve(false);
                        return;
                    }
                    
                    const transaction = db.transaction([VOICE_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(VOICE_STORE_NAME);
                    
                    transaction.onabort = () => {
                        console.error('Save voice note transaction aborted');
                        resolve(false);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Save voice note transaction error:', transaction.error);
                        resolve(false);
                    };
                    
                    const request = store.add(voiceNote);
                    
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => {
                        // Handle ID collision
                        if (event.target.error && event.target.error.name === 'ConstraintError') {
                            const putRequest = store.put(voiceNote);
                            putRequest.onsuccess = () => resolve(true);
                            putRequest.onerror = () => resolve(false);
                        } else {
                            console.error('Failed to save voice note:', event.target.error);
                            resolve(false);
                        }
                    };
                } catch (error) {
                    console.error('Error creating save voice note transaction:', error);
                    resolve(false);
                }
            });
        }
        
        // Delete voice note from IndexedDB
        async function deleteVoiceNoteFromIndexedDB(voiceNoteId) {
            if (!isIndexedDBAvailable()) return false;
            
            return new Promise((resolve) => {
                try {
                    // Check if voice notes store exists
                    if (!db.objectStoreNames.contains(VOICE_STORE_NAME)) {
                        resolve(false);
                        return;
                    }
                    
                    const transaction = db.transaction([VOICE_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(VOICE_STORE_NAME);
                    
                    transaction.onabort = () => {
                        console.error('Delete voice note transaction aborted');
                        resolve(false);
                    };
                    
                    transaction.onerror = () => {
                        console.error('Delete voice note transaction error:', transaction.error);
                        resolve(false);
                    };
                    
                    const request = store.delete(voiceNoteId);
                    
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => {
                        console.error('Failed to delete voice note:', request.error);
                        resolve(false);
                    };
                } catch (error) {
                    console.error('Error creating delete voice note transaction:', error);
                    resolve(false);
                }
            });
        }
        
        // Save voice note with fallback (with mutex protection)
        async function saveVoiceNote(voiceNote) {
            return withMutex('voiceOperations', async () => {
                // Try IndexedDB first
                if (isIndexedDBAvailable()) {
                    const saved = await saveVoiceNoteToIndexedDB(voiceNote);
                    if (saved) return true;
                }
                
                // Fallback to memory
                memoryVoiceNotes.unshift(voiceNote);
                // Keep only most recent in memory fallback
                if (memoryVoiceNotes.length > CONSTANTS.VOICE_STORAGE_LIMIT) {
                    memoryVoiceNotes.splice(CONSTANTS.VOICE_STORAGE_LIMIT);
                }
                
                // Show warning about temporary storage
                if (!document.getElementById('voiceStorageWarning')) {
                    showVoiceStorageWarning();
                }
                
                return true;
            });
        }

        // Show warning when voice notes are stored in memory only
        function showVoiceStorageWarning() {
            const container = document.querySelector('.voice-notes-section');
            if (!container) return;
            
            createInlineMessage('warning', 
                '⚠️ Voice Storage Notice: Voice recordings are stored temporarily in memory only. They will be lost when you close this tab. Download important recordings!', 
                {
                    container: container,
                    position: 'top',
                    duration: 10000,
                    className: 'voice-storage-warning'
                }
            );
        }

        // VOICE RECORDING INTERFACE & CONTROLS
        
        // Voice Recording Functions
        
        // Enhanced browser detection for voice features
        function getVoiceCapabilities() {
            const hasGetUserMedia = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
            const hasMediaRecorder = !!(window.MediaRecorder);
            const hasSpeechRecognition = !!(window.SpeechRecognition || window.webkitSpeechRecognition);
            
            // Detect browser type
            const userAgent = navigator.userAgent.toLowerCase();
            const isFirefox = userAgent.includes('firefox');
            const isFirefoxMobile = isFirefox && userAgent.includes('mobile');
            const isSafari = userAgent.includes('safari') && !userAgent.includes('chrome');
            const isSafariMobile = isSafari && userAgent.includes('mobile');
            const isChrome = userAgent.includes('chrome') && !userAgent.includes('edg');
            const isEdge = userAgent.includes('edg');
            
            return {
                canRecord: hasGetUserMedia && hasMediaRecorder,
                canTranscribe: hasSpeechRecognition,
                hasGetUserMedia,
                hasMediaRecorder,
                hasSpeechRecognition,
                browser: {
                    isFirefox,
                    isFirefoxMobile,
                    isSafari,
                    isSafariMobile,
                    isChrome,
                    isEdge
                },
                getStatusMessage() {
                    if (this.canRecord && this.canTranscribe) {
                        return { type: 'success', message: 'Full voice recording and transcription support' };
                    } else if (this.canRecord && !this.canTranscribe) {
                        if (isFirefox) {
                            return { type: 'warning', message: 'Voice recording supported, Firefox does not support transcription' };
                        } else if (isSafari) {
                            return { type: 'warning', message: 'Voice recording supported, Safari does not support transcription' };
                        } else {
                            return { type: 'warning', message: 'Voice recording supported, transcription not available' };
                        }
                    } else if (!this.canRecord) {
                        if (isSafariMobile) {
                            return { type: 'error', message: 'Safari iOS has limited voice recording support. Try Chrome or Edge mobile.' };
                        } else {
                            return { type: 'error', message: 'Voice recording not supported in this browser. Try Chrome, Edge, or Firefox.' };
                        }
                    }
                }
            };
        }
        
        // Check if browser supports voice recording
        function isVoiceRecordingSupported() {
            return getVoiceCapabilities().canRecord;
        }
        
        // Check if speech recognition is supported
        function isSpeechRecognitionSupported() {
            return getVoiceCapabilities().canTranscribe;
        }
        
        // Setup speech recognition
        function setupSpeechRecognition() {
            if (!isSpeechRecognitionSupported()) return null;
            
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            
            let finalTranscript = '';
            
            recognition.onresult = (event) => {
                let interimTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                recognitionResults = finalTranscript + interimTranscript;
                updateVoiceStatus(`Recording... "${recognitionResults.slice(-CONSTANTS.TEXT_TRUNCATE_LENGTH)}${recognitionResults.length > CONSTANTS.TEXT_TRUNCATE_LENGTH ? '...' : ''}"`, 'info');
            };
            
            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                // Don't show error for network issues - transcription is optional
                if (event.error !== 'network') {
                    updateVoiceStatus('Recording... (transcription unavailable)', 'info');
                }
            };
            
            recognition.onend = () => {
                isTranscribing = false;
            };
            
            return recognition;
        }
        
        // Format recording duration
        function formatDuration(seconds) {
            if (!seconds || isNaN(seconds) || seconds < 0) return '0:00';
            const safeSeconds = Math.max(0, Math.floor(seconds));
            const mins = Math.floor(safeSeconds / 60);
            const secs = safeSeconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Update recording timer
        function updateRecordingTimer() {
            if (!recordingStartTime || !recordingTimer) {
                // Safety check: if recording should be stopped, clear any lingering timer
                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }
                return;
            }
            
            const elapsed = (Date.now() - recordingStartTime) / 1000;
            const timerElement = document.getElementById('recordingTimer');
            if (timerElement) {
                timerElement.textContent = formatDuration(elapsed);
            }
        }
        
        // Update voice status message
        function updateVoiceStatus(message, type = 'info') {
            const statusElement = document.getElementById('voiceStatus');
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.className = `voice-status ${type}`;
            }
        }
        
        // Update record button state
        async function updateRecordButtonState() {
            const recordBtn = document.getElementById('recordBtn');
            const recordIcon = document.getElementById('recordIcon');
            const recordText = document.getElementById('recordText');
            
            if (!recordBtn || !recordIcon || !recordText) return;
            
            try {
                const voiceNotes = await loadVoiceNotes();
                const voiceCount = voiceNotes.length;
                
                // Check if currently recording
                const isCurrentlyRecording = mediaRecorder && mediaRecorder.state === 'recording';
                
                if (isCurrentlyRecording) {
                    // Don't change button state if recording is in progress
                    return;
                }
                
                if (voiceCount >= CONSTANTS.VOICE_STORAGE_LIMIT) {
                    recordBtn.className = 'record-btn disabled';
                    recordBtn.disabled = true;
                    recordIcon.textContent = '🚫';
                    recordText.textContent = 'Storage Full';
                    updateVoiceStatus(`Storage full (${voiceCount}/${CONSTANTS.VOICE_STORAGE_LIMIT}). Delete a recording to record new ones.`, 'error');
                } else {
                    recordBtn.className = 'record-btn ready';
                    recordBtn.disabled = false;
                    recordIcon.textContent = '🎤';
                    recordText.textContent = 'Start Recording';
                    
                    if (voiceCount >= 3) {
                        updateVoiceStatus(`Voice Notes (${voiceCount}/${CONSTANTS.VOICE_STORAGE_LIMIT}) - ${CONSTANTS.VOICE_STORAGE_LIMIT - voiceCount} slot${CONSTANTS.VOICE_STORAGE_LIMIT - voiceCount === 1 ? '' : 's'} remaining`, 'warning');
                    } else {
                        const voiceCapabilities = getVoiceCapabilities();
                        if (voiceCapabilities.canTranscribe) {
                            updateVoiceStatus(`Voice Notes (${voiceCount}/${CONSTANTS.VOICE_STORAGE_LIMIT}) - Recording and transcription supported`, 'info');
                        } else {
                            updateVoiceStatus(`Voice Notes (${voiceCount}/${CONSTANTS.VOICE_STORAGE_LIMIT}) - Recording supported (no transcription)`, 'warning');
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating record button state:', error);
                updateVoiceStatus('Error checking voice note storage', 'error');
            }
        }
        
        // startRecording function moved to SECTION 5.2
        
        // stopRecording function moved to SECTION 5.2
        
        // toggleRecording function moved to SECTION 5.2
        
        // Save completed recording
        async function saveRecording(audioBlob) {
            try {
                if (!audioBlob || audioBlob.size === 0) {
                    throw new Error('Invalid audio data');
                }
                
                const now = new Date();
                const duration = recordingStartTime ? (Date.now() - recordingStartTime) / 1000 : 0;
                
                const voiceNote = {
                    id: `voice_${now.getTime()}_${Math.random().toString(36).slice(2, 11)}`,
                    audioBlob: audioBlob,
                    timestamp: now.toISOString(),
                    duration: Math.round(Math.max(0, duration)),
                    title: `Voice Note ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`,
                    dateString: now.toLocaleDateString('en-AU', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    }),
                    size: audioBlob.size,
                    transcription: (recognitionResults && recognitionResults.trim()) || null // Store transcribed text
                };
                
                await saveVoiceNote(voiceNote);
                await updateRecordButtonState();
                await displayVoiceNotes();
                
                // Switch to stored notes tab to show the new recording
                switchVoiceTab('stored');
                
                // Show different success messages based on transcription
                if (recognitionResults && recognitionResults.trim()) {
                    updateVoiceStatus(`Recording saved with transcription! Duration: ${formatDuration(duration)}`, 'info');
                    
                    // Show option to create dream entry
                    const container = document.querySelector('.voice-recording-section');
                    if (container) {
                        const successMsg = document.createElement('div');
                        successMsg.className = 'message-success mt-md';
                        successMsg.innerHTML = `
                            Voice note saved with transcription! (${formatDuration(duration)})<br>
                            <button data-action="create-from-transcription" data-voice-note-id="${voiceNote.id}" class="btn btn-primary btn-small mt-sm">
                                📝 Create Dream Entry
                            </button>
                        `;
                        container.appendChild(successMsg);
                        
                        setTimeout(() => {
                            if (successMsg.parentNode) {
                                successMsg.remove();
                            }
                        }, 10000);
                    }
                } else {
                    updateVoiceStatus(`Recording saved! Duration: ${formatDuration(duration)} (no transcription captured)`, 'info');
                    
                    // Show regular success message
                    const container = document.querySelector('.voice-recording-section');
                    if (container) {
                        createInlineMessage('success', `Voice note saved! (${formatDuration(duration)})`, {
                            container: container,
                            position: 'bottom',
                            duration: 3000
                        });
                    }
                }
                
            } catch (error) {
                console.error('Error saving recording:', error);
                updateVoiceStatus('Failed to save recording: ' + error.message, 'error');
            } finally {
                // Ensure button state is updated regardless of save success/failure
                await updateRecordButtonState();
            }
        }

        // VOICE NOTES DISPLAY & PLAYBACK CONTROLS
        
        // Voice Notes Display and Controls
        
        // Throttle progress updates to prevent excessive DOM manipulation
        let lastProgressUpdate = 0;
        const PROGRESS_UPDATE_THROTTLE = 100; // ms
        
        // Display voice notes (Updated for Event Delegation)
        async function displayVoiceNotes() {
            const container = document.getElementById('voiceNotesContainer');
            if (!container) return;
            
            try {
                const voiceNotes = await loadVoiceNotes();
                
                if (voiceNotes.length === 0) {
                    container.innerHTML = `
                        <div class="no-voice-notes">
                            No voice notes recorded yet.<br>
                            Use the recording button above to capture quick voice memos of your dreams.
                        </div>
                    `;
                    return;
                }
                
                // Show warning if at capacity
                let warningHTML = '';
                if (voiceNotes.length >= CONSTANTS.VOICE_STORAGE_LIMIT) {
                    warningHTML = `
                        <div class="voice-full-warning">
                            ⚠️ Storage full (${CONSTANTS.VOICE_STORAGE_LIMIT}/${CONSTANTS.VOICE_STORAGE_LIMIT} voice notes). Delete recordings to free space for new ones.
                        </div>
                    `;
                }
                
                const notesHTML = voiceNotes.map(note => {
                    const sizeKB = Math.round(note.size / CONSTANTS.BYTES_PER_KB);
                    const sizeMB = (note.size / CONSTANTS.BYTES_PER_MB).toFixed(1);
                    const sizeDisplay = note.size < CONSTANTS.BYTES_PER_MB ? `${sizeKB} KB` : `${sizeMB} MB`;
                    
                    // Check if transcription is available
                    const hasTranscription = note.transcription && note.transcription.trim();
                    const transcriptionIndicator = hasTranscription ? ' • 📝 Transcribed' : '';
                    
                    // Create meta information
                    const metaItems = [
                        { value: escapeHtml(note.dateString) },
                        { value: formatDuration(note.duration) },
                        { value: sizeDisplay }
                    ];
                    
                    if (transcriptionIndicator) {
                        metaItems.push({ value: transcriptionIndicator });
                    }
                    
                    // Create control buttons using utility classes
                    const controlButtons = [
                        `<button data-action="play-voice" data-voice-note-id="${escapeAttr(note.id)}" id="play-btn-${escapeAttr(note.id)}" class="voice-btn-base voice-btn-play">▶️ Play</button>`,
                        `<button data-action="transcribe-voice" data-voice-note-id="${escapeAttr(note.id)}" class="voice-btn-base voice-btn-transcribe" title="${hasTranscription ? 'Create a dream entry from this transcription' : 'Transcribe the audio and create a dream entry'}">${hasTranscription ? '📝 Use as Dream' : '📝 Transcribe & Create Dream'}</button>`,
                        `<button data-action="download-voice" data-voice-note-id="${escapeAttr(note.id)}" class="voice-btn-base voice-btn-download">⬇️ Download</button>`,
                        `<button data-action="delete-voice" data-voice-note-id="${escapeAttr(note.id)}" class="voice-btn-base voice-btn-delete">🗑️ Delete</button>`
                    ].join('');
                    
                    return `
                        <div class="voice-note-container" id="voice-note-${escapeAttr(note.id)}">
                            <div class="voice-note-info">
                                <div class="voice-note-title">${escapeHtml(note.title)}</div>
                                <div class="voice-note-meta">${createMetaDisplay(metaItems)}</div>
                            </div>
                            <div class="voice-note-controls">
                                ${controlButtons}
                                <div class="voice-progress-container" id="progress-container-${escapeAttr(note.id)}" style="display: none;">
                                    <div class="voice-time-display" id="time-current-${escapeAttr(note.id)}">0:00</div>
                                    <div class="voice-progress-bar" data-action="seek-audio" data-voice-note-id="${escapeAttr(note.id)}" id="progress-bar-${escapeAttr(note.id)}">
                                        <div class="voice-progress-fill" id="progress-fill-${escapeAttr(note.id)}"></div>
                                    </div>
                                    <div class="voice-time-display" id="time-total-${escapeAttr(note.id)}">${formatDuration(note.duration)}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                container.innerHTML = warningHTML + notesHTML;
                
            } catch (error) {
                console.error('Error displaying voice notes:', error);
                container.innerHTML = `
                    <div class="no-voice-notes">
                        Error loading voice notes. Please try refreshing the page.
                    </div>
                `;
            }
        }
        
        // playVoiceNote function moved to SECTION 5.2
        
        // Pause voice note (Updated for Event Delegation)
        function pauseVoiceNote(voiceNoteId) {
            if (currentPlayingAudio) {
                try {
                    currentPlayingAudio.pause();
                    // Don't revoke URL here since user might want to resume
                } catch (e) {
                    console.warn('Error pausing audio:', e);
                }
                currentPlayingAudio = null;
            }
            
            const playBtn = document.getElementById(`play-btn-${voiceNoteId}`);
            const progressContainer = document.getElementById(`progress-container-${voiceNoteId}`);
            
            if (playBtn) {
                playBtn.className = 'voice-btn play';
                playBtn.innerHTML = '▶️ Play';
                playBtn.dataset.action = 'play-voice';
            }
            
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
        }
        
        // Update audio progress bar and time displays
        function updateAudioProgress(voiceNoteId, currentTime, duration) {
            if (!voiceNoteId || isNaN(currentTime) || isNaN(duration) || duration <= 0) return;
            
            // Throttle updates to prevent excessive DOM manipulation
            const now = Date.now();
            if (now - lastProgressUpdate < PROGRESS_UPDATE_THROTTLE) return;
            lastProgressUpdate = now;
            
            const progressFill = document.getElementById(`progress-fill-${voiceNoteId}`);
            const currentTimeEl = document.getElementById(`time-current-${voiceNoteId}`);
            
            if (progressFill) {
                // Extra safety check to prevent division by zero and invalid values
                const safeCurrentTime = Math.max(0, Math.min(currentTime, duration));
                const progress = Math.max(0, Math.min(100, (safeCurrentTime / duration) * 100));
                progressFill.style.width = `${progress}%`;
            }
            
            if (currentTimeEl) {
                currentTimeEl.textContent = formatDuration(Math.max(0, currentTime));
            }
        }
        
        // Seek to specific position in audio
        function seekAudio(voiceNoteId, event) {
            if (!currentPlayingAudio || !event) return;
            
            const progressBar = document.getElementById(`progress-bar-${voiceNoteId}`);
            if (!progressBar) return;
            
            const rect = progressBar.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const progressBarWidth = rect.width;
            
            if (progressBarWidth <= 0) return; // Prevent division by zero
            
            const clickPercentage = clickX / progressBarWidth;
            
            // Ensure percentage is between 0 and 1
            const seekPercentage = Math.max(0, Math.min(1, clickPercentage));
            
            if (!isNaN(currentPlayingAudio.duration) && currentPlayingAudio.duration > 0) {
                const seekTime = seekPercentage * currentPlayingAudio.duration;
                currentPlayingAudio.currentTime = seekTime;
                
                // Update progress immediately for responsive feedback
                updateAudioProgress(voiceNoteId, seekTime, currentPlayingAudio.duration);
            }
        }
        
        // Download voice note
        async function downloadVoiceNote(voiceNoteId) {
            try {
                const voiceNotes = await loadVoiceNotes();
                const voiceNote = voiceNotes.find(n => n.id === voiceNoteId);
                
                if (!voiceNote) {
                    updateVoiceStatus('Voice note not found', 'error');
                    return;
                }
                
                const url = URL.createObjectURL(voiceNote.audioBlob);
                const a = document.createElement('a');
                a.href = url;
                
                // Generate filename with date
                const date = new Date(voiceNote.timestamp);
                const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD
                const timeStr = date.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
                const extension = voiceNote.audioBlob.type.includes('webm') ? 'webm' : 'mp4';
                
                a.download = `dream-voice-note-${dateStr}-${timeStr}.${extension}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                updateVoiceStatus('Voice note downloaded', 'info');
                
            } catch (error) {
                console.error('Error downloading voice note:', error);
                updateVoiceStatus('Failed to download voice note', 'error');
            }
        }
        
        // Show delete confirmation for voice note
        function deleteVoiceNote(voiceNoteId) {
            // Clear any existing timeout for this voice note
            if (voiceDeleteTimeouts[voiceNoteId]) {
                clearTimeout(voiceDeleteTimeouts[voiceNoteId]);
                delete voiceDeleteTimeouts[voiceNoteId];
            }
            
            const voiceNoteElement = document.getElementById(`voice-note-${voiceNoteId}`);
            if (!voiceNoteElement) return; // Safety check
            
            // Add pending delete styling
            voiceNoteElement.classList.add('delete-pending');
            
            // Find and replace delete button with confirm button
            const deleteBtn = voiceNoteElement.querySelector(`button[data-voice-note-id="${voiceNoteId}"][data-action="delete-voice"]`);
            if (deleteBtn) {
                deleteBtn.outerHTML = `<button data-action="confirm-delete-voice" data-voice-note-id="${voiceNoteId}" class="voice-btn-base voice-btn-delete" style="animation: pulse 0.5s ease-in-out;">Confirm Delete</button>`;
            }
            
            // Set timeout to revert after specified time
            voiceDeleteTimeouts[voiceNoteId] = setTimeout(() => {
                cancelDeleteVoiceNote(voiceNoteId);
            }, CONSTANTS.MESSAGE_DURATION_EXTENDED);
        }

        // Actually delete the voice note after confirmation (with mutex protection)
        async function confirmDeleteVoiceNote(voiceNoteId) {
            return withMutex('voiceOperations', async () => {
                try {
                    // Clear the timeout
                    if (voiceDeleteTimeouts[voiceNoteId]) {
                        clearTimeout(voiceDeleteTimeouts[voiceNoteId]);
                        delete voiceDeleteTimeouts[voiceNoteId];
                    }
                    
                    // Stop playing if this note is currently playing
                    if (currentPlayingAudio) {
                        currentPlayingAudio.pause();
                        currentPlayingAudio = null;
                    }
                    
                    // Try to delete from IndexedDB first
                    let deleted = false;
                    if (isIndexedDBAvailable()) {
                        deleted = await deleteVoiceNoteFromIndexedDB(voiceNoteId);
                    }
                    
                    // If IndexedDB deletion failed or unavailable, delete from memory
                    if (!deleted) {
                        const index = memoryVoiceNotes.findIndex(n => n.id === voiceNoteId);
                        if (index !== -1) {
                            memoryVoiceNotes.splice(index, 1);
                            deleted = true;
                        }
                    }
                    
                    if (deleted) {
                        await updateRecordButtonState();
                        await displayVoiceNotes();
                        updateVoiceStatus('Voice note deleted', 'info');
                    } else {
                        updateVoiceStatus('Voice note not found', 'error');
                    }
                    
                } catch (error) {
                    console.error('Error deleting voice note:', error);
                    updateVoiceStatus('Failed to delete voice note', 'error');
                }
            });
        }

        // Cancel voice note delete and revert to normal state
        function cancelDeleteVoiceNote(voiceNoteId) {
            // Clear the timeout
            if (voiceDeleteTimeouts[voiceNoteId]) {
                clearTimeout(voiceDeleteTimeouts[voiceNoteId]);
                delete voiceDeleteTimeouts[voiceNoteId];
            }
            
            const voiceNoteElement = document.getElementById(`voice-note-${voiceNoteId}`);
            if (voiceNoteElement) {
                // Remove pending delete styling
                voiceNoteElement.classList.remove('delete-pending');
                
                // Replace confirm button with original delete button
                const confirmBtn = voiceNoteElement.querySelector(`button[data-voice-note-id="${voiceNoteId}"][data-action="confirm-delete-voice"]`);
                if (confirmBtn) {
                    confirmBtn.outerHTML = `<button data-action="delete-voice" data-voice-note-id="${voiceNoteId}" class="voice-btn-base voice-btn-delete">🗑️ Delete</button>`;
                }
            }
        }

        // CALENDAR & STATS SYSTEM

        let calendarState = {
            date: new Date(),
            dreamsByDate: {}
        };

        async function updateCalendarData() {
            const dreams = await loadDreams();
            calendarState.dreamsByDate = {};
            dreams.forEach(dream => {
                const dreamDate = new Date(dream.timestamp);
                const y = dreamDate.getFullYear();
                const m = String(dreamDate.getMonth() + 1).padStart(2, '0');
                const d = String(dreamDate.getDate()).padStart(2, '0');
                const date = `${y}-${m}-${d}`;

                if (!calendarState.dreamsByDate[date]) {
                    calendarState.dreamsByDate[date] = { count: 0, lucid: 0 };
                }
                calendarState.dreamsByDate[date].count++;
                if (dream.isLucid) {
                    calendarState.dreamsByDate[date].lucid++;
                }
            });
        }

        // Function moved to SECTION 5.4

        // Function moved to SECTION 5.4

        function getYearOptions(selectedYear) {
            let years = new Set();
            for(const date in calendarState.dreamsByDate) {
                years.add(parseInt(date.substring(0,4)));
            }
            const currentYear = new Date().getFullYear();
            years.add(currentYear);
            if(selectedYear) years.add(selectedYear);

            for(let i = -5; i <= 5; i++) {
                years.add(currentYear + i);
            }

            return Array.from(years).sort((a,b) => b-a).map(y => `<option value="${y}" ${y === selectedYear ? 'selected' : ''}>${y}</option>`).join('');
        }

        async function updateMonthlyStats(year, month) {
            const monthlyStatsContainer = document.getElementById('monthlyStatsContainer');
            if (!monthlyStatsContainer) return;

            monthlyStatsContainer.innerHTML = `<h3 class="text-primary mb-md">Monthly Stats</h3><div class="loading-state">Calculating stats...</div>`;

            try {
                const dreams = await loadDreams();
                const goals = await loadGoals();

                // 1. Filter dreams for the selected month
                const dreamsInMonth = dreams.filter(dream => {
                    const dreamDate = new Date(dream.timestamp);
                    return dreamDate.getFullYear() === year && dreamDate.getMonth() === month;
                });

                // 2. Calculate dream stats
                const totalDreams = dreamsInMonth.length;
                const lucidDreams = dreamsInMonth.filter(d => d.isLucid).length;

                const daysInMonth = new Date(year, month + 1, 0).getDate();

                const daysWithDreamsSet = new Set();
                dreamsInMonth.forEach(dream => {
                    daysWithDreamsSet.add(new Date(dream.timestamp).getDate());
                });
                const daysWithDreams = daysWithDreamsSet.size;

                const dreamDaysPercentage = daysInMonth > 0 ? ((daysWithDreams / daysInMonth) * 100).toFixed(1) : 0;
                const avgDreamsPerDay = daysInMonth > 0 ? (totalDreams / daysInMonth).toFixed(2) : 0;

                // 3. Calculate goal stats for the month
                const goalStats = getMonthlyGoalStats(goals, year, month);

                // 4. Render the stats
                const statsHTML = `
                    <h3 class="text-primary mb-md text-lg">Stats for ${new Date(year, month).toLocaleString('default', { month: 'long', year: 'numeric' })}</h3>
                    
                    <h4 class="text-secondary mb-sm mt-lg">📝 Dream Statistics</h4>
                    <div class="stats-grid" style="grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${totalDreams}</div>
                            <div class="stats-label">Total Dreams</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${lucidDreams}</div>
                            <div class="stats-label">Lucid Dreams</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${dreamDaysPercentage}%</div>
                            <div class="stats-label">Dream Recall Rate</div>
                            <div class="stats-detail">${daysWithDreams} of ${daysInMonth} days</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${avgDreamsPerDay}</div>
                            <div class="stats-label">Avg Dreams/Day</div>
                        </div>
                    </div>
                    
                    <h4 class="text-secondary mb-sm mt-lg">🎯 Goal Statistics</h4>
                    <div class="stats-grid" style="grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${goalStats.completed}</div>
                            <div class="stats-label">Goals Completed</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${goalStats.total}</div>
                            <div class="stats-label">Total Goals</div>
                            <div class="stats-detail">${goalStats.active} active</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${goalStats.completionRate}%</div>
                            <div class="stats-label">Completion Rate</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${goalStats.completed > 0 ? '🏆' : '📈'}</div>
                            <div class="stats-label">${goalStats.completed > 0 ? 'Achieving Goals!' : 'Keep Going!'}</div>
                        </div>
                    </div>
                `;

                monthlyStatsContainer.innerHTML = statsHTML;
            } catch (error) {
                console.error("Error calculating monthly stats:", error);
                monthlyStatsContainer.innerHTML = `<h3 class="text-primary mb-md">Monthly Stats</h3><div class="message-error">Could not load stats.</div>`;
            }
        }

        // Function moved to SECTION 5.4
        
        // Update the dream signs tab with the latest data
        async function updateDreamSignsTab() {
            const stats = await calculateDreamSignStats();
            renderDreamSignWordCloud(stats);
            renderDreamSignList(stats);
        }

        // STATS TAB SWITCHING FUNCTION
        async function switchStatsTab(tabName) {
    
        // Update tab buttons
        document.querySelectorAll('.stats-tab').forEach(tab => {
            tab.classList.remove('active');
        });
        document.querySelector(`.stats-tab[data-tab="${tabName}"]`).classList.add('active');
    
        // Update tab panels
        document.querySelectorAll('.stats-tab-panel').forEach(panel => {
            panel.style.display = 'none';
        });

        const panelId = `statsTab${tabName.charAt(0).toUpperCase() + tabName.slice(1).replace('-s', 'S')}`;
        const panel = document.getElementById(panelId);
        if (panel) {
            panel.style.display = 'block';
        }

        // --- NEW LOGIC STARTS HERE ---
        // Check if the content for this panel has already been loaded
        if (panel && panel.getAttribute('data-loaded') === 'true') {
            return; // Content is already there, do nothing else
        }

        // If not loaded, load the data now
        if (tabName === 'year') {
            const currentYear = calendarState.date.getFullYear();
            await updateYearlyStats(currentYear);
            await renderYearlyPieChart(currentYear);
        } else if (tabName === 'lifetime') {
            await updateLifetimeStats();
            await renderLifetimePieChart();
        } else if (tabName === 'dream-signs') {
            await updateDreamSignsTab();
        }
        
        // Mark the panel as loaded so we don't reload it again
        if (panel) {
            panel.setAttribute('data-loaded', 'true');
        }
}
        
        // YEARLY STATS FUNCTIONS
        async function updateYearlyStats(year) {
            const yearlyStatsContainer = document.getElementById('yearlyStatsContainer');
            if (!yearlyStatsContainer) return;
            
            yearlyStatsContainer.innerHTML = `<h3 class="text-primary mb-md">Yearly Stats</h3><div class="loading-state">Calculating yearly stats...</div>`;
            
            try {
                const dreams = await loadDreams();
                const goals = await loadGoals();
                
                // Filter dreams for the selected year
                const dreamsInYear = dreams.filter(dream => {
                    const dreamDate = new Date(dream.timestamp);
                    return dreamDate.getFullYear() === year;
                });
                
                // Calculate goal stats for the year
                const goalStats = getYearlyGoalStats(goals, year);
                
                if (dreamsInYear.length === 0 && goalStats.total === 0) {
                    yearlyStatsContainer.innerHTML = `
                        <h3 class="text-primary mb-md text-lg">Stats for ${year}</h3>
                        <div class="no-entries" style="padding: 20px;">No dreams or goals recorded for ${year} yet.</div>
                    `;
                    return;
                }
                
                // Calculate yearly stats
                const totalDreams = dreamsInYear.length;
                const lucidDreams = dreamsInYear.filter(d => d.isLucid).length;
                
                // Calculate days with dreams in the year
                const daysWithDreamsSet = new Set();
                dreamsInYear.forEach(dream => {
                    const dreamDate = new Date(dream.timestamp);
                    const dateKey = `${dreamDate.getFullYear()}-${String(dreamDate.getMonth() + 1).padStart(2, '0')}-${String(dreamDate.getDate()).padStart(2, '0')}`;
                    daysWithDreamsSet.add(dateKey);
                });
                const daysWithDreams = daysWithDreamsSet.size;
                
                // Calculate total days in year (accounting for leap years and current year)
                const isCurrentYear = year === new Date().getFullYear();
                const currentDate = new Date();
                let totalDaysInYear;
                
                if (isCurrentYear) {
                    // For current year, count from Jan 1 to today
                    const startOfYear = new Date(year, 0, 1);
                    const daysSinceStart = Math.ceil((currentDate.getTime() - startOfYear.getTime()) / (1000 * 3600 * 24)) + 1;
                    totalDaysInYear = daysSinceStart;
                } else {
                    // For past years, use full year
                    totalDaysInYear = (year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)) ? 366 : 365;
                }
                
                // Calculate percentages and averages
                const dreamDaysPercentage = totalDaysInYear > 0 ? ((daysWithDreams / totalDaysInYear) * 100).toFixed(1) : 0;
                const avgDreamsPerDay = totalDaysInYear > 0 ? (totalDreams / totalDaysInYear).toFixed(2) : 0;
                
                // Render the yearly stats
                const statsHTML = `
                    <h3 class="text-primary mb-md text-lg">Stats for ${year}</h3>
                    <div class="text-xs text-secondary mb-md" style="text-align: center; font-style: italic;">
                        ${isCurrentYear ? `January 1 to ${currentDate.toLocaleDateString()}` : `Full year ${year}`}
                    </div>
                    
                    <h4 class="text-secondary mb-sm mt-lg">📝 Dream Statistics</h4>
                    <div class="stats-grid" style="grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${totalDreams}</div>
                            <div class="stats-label">Total Dreams</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${lucidDreams}</div>
                            <div class="stats-label">Lucid Dreams</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${dreamDaysPercentage}%</div>
                            <div class="stats-label">Dream Recall Rate</div>
                            <div class="stats-detail">${daysWithDreams} of ${totalDaysInYear} days</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${avgDreamsPerDay}</div>
                            <div class="stats-label">Avg Dreams/Day</div>
                        </div>
                    </div>
                    
                    <h4 class="text-secondary mb-sm mt-lg">🎯 Goal Statistics</h4>
                    <div class="stats-grid" style="grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${goalStats.completed}</div>
                            <div class="stats-label">Goals Completed</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${goalStats.total}</div>
                            <div class="stats-label">Total Goals</div>
                            <div class="stats-detail">${goalStats.active} active</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${goalStats.completionRate}%</div>
                            <div class="stats-label">Completion Rate</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${goalStats.completed > 0 ? '🏆' : '📊'}</div>
                            <div class="stats-label">${goalStats.completed > 0 ? 'Great Progress!' : 'Keep Building!'}</div>
                        </div>
                    </div>
                `;
                
                yearlyStatsContainer.innerHTML = statsHTML;
                
            } catch (error) {
                console.error("Error calculating yearly stats:", error);
                yearlyStatsContainer.innerHTML = `<h3 class="text-primary mb-md">Yearly Stats</h3><div class="message-error">Could not load yearly stats.</div>`;
            }
        }
        
        async function renderYearlyPieChart(year) {
            const yearlyPieChartContainer = document.getElementById('yearlyPieChartContainer');
            if (!yearlyPieChartContainer) return;
            
            yearlyPieChartContainer.innerHTML = `<h3 class="text-primary mb-md">Year Dream Types</h3><div class="loading-state">Loading yearly chart...</div>`;
            
            try {
                const dreams = await loadDreams();
                const dreamsInYear = dreams.filter(dream => {
                    const dreamDate = new Date(dream.timestamp);
                    return dreamDate.getFullYear() === year;
                });
                
                const totalDreams = dreamsInYear.length;
                const lucidDreams = dreamsInYear.filter(d => d.isLucid).length;
                const regularDreams = totalDreams - lucidDreams;
                
                if (totalDreams === 0) {
                    yearlyPieChartContainer.innerHTML = `
                        <h3 class="text-primary mb-md">Year Dream Types</h3>
                        <div class="no-entries" style="padding: 20px;">No dreams recorded for ${year} to create a chart.</div>
                    `;
                    return;
                }
                
                const lucidPercentage = (lucidDreams / totalDreams) * 100;
                const regularPercentage = 100 - lucidPercentage;
                const lucidColor = 'var(--success-color)';
                const regularColor = 'var(--info-color)';
                const gradient = `conic-gradient(${lucidColor} 0% ${lucidPercentage.toFixed(2)}%, ${regularColor} ${lucidPercentage.toFixed(2)}% 100%)`;
                
                const chartHTML = `
                    <h3 class="text-primary mb-md">Year Dream Types</h3>
                    <div class="pie-chart-container">
                        <div class="pie-chart" style="background: ${gradient};">
                            <div class="pie-chart-center">
                                <div class="pie-chart-total">${totalDreams}</div>
                                <div class="pie-chart-label">Dreams</div>
                            </div>
                        </div>
                        <div class="pie-chart-legend">
                            <div class="legend-item">
                                <div class="legend-color-box" style="background: ${lucidColor};"></div>
                                <span>Lucid (${lucidDreams}) - ${lucidPercentage.toFixed(1)}%</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color-box" style="background: ${regularColor};"></div>
                                <span>Regular (${regularDreams}) - ${regularPercentage.toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>
                `;
                
                yearlyPieChartContainer.innerHTML = chartHTML;
                
            } catch (error) {
                console.error("Error rendering yearly pie chart:", error);
                yearlyPieChartContainer.innerHTML = `<h3 class="text-primary mb-md">Year Dream Types</h3><div class="message-error">Could not load yearly chart.</div>`;
            }
        }
        
        // LIFETIME STATS FUNCTIONS
        async function updateLifetimeStats() {
            const lifetimeStatsContainer = document.getElementById('lifetimeStatsContainer');
            if (!lifetimeStatsContainer) return;
            
            lifetimeStatsContainer.innerHTML = `<h3 class="text-primary mb-md">Lifetime Stats</h3><div class="loading-state">Calculating lifetime stats...</div>`;
            
            try {
                const dreams = await loadDreams();
                const goals = await loadGoals();
                
                // Calculate goal stats for lifetime
                const goalStats = getLifetimeGoalStats(goals);
                
                if (dreams.length === 0 && goalStats.total === 0) {
                    lifetimeStatsContainer.innerHTML = `
                        <h3 class="text-primary mb-md text-lg">Lifetime Stats</h3>
                        <div class="no-entries" style="padding: 20px;">No dreams or goals recorded yet to calculate lifetime stats.</div>
                    `;
                    return;
                }
                
                // Calculate lifetime stats
                const totalDreams = dreams.length;
                const lucidDreams = dreams.filter(d => d.isLucid).length;
                
                // Find first and last dream dates
                const dreamDates = dreams.map(d => new Date(d.timestamp)).sort((a, b) => a - b);
                const firstDreamDate = dreamDates[0];
                const currentDate = new Date();
                
                // Calculate total days from first entry to today
                const timeDiff = currentDate.getTime() - firstDreamDate.getTime();
                const totalDays = Math.ceil(timeDiff / (1000 * 3600 * 24)) + 1; // +1 to include both start and end days
                
                // Calculate days with dreams
                const daysWithDreamsSet = new Set();
                dreams.forEach(dream => {
                    const dreamDate = new Date(dream.timestamp);
                    const dateKey = `${dreamDate.getFullYear()}-${String(dreamDate.getMonth() + 1).padStart(2, '0')}-${String(dreamDate.getDate()).padStart(2, '0')}`;
                    daysWithDreamsSet.add(dateKey);
                });
                const daysWithDreams = daysWithDreamsSet.size;
                
                // Calculate percentages and averages
                const dreamDaysPercentage = totalDays > 0 ? ((daysWithDreams / totalDays) * 100).toFixed(1) : 0;
                const avgDreamsPerDay = totalDays > 0 ? (totalDreams / totalDays).toFixed(2) : 0;
                
                // Format the date range
                const startDateFormatted = firstDreamDate.toLocaleDateString();
                const endDateFormatted = currentDate.toLocaleDateString();
                
                // Render the lifetime stats
                const statsHTML = `
                    <h3 class="text-primary mb-md text-lg">Lifetime Stats</h3>
                    <div class="text-xs text-secondary mb-md" style="text-align: center; font-style: italic;">
                        ${dreams.length > 0 ? `${startDateFormatted} to ${endDateFormatted}` : 'Your dream journal journey'}
                    </div>
                    
                    ${dreams.length > 0 ? `
                    <h4 class="text-secondary mb-sm mt-lg">📝 Dream Statistics</h4>
                    <div class="stats-grid" style="grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${totalDreams}</div>
                            <div class="stats-label">Total Dreams</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${lucidDreams}</div>
                            <div class="stats-label">Lucid Dreams</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${dreamDaysPercentage}%</div>
                            <div class="stats-label">Dream Recall Rate</div>
                            <div class="stats-detail">${daysWithDreams} of ${totalDays} days</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${avgDreamsPerDay}</div>
                            <div class="stats-label">Avg Dreams/Day</div>
                        </div>
                    </div>
                    ` : ''}
                    
                    <h4 class="text-secondary mb-sm mt-lg">🎯 Goal Statistics</h4>
                    <div class="stats-grid" style="grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${goalStats.completed}</div>
                            <div class="stats-label">Goals Completed</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${goalStats.total}</div>
                            <div class="stats-label">Total Goals</div>
                            <div class="stats-detail">${goalStats.active} active</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${goalStats.completionRate}%</div>
                            <div class="stats-label">Overall Completion Rate</div>
                        </div>
                        <div class="stats-card card-sm text-center">
                            <div class="stats-number">${goalStats.completed >= 5 ? '🌟' : goalStats.completed > 0 ? '🏆' : '🎯'}</div>
                            <div class="stats-label">${goalStats.completed >= 5 ? 'Goal Master!' : goalStats.completed > 0 ? 'Making Progress!' : 'Start Your Journey!'}</div>
                        </div>
                    </div>
                `;
                
                lifetimeStatsContainer.innerHTML = statsHTML;
                
            } catch (error) {
                console.error("Error calculating lifetime stats:", error);
                lifetimeStatsContainer.innerHTML = `<h3 class="text-primary mb-md">Lifetime Stats</h3><div class="message-error">Could not load lifetime stats.</div>`;
            }
        }
        
        async function renderLifetimePieChart() {
            const lifetimePieChartContainer = document.getElementById('lifetimePieChartContainer');
            if (!lifetimePieChartContainer) return;
            
            lifetimePieChartContainer.innerHTML = `<h3 class="text-primary mb-md">All-Time Dream Types</h3><div class="loading-state">Loading lifetime chart...</div>`;
            
            try {
                const dreams = await loadDreams();
                const totalDreams = dreams.length;
                const lucidDreams = dreams.filter(d => d.isLucid).length;
                const regularDreams = totalDreams - lucidDreams;
                
                if (totalDreams === 0) {
                    lifetimePieChartContainer.innerHTML = `
                        <h3 class="text-primary mb-md">All-Time Dream Types</h3>
                        <div class="no-entries" style="padding: 20px;">No dreams recorded to create a lifetime chart.</div>
                    `;
                    return;
                }
                
                const lucidPercentage = (lucidDreams / totalDreams) * 100;
                const regularPercentage = 100 - lucidPercentage;
                const lucidColor = 'var(--success-color)';
                const regularColor = 'var(--info-color)';
                const gradient = `conic-gradient(${lucidColor} 0% ${lucidPercentage.toFixed(2)}%, ${regularColor} ${lucidPercentage.toFixed(2)}% 100%)`;
                
                const chartHTML = `
                    <h3 class="text-primary mb-md">All-Time Dream Types</h3>
                    <div class="pie-chart-container">
                        <div class="pie-chart" style="background: ${gradient};">
                            <div class="pie-chart-center">
                                <div class="pie-chart-total">${totalDreams}</div>
                                <div class="pie-chart-label">Dreams</div>
                            </div>
                        </div>
                        <div class="pie-chart-legend">
                            <div class="legend-item">
                                <div class="legend-color-box" style="background: ${lucidColor};"></div>
                                <span>Lucid (${lucidDreams}) - ${lucidPercentage.toFixed(1)}%</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color-box" style="background: ${regularColor};"></div>
                                <span>Regular (${regularDreams}) - ${regularPercentage.toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>
                `;
                
                lifetimePieChartContainer.innerHTML = chartHTML;
                
            } catch (error) {
                console.error("Error rendering lifetime pie chart:", error);
                lifetimePieChartContainer.innerHTML = `<h3 class="text-primary mb-md">All-Time Dream Types</h3><div class="message-error">Could not load lifetime chart.</div>`;
            }
        }

        // Calculate dream sign statistics
        async function calculateDreamSignStats() {
            const dreams = await loadDreams();
            const dreamSignStats = new Map();

            dreams.forEach(dream => {
                if (dream.dreamSigns && Array.isArray(dream.dreamSigns)) {
                    const uniqueSigns = [...new Set(dream.dreamSigns.map(s => s.trim().toLowerCase()))];

                    uniqueSigns.forEach(sign => {
                        if (!sign) return;

                        const stat = dreamSignStats.get(sign) || {
                            total: 0,
                            lucid: 0,
                            originalCase: sign
                        };

                        stat.total++;
                        if (dream.isLucid) {
                            stat.lucid++;
                        }
                        // A simple way to keep a consistent-ish casing
                        if (dream.dreamSigns.includes(stat.originalCase)) {
                            // prefer the casing that is already stored if it exists in the current dream
                        } else {
                            // otherwise, just take the first one we see
                            stat.originalCase = dream.dreamSigns.find(s => s.trim().toLowerCase() === sign);
                        }

                        dreamSignStats.set(sign, stat);
                    });
                }
            });

            const statsArray = [];
            for (const [sign, stat] of dreamSignStats.entries()) {
                statsArray.push({
                    sign: stat.originalCase,
                    total: stat.total,
                    lucid: stat.lucid,
                    lucidityRate: stat.total > 0 ? (stat.lucid / stat.total) : 0
                });
            }

            return statsArray;
        }

        // Render the detailed list of dream signs
        function renderDreamSignList(stats) {
            const container = document.getElementById('dreamSignListContainer');
            if (!container) return;

            const successfulSigns = stats.filter(stat => stat.lucid > 0);

            if (successfulSigns.length === 0) {
                container.innerHTML = `
                    <h3 class="text-primary mb-md">Dream Sign Lucidity Rate</h3>
                    <div class="no-entries" style="padding: 20px;">
                        You haven't had any lucid dreams triggered by your tracked dream signs yet.
                        Keep practicing reality checks when you notice them!
                    </div>
                `;
                return;
            }

            // Sort by lucidity rate (highest first)
            successfulSigns.sort((a, b) => b.lucidityRate - a.lucidityRate);

            const listHTML = successfulSigns.map(stat => {
                const percentage = (stat.lucidityRate * 100).toFixed(0);
                return `
                    <div class="stats-card card-sm text-left mb-sm">
                        <div class="flex-between">
                            <span class="font-semibold text-primary">⚡ ${escapeHtml(stat.sign)}</span>
                            <span class="status-success">${percentage}% Lucid</span>
                        </div>
                        <div class="progress-bar mt-sm mb-sm">
                            <div class="progress-fill progress-success" style="width: ${percentage}%;"></div>
                        </div>
                        <div class="text-sm text-secondary">
                            Triggered lucidity in <strong>${stat.lucid}</strong> of <strong>${stat.total}</strong> appearances.
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `
                <h3 class="text-primary mb-md">Dream Sign Lucidity Rate</h3>
                <p class="text-secondary mb-lg text-sm">This list shows dream signs that have successfully triggered a lucid dream at least once, sorted by their effectiveness.</p>
                ${listHTML}
            `;
        }

        // Render the dream sign word cloud
        function renderDreamSignWordCloud(stats) {
            const container = document.getElementById('dreamSignWordCloudContainer');
            if (!container) return;

            if (stats.length === 0) {
                container.innerHTML = `
                    <h3 class="text-primary mb-md">Dream Sign Word Cloud</h3>
                    <div class="no-entries" style="padding: 20px;">
                        Record dreams with dream signs to see your personal word cloud here!
                    </div>
                `;
                return;
            }

            // Sort by total frequency (most frequent first)
            const sortedByFrequency = [...stats].sort((a, b) => b.total - a.total);

            // Tiering system (6 tiers)
            const tierCount = 6;
            const tierSize = Math.max(1, Math.ceil(sortedByFrequency.length / tierCount));

            // Define styles for each tier (font size and HSL color)
            // Hues: Red(0), Orange(30), Yellow(55), Blue(220), Green(140), Purple(270)
            const styles = [
                { size: '2.5em', color: 'hsl(0, 85%, 65%)' },   // Tier 1: Bright Red
                { size: '2.1em', color: 'hsl(30, 85%, 60%)' },  // Tier 2: Bright Orange
                { size: '1.8em', color: 'hsl(55, 85%, 55%)' },  // Tier 3: Bright Yellow
                { size: '1.5em', color: 'hsl(220, 85%, 65%)' }, // Tier 4: Bright Blue
                { size: '1.2em', color: 'hsl(140, 75%, 50%)' }, // Tier 5: Medium Green
                { size: '1.0em', color: 'hsl(270, 75%, 60%)' }  // Tier 6: Medium-dim Purple
            ];

            const cloudHTML = sortedByFrequency.map((stat, index) => {
                const tier = Math.floor(index / tierSize);
                const style = styles[Math.min(tier, tierCount - 1)]; // Ensure we don't go out of bounds

                return `
                    <span class="word-cloud-item" style="font-size: ${style.size}; color: ${style.color};" title="${stat.total} appearances">
                        ${escapeHtml(stat.sign)}
                    </span>
                `;
            }).join('');

            container.innerHTML = `
                <h3 class="text-primary mb-md">Dream Sign Word Cloud</h3>
                <div class="word-cloud">
                    ${cloudHTML}
                </div>
            `;
        }

        // PIN SECURITY & ACCESS CONTROL SYSTEM
        
        // NEW UNIFIED PIN SCREEN RENDERER
        function renderPinScreen(targetElement, config) {
            if (!targetElement || !config) return;

            let inputsHTML = '';
            if (config.inputs) {
                inputsHTML = config.inputs.map(input => {
                    const valueAttr = input.value ? `value="${escapeAttr(input.value)}"` : '';
                    const inputClass = input.class || 'form-control';
                    return `<input
                        type="${input.type}"
                        id="${input.id}"
                        class="${inputClass}"
                        placeholder="${escapeAttr(input.placeholder)}"
                        ${input.maxLength ? `maxlength="${input.maxLength}"` : ''}
                        ${valueAttr}
                        style="margin-bottom: 10px;"
                    >`;
                }).join('');
            }

            let buttonsHTML = '';
            if (config.buttons) {
                buttonsHTML = config.buttons.map(button => `
                    <button
                        data-action="${button.action}"
                        class="btn ${button.class}"
                        ${button.id ? `id="${button.id}"` : ''}
                    >
                        ${escapeHtml(button.text)}
                    </button>
                `).join('');
            }

            let linksHTML = '';
            if (config.links) {
                linksHTML = config.links.map(link => `
                    <span
                        data-action="${link.action}"
                        class="pin-setup-link"
                        ${link.id ? `id="${link.id}"` : ''}
                        style="${link.style || ''}"
                    >
                        ${escapeHtml(link.text)}
                    </span>
                `).join('');
            }

            const iconHTML = config.icon ? `<div class="text-4xl mb-lg">${config.icon}</div>` : '';
            const messageHTML = config.message ? `<p id="pinMessage" class="text-secondary mb-lg line-height-relaxed">${config.message}</p>` : '';
            const feedbackHTML = config.feedbackContainer ? `<div id="pinFeedback" class="notification-message"></div><div id="pinSuccess" class="notification-message"></div><div id="pinInfo" class="notification-message"></div>` : '';

            targetElement.innerHTML = `
                ${iconHTML}
                <h2 id="pinTitle" class="text-primary mb-md text-xl">${escapeHtml(config.title)}</h2>
                ${messageHTML}
                <div id="pinInputsContainer">${inputsHTML}</div>
                <div class="pin-buttons">
                    ${buttonsHTML}
                </div>
                <div id="pinLinksContainer" style="margin-top: 15px;">${linksHTML}</div>
                ${feedbackHTML}
            `;

            // Auto-focus the first input if it exists
            if (config.inputs && config.inputs.length > 0) {
                setTimeout(() => {
                    const firstInput = document.getElementById(config.inputs[0].id);
                    if (firstInput) {
                        firstInput.focus();
                    }
                }, CONSTANTS.FOCUS_DELAY_MS);
            }
        }

        // Show warning when storage isn't persistent
        function showStorageWarning() {
            const warning = document.createElement('div');
            warning.id = 'storageWarning';
            warning.className = 'message-warning mb-lg mx-lg';
            warning.innerHTML = `
                ⚠️ <strong>Storage Warning:</strong> Your dreams are stored temporarily in memory only. 
                <br>They will be lost when you close this tab. Please export your dreams regularly!
                <br><small>To enable permanent storage, access this page through a web server.</small>
            `;
            
            const container = document.querySelector('.container');
            container.insertBefore(warning, container.children[2]);
        }

        // Simple hash function for PIN (DEPRECATED - kept for migration)
        function hashPinLegacy(pin) {
            let hash = 0;
            for (let i = 0; i < pin.length; i++) {
                const char = pin.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString();
        }

        // Secure PIN hashing using existing crypto infrastructure
        async function hashPinSecure(pin, salt = null) {
            try {
                if (!salt) salt = generateSalt();
                
                // Use existing deriveKey function but make result extractable for storage
                const encoder = new TextEncoder();
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(pin),
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits']
                );
                
                // Derive bits instead of key to avoid extractability issues
                const derivedBits = await crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: CONSTANTS.CRYPTO_PBKDF2_ITERATIONS,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    CONSTANTS.CRYPTO_KEY_LENGTH // 32 bytes
                );
                
                // Convert to hex string
                const hashArray = Array.from(new Uint8Array(derivedBits));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                
                // Convert salt to hex string  
                const saltArray = Array.from(salt);
                const saltHex = saltArray.map(b => b.toString(16).padStart(2, '0')).join('');
                
                return {
                    hash: hashHex,
                    salt: saltHex
                };
            } catch (error) {
                console.error('Secure PIN hashing error:', error);
                throw new Error('Failed to hash PIN securely');
            }
        }

        // Detect if stored PIN data is old format (simple hash) or new format (secure)
        function isLegacyPinFormat(storedData) {
            // Legacy format is just a simple hash string
            // New format is JSON with hash and salt properties
            if (typeof storedData === 'string') {
                try {
                    const parsed = JSON.parse(storedData);
                    return !(parsed && parsed.hash && parsed.salt);
                } catch (e) {
                    return true; // Not JSON, so it's legacy
                }
            }
            return true;
        }

        // PIN storage with fallback system (same as main app)
        let pinStorage = {
            hash: null,
            resetTime: null
        };

        // Check if PIN is set up (with fallback storage)
        function isPinSetup() {
            // Try localStorage first
            if (isLocalStorageAvailable()) {
                return localStorage.getItem('dreamJournalPinHash') !== null;
            }
            
            // Fallback to memory storage
            return pinStorage.hash !== null;
        }

        // Store PIN hash (with fallback storage) - UPDATED for secure hashing
        async function storePinHash(pin) {
            if (!pin) {
                return false;
            }
            
            try {
                // Use secure hashing
                const { hash, salt } = await hashPinSecure(pin);
                const secureData = JSON.stringify({ hash, salt, version: 'secure' });
                
                // Try localStorage first
                if (isLocalStorageAvailable()) {
                    try {
                        localStorage.setItem('dreamJournalPinHash', secureData);
                        return true;
                    } catch (error) {
                        console.error('Error storing secure PIN hash:', error);
                        // Fall through to memory storage
                    }
                }
                
                // Fallback to memory storage
                pinStorage.hash = secureData;
                return true;
            } catch (error) {
                console.error('Error storing secure PIN hash:', error);
                return false;
            }
        }

        // Get stored PIN hash (with fallback storage) - UPDATED for secure hashing
        function getStoredPinData() {
            // Try localStorage first
            if (isLocalStorageAvailable()) {
                const data = localStorage.getItem('dreamJournalPinHash');
                if (data) return data;
            }
            
            // Fallback to memory storage
            return pinStorage.hash;
        }

        // Verify PIN against stored hash - UPDATED to handle both legacy and secure formats
        async function verifyPinHash(enteredPin, storedData) {
            if (!storedData) return false;
            
            try {
                if (isLegacyPinFormat(storedData)) {
                    // Legacy format - use simple hash comparison
                    const legacyHash = hashPinLegacy(enteredPin);
                    return legacyHash === storedData;
                } else {
                    // Secure format - parse and verify
                    const { hash: storedHash, salt: storedSaltHex } = JSON.parse(storedData);
                    
                    // Convert salt from hex back to Uint8Array
                    const saltArray = new Uint8Array(storedSaltHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                    
                    // Hash the entered PIN with the stored salt
                    const { hash: enteredHash } = await hashPinSecure(enteredPin, saltArray);
                    
                    return enteredHash === storedHash;
                }
            } catch (error) {
                console.error('Error verifying PIN:', error);
                return false;
            }
        }

        // Remove PIN hash (with fallback storage) - works with both legacy and secure formats
        function removePinHash() {
            // Remove from localStorage if available
            if (isLocalStorageAvailable()) {
                localStorage.removeItem('dreamJournalPinHash');
            }
            
            // Remove from memory storage
            pinStorage.hash = null;
        }

        // Store reset time (with fallback storage)
        function storeResetTime(time) {
            // Try localStorage first
            if (isLocalStorageAvailable()) {
                try {
                    localStorage.setItem('dreamJournalPinResetTime', time.toString());
                    return true;
                } catch (error) {
                    console.error('storeResetTime: Failed to save to localStorage:', error);
                }
            }
            
            // Fallback to memory storage
            pinStorage.resetTime = time;
            return true;
        }

        // Get reset time (with fallback storage)
        function getResetTime() {
            // Try localStorage first
            if (isLocalStorageAvailable()) {
                const time = localStorage.getItem('dreamJournalPinResetTime');
                if (time) return parseInt(time);
            }
            
            // Fallback to memory storage
            return pinStorage.resetTime;
        }

        // Remove reset time (with fallback storage)
        function removeResetTime() {
            // Remove from localStorage if available
            if (isLocalStorageAvailable()) {
                localStorage.removeItem('dreamJournalPinResetTime');
            }
            
            // Remove from memory storage
            pinStorage.resetTime = null;
        }

        // Update security controls visibility
        // Note: Lock button is ALWAYS visible for better UX - logic handled in toggleLock()
        function updateSecurityControls() {
            const lockBtn = document.getElementById('lockBtn');
            const lockBtnSettings = document.getElementById('lockBtnSettings');
            const setupBtnSettings = document.getElementById('setupPinBtnSettings');
            
            // Always show the lock button - much simpler UX!
            if (lockBtn) {
                lockBtn.style.display = 'inline-block';
                if (isPinSetup()) {
                    if (isUnlocked && !isAppLocked) {
                        lockBtn.textContent = '🔒 Lock Journal';
                        lockBtn.title = 'Lock your journal with your PIN to keep dreams private';
                    } else {
                        lockBtn.textContent = '🔓 Unlock Journal'; // This case shouldn't happen much since we use lock screen
                        lockBtn.title = 'Unlock your journal by entering your PIN';
                    }
                } else {
                    lockBtn.textContent = '🔒 Setup & Lock';
                    lockBtn.title = 'Set up a PIN to secure your dreams, then lock the journal';
                }
            }
            
            // Always show settings lock button too
            if (lockBtnSettings) {
                lockBtnSettings.style.display = 'inline-block';
                if (isPinSetup()) {
                    if (isUnlocked && !isAppLocked) {
                        lockBtnSettings.textContent = '🔒 Lock Journal';
                        lockBtnSettings.title = 'Lock your journal with your PIN to keep dreams private';
                    } else {
                        lockBtnSettings.textContent = '🔓 Unlock Journal';
                        lockBtnSettings.title = 'Unlock your journal by entering your PIN';
                    }
                } else {
                    lockBtnSettings.textContent = '🔒 Setup & Lock';
                    lockBtnSettings.title = 'Set up a PIN to secure your dreams, then lock the journal';
                }
            }
            
            // Update setup button text (only exists in settings)
            if (setupBtnSettings) {
                setupBtnSettings.textContent = isPinSetup() ? '⚙️ Change/Remove PIN' : '⚙️ Setup PIN';
            }
            
            // Ensure correct app state
            if (!isPinSetup()) {
                isUnlocked = true;
                isAppLocked = false;
            }
        }

        // Show Remove PIN option
        function showRemovePin() {
            const pinContainer = document.querySelector('#pinOverlay .pin-container');
            renderPinScreen(pinContainer, {
                title: 'Remove PIN Protection',
                icon: '⚠️',
                message: 'Enter your current PIN to remove protection. Your dreams will no longer be secured.',
                inputs: [
                    { id: 'pinInput', type: 'password', placeholder: 'Enter current PIN', class: 'pin-input', maxLength: 6 }
                ],
                buttons: [
                    { text: 'Remove PIN', action: 'confirm-remove-pin', class: 'btn-primary' },
                    { text: 'Cancel', action: 'hide-pin-overlay', class: 'btn-secondary' }
                ],
                feedbackContainer: true
            });
            document.getElementById('pinOverlay').style.display = 'flex';
        }

        // Execute PIN removal after verification
        async function executePinRemoval() {
            try {
                // Remove the PIN
                removePinHash();

                const pinContainer = document.querySelector('#pinOverlay .pin-container');
                renderPinScreen(pinContainer, {
                    title: 'PIN Removed',
                    icon: '✅',
                    message: 'PIN protection has been removed. Your dreams are no longer secured.',
                    buttons: [
                        { text: 'Close', action: 'complete-pin-removal', class: 'btn-primary' }
                    ]
                });

                isUnlocked = true;
            } catch (error) {
                console.error('Error removing PIN:', error);
                showMessage('error', 'Error removing PIN. Please try again.');
            }
        }

        // Confirm PIN removal - UPDATED for secure hashing
        async function confirmRemovePin() {
            const enteredPin = document.getElementById('pinInput').value;
            
            if (!enteredPin) {
                showMessage('error', 'Please enter your current PIN');
                return;
            }
            
            try {
                const storedData = getStoredPinData();
                const isValid = await verifyPinHash(enteredPin, storedData);
                
                if (!isValid) {
                    const message = document.getElementById('pinMessage');
                    message.textContent = 'Incorrect PIN. Please try again.';
                    message.style.color = 'var(--error-color)';
                    document.getElementById('pinInput').value = '';
                    return;
                }
                
                await executePinRemoval();
                
            } catch (error) {
                console.error('Error removing PIN:', error);
                showMessage('error', 'Error removing PIN. Please try again.');
            }
        }

        // Complete PIN removal and close overlay
        async function completePinRemoval() {
            resetPinOverlay();
            hidePinOverlay();
            
            // Reset failed attempts since PIN removal was successful
            failedPinAttempts = 0;
            
            // PIN removed - unlock the app
            isUnlocked = true;
            isAppLocked = false;
            
            console.log('PIN removal complete - ensuring tabs are visible');
            
            // Ensure all tabs are visible (PIN is removed, no need to hide)
            showAllTabButtons();
            
            updateSecurityControls();
            await displayDreams();
        }

        // Show inline message
        function showMessage(type, message, elementId = null) {
            // Clear all messages first
            document.getElementById('pinFeedback').style.display = 'none';
            document.getElementById('pinSuccess').style.display = 'none';
            document.getElementById('pinInfo').style.display = 'none';
            
            let element;
            if (elementId) {
                element = document.getElementById(elementId);
            } else {
                switch(type) {
                    case 'error': element = document.getElementById('pinFeedback'); break;
                    case 'success': element = document.getElementById('pinSuccess'); break;
                    case 'info': element = document.getElementById('pinInfo'); break;
                }
            }
            
            if (element) {
                element.textContent = message;
                element.className = `notification-message ${type}`;
                element.style.display = 'block';
                
                // Auto-hide success messages after duration
                if (type === 'success') {
                    setTimeout(() => {
                        element.style.display = 'none';
                    }, CONSTANTS.MESSAGE_DURATION_MEDIUM);
                }
            }
        }

        // Verify PIN - UPDATED for secure hashing with migration
        // MOVE TO: SECTION 5.6 - PIN verification logic
        async function verifyPin() {
            const enteredPin = document.getElementById('pinInput').value;
            if (!enteredPin) {
                showMessage('error', 'Please enter a PIN');
                return;
            }
            
            try {
                const storedData = getStoredPinData();
                const isValid = await verifyPinHash(enteredPin, storedData);
                
                if (isValid) {
                    // Check if we need to migrate from legacy format
                    if (isLegacyPinFormat(storedData)) {
                        showMessage('info', 'Upgrading PIN security...');
                        
                        // Migrate to secure format
                        const migrationSuccess = await storePinHash(enteredPin);
                        if (migrationSuccess) {
                            showMessage('success', 'PIN security upgraded successfully!');
                        } else {
                            showMessage('warning', 'PIN security upgrade failed, but access granted.');
                        }
                        
                        // Small delay to let user see the upgrade message
                        await new Promise(resolve => setTimeout(resolve, 1500));
                    }
                    
                    isUnlocked = true;
                    isAppLocked = false; // Ensure app is not locked after successful PIN entry
                    failedPinAttempts = 0; // Reset failed attempts on success
                    
                    console.log('PIN overlay unlock successful - showing all tabs');
                    
                    hidePinOverlay();
                    
                    // Show all tabs again if they were hidden
                    showAllTabButtons();
                    
                    updateSecurityControls();
                    await displayDreams();
                    document.getElementById('pinInput').value = '';
                } else {
                    failedPinAttempts++;
                    
                    // Show forgot PIN link after failed attempts
                    if (failedPinAttempts >= CONSTANTS.FAILED_PIN_ATTEMPT_LIMIT) {
                        const forgotPinLink = document.getElementById('forgotPinLink');
                        if(forgotPinLink) forgotPinLink.style.display = 'block';
                        showMessage('error', 'Incorrect PIN. You can use "Forgot PIN?" below if needed.');
                    } else {
                        showMessage('error', 'Incorrect PIN. Please try again.');
                    }
                    
                    document.getElementById('pinInput').value = '';
                    document.getElementById('pinInput').focus();
                }
            } catch (error) {
                console.error('Error verifying PIN:', error);
                showMessage('error', 'PIN verification failed. Please try again.');
                document.getElementById('pinInput').value = '';
            }
        }

        // Show Forgot PIN options
        async function showForgotPin() {
            const resetTime = getResetTime();
            if (resetTime) {
                const remainingTime = resetTime - Date.now();
                if (remainingTime > 0) {
                    showTimerRecovery(remainingTime);
                    return;
                } else {
                    // Timer expired, allow reset
                    removeResetTime();
                    removePinHash();
                    isUnlocked = true;
                    failedPinAttempts = 0;
                    hidePinOverlay();
                    updateSecurityControls();
                    displayDreams();
                    
                    setTimeout(() => {
                        const container = document.querySelector('.main-content');
                        createInlineMessage('info', 'PIN reset timer has expired. Your PIN has been removed. You can set a new one if desired.', {
                            container: container,
                            position: 'top',
                            duration: 8000
                        });
                    }, 100);
                    return;
                }
            }

            const pinContainer = document.querySelector('#pinOverlay .pin-container');
            renderPinScreen(pinContainer, {
                title: 'PIN Recovery',
                icon: '🔑',
                message: '<strong>Choose a recovery method:</strong><br><br>' +
                         '<strong>Option 1:</strong> Enter 3 of your dream titles exactly as written<br>' +
                         '<em style="font-size: 0.9em; color: var(--text-secondary);">(Note: "Untitled Dream" entries are not valid)</em><br><br>' +
                         '<strong>Option 2:</strong> Wait 72 hours for automatic reset<br>' +
                         '<em style="font-size: 0.9em; color: var(--text-secondary);">(Your dreams will remain safe)</em>',
                buttons: [
                    { text: 'Verify Dream Titles', action: 'start-title-recovery', class: 'btn-primary' },
                    { text: 'Start 72hr Timer', action: 'start-timer-recovery', class: 'btn-secondary', id: 'timerBtn' },
                    { text: 'Cancel', action: 'hide-pin-overlay', class: 'btn-secondary' }
                ],
                feedbackContainer: true
            });
        }

        // Start dream title recovery (Updated for Event Delegation)
        async function startTitleRecovery() {
            const dreams = await loadDreams();
            const validDreams = dreams.filter(d => d.title !== 'Untitled Dream');
            const pinContainer = document.querySelector('#pinOverlay .pin-container');

            if (validDreams.length < 3) {
                renderPinScreen(pinContainer, {
                    title: 'PIN Recovery',
                    icon: '🔑',
                    message: '<span style="color: var(--error-color);">You need at least 3 dreams with custom titles to use this recovery method.</span><br><br>Please use the 72-hour timer option instead.',
                    buttons: [
                        { text: 'Start 72hr Timer', action: 'start-timer-recovery', class: 'btn-secondary', id: 'timerBtn' },
                        { text: 'Cancel', action: 'hide-pin-overlay', class: 'btn-secondary' }
                    ],
                    feedbackContainer: false
                });
                return;
            }

            renderPinScreen(pinContainer, {
                title: 'Verify Your Dreams',
                icon: '🔑',
                message: 'Enter exactly 3 of your dream titles:<br><em class="text-sm text-secondary">Must match exactly, including capitalisation</em>',
                inputs: [
                    { id: 'recovery1', type: 'text', placeholder: 'Dream title 1', class: 'form-control' },
                    { id: 'recovery2', type: 'text', placeholder: 'Dream title 2', class: 'form-control' },
                    { id: 'recovery3', type: 'text', placeholder: 'Dream title 3', class: 'form-control' }
                ],
                buttons: [
                    { text: 'Verify Titles', action: 'verify-dream-titles', class: 'btn-primary' },
                    { text: 'Cancel', action: 'hide-pin-overlay', class: 'btn-secondary' }
                ],
                feedbackContainer: true
            });
        }

        // Verify dream titles for recovery - UPDATED for secure hashing
        async function verifyDreamTitles() {
            const title1 = document.getElementById('recovery1').value.trim();
            const title2 = document.getElementById('recovery2').value.trim();
            const title3 = document.getElementById('recovery3').value.trim();
            const feedback = document.getElementById('pinFeedback');
            
            if (!title1 || !title2 || !title3) {
                feedback.innerHTML = '<span style="color: var(--error-color);">Please enter all 3 dream titles</span>';
                return;
            }
            
            const dreams = await loadDreams();
            const validDreams = dreams.filter(d => d.title !== 'Untitled Dream');
            const dreamTitles = validDreams.map(d => d.title);
            
            const titles = [title1, title2, title3];
            const uniqueTitles = [...new Set(titles)];
            
            if (uniqueTitles.length !== 3) {
                feedback.innerHTML = '<span style="color: var(--error-color);">Please enter 3 DIFFERENT dream titles. Each title must be unique.</span>';
                return;
            }
            
            const allValid = titles.every(t => dreamTitles.includes(t));
            
            if (allValid) {
                removePinHash();
                removeResetTime();
                
                const pinContainer = document.querySelector('#pinOverlay .pin-container');
                renderPinScreen(pinContainer, {
                    title: 'Recovery Successful',
                    icon: '✅',
                    message: '<span style="color: var(--success-color);">Your PIN has been removed. You can now set a new secure PIN.</span><br><br>Click below to continue.',
                    buttons: [
                        { text: 'Continue', action: 'complete-recovery', class: 'btn-primary' }
                    ]
                });
                
                isUnlocked = true;
                failedPinAttempts = 0;
                updateTimerWarning();
            } else {
                feedback.innerHTML = '<span style="color: var(--error-color);">One or more titles did not match. Please try again with exact titles from your dreams.</span>';
            }
        }

        // Start timer recovery
        function startTimerRecovery() {
            const pinContainer = document.querySelector('#pinOverlay .pin-container');
            renderPinScreen(pinContainer, {
                title: 'Confirm Timer Reset',
                icon: '⏳',
                message: '<span style="color: var(--error-color); font-weight: 600;">⚠️ Warning</span><br><br>' +
                         'This will start a 72-hour countdown. After 72 hours, your PIN will be automatically removed.<br><br>' +
                         '<span style="color: var(--text-secondary);">Your dreams will remain safe and will not be deleted.</span><br><br>' +
                         'Do you want to continue?',
                buttons: [
                    { text: 'Yes, Start Timer', action: 'confirm-start-timer', class: 'btn-primary' },
                    { text: 'No, Cancel', action: 'hide-pin-overlay', class: 'btn-secondary' }
                ]
            });
        }

        // Confirm and actually start the timer
        function confirmStartTimer() {
            const resetTime = Date.now() + (CONSTANTS.PIN_RESET_HOURS * 60 * 60 * 1000); // hours from now
            storeResetTime(resetTime);
            showTimerRecovery(CONSTANTS.PIN_RESET_HOURS * 60 * 60 * 1000);
            updateTimerWarning(); // Show warning banner
        }

        // Update timer warning banner
        function updateTimerWarning() {
            const warningBanner = document.getElementById('timerWarning');
            const warningTime = document.getElementById('timerWarningTime');
            
            if (!warningBanner || !warningTime) return; // Safety check
            
            const resetTime = getResetTime();
            if (resetTime) {
                const remainingMs = resetTime - Date.now();
                if (remainingMs > 0) {
                    const hours = Math.ceil(remainingMs / (1000 * 60 * 60));
                    const days = Math.ceil(hours / 24);
                    
                    let timeDisplay = '';
                    if (days > 1) {
                        timeDisplay = `${days} days remaining`;
                    } else if (hours > 1) {
                        timeDisplay = `${hours} hours remaining`;
                    } else {
                        timeDisplay = 'Less than 1 hour remaining';
                    }
                    
                    warningTime.textContent = `(${timeDisplay})`;
                    warningBanner.classList.add('active');
                } else {
                    warningBanner.classList.remove('active');
                }
            } else {
                warningBanner.classList.remove('active');
            }
        }

        // Cancel reset timer - now requires PIN
        function cancelResetTimer() {
            const pinOverlay = document.getElementById('pinOverlay');
            const pinContainer = pinOverlay.querySelector('.pin-container');
            
            renderPinScreen(pinContainer, {
                title: 'Cancel PIN Reset',
                icon: '⚠️',
                message: 'To cancel the pending PIN reset, please enter your current PIN.',
                inputs: [
                    { id: 'pinInput', type: 'password', placeholder: 'Enter current PIN', class: 'pin-input', maxLength: 6 }
                ],
                buttons: [
                    { text: 'Confirm Cancellation', action: 'confirm-cancel-timer', class: 'btn-primary' },
                    { text: 'Back', action: 'hide-pin-overlay', class: 'btn-secondary' }
                ],
                feedbackContainer: true
            });
            
            pinOverlay.style.display = 'flex';
        }

        // Actually cancel the timer - NOW requires PIN verification
        async function confirmCancelTimer() {
            const enteredPin = document.getElementById('pinInput').value;
            if (!enteredPin) {
                showMessage('error', 'Please enter your PIN.');
                return;
            }

            const storedData = getStoredPinData();
            const isValid = await verifyPinHash(enteredPin, storedData);

            if (isValid) {
                removeResetTime();
                updateTimerWarning();
                hidePinOverlay();

                // Show a success message in the main content area
                const container = document.querySelector('.main-content');
                if (container) {
                    createInlineMessage('success', 'PIN reset timer has been successfully cancelled.', {
                        container: document.querySelector('.container'),
                        position: 'top',
                        duration: 5000
                    });
                }
            } else {
                showMessage('error', 'Incorrect PIN. The reset timer remains active.');
            }
        }

        // Show timer recovery status
        function showTimerRecovery(remainingMs) {
            const hours = Math.ceil(remainingMs / (1000 * 60 * 60));
            const days = Math.ceil(hours / 24);
            
            let timeDisplay = '';
            if (days > 1) {
                timeDisplay = `${days} days`;
            } else if (hours > 1) {
                timeDisplay = `${hours} hours`;
            } else {
                timeDisplay = 'Less than 1 hour';
            }

            const pinContainer = document.querySelector('#pinOverlay .pin-container');
            renderPinScreen(pinContainer, {
                title: 'Recovery Timer Active',
                icon: '⏳',
                message: `PIN reset timer is active.<br><br><strong>Time remaining: ${timeDisplay}</strong><br><br><em style="font-size: 0.9em; color: var(--text-secondary);">Check back later, or try the dream title recovery method instead.</em>`,
                buttons: [
                    { text: 'Try Title Recovery', action: 'start-title-recovery', class: 'btn-primary' },
                    { text: 'Cancel', action: 'hide-pin-overlay', class: 'btn-secondary' }
                ]
            });
        }

        // Complete recovery process
        async function completeRecovery() {
            resetPinOverlay();
            hidePinOverlay();
            
            isUnlocked = true;
            isAppLocked = false;
            
            console.log('PIN overlay recovery complete - showing all tabs');
            
            showAllTabButtons();
            
            updateSecurityControls();
            updateTimerWarning();
            await displayDreams();
            
            const container = document.querySelector('.main-content');
            if (container) {
                createInlineMessage('success', 'Recovery complete! You can now set a new PIN from the security controls if desired.', {
                    container: container,
                    position: 'top',
                    duration: 5000
                });
            }
        }

        // LOCK SCREEN TAB FUNCTIONS
        
        // Verify PIN on lock screen
        async function verifyLockScreenPin() {
            const pinInput = document.getElementById('lockScreenPinInput');
            if (!pinInput) return;
            
            const enteredPin = pinInput.value;
            if (!enteredPin) {
                showLockScreenMessage('error', 'Please enter a PIN');
                return;
            }
            
            try {
                const storedData = getStoredPinData();
                const isValid = await verifyPinHash(enteredPin, storedData);
                
                if (isValid) {
                    showLockScreenMessage('success', 'PIN verified! Unlocking journal...');
                    
                    failedPinAttempts = 0;
                    isUnlocked = true;
                    isAppLocked = false;
                    
                    console.log('Lock screen unlock successful - showing all tabs');
                    
                    pinInput.value = '';
                    
                    setTimeout(() => {
                        showAllTabButtons();
                        const targetTab = (preLockActiveTab === 'lock') ? 'journal' : preLockActiveTab;
                        switchAppTab(targetTab);
                        updateSecurityControls();
                    }, 200);
                    
                } else {
                    failedPinAttempts++;
                    pinInput.value = '';
                    if (failedPinAttempts >= CONSTANTS.FAILED_PIN_ATTEMPT_LIMIT) {
                        showLockScreenMessage('error', 'Incorrect PIN. Use "Forgot PIN?" if needed.');
                    } else {
                        showLockScreenMessage('error', 'Incorrect PIN. Please try again.');
                    }
                }
            } catch (error) {
                console.error('Lock screen PIN verification error:', error);
                showLockScreenMessage('error', 'PIN verification failed. Please try again.');
                pinInput.value = '';
            }
        }
        
        // Show forgot PIN options on lock screen
        async function showLockScreenForgotPin() {
            const resetTime = getResetTime();
            if (resetTime) {
                const remainingTime = resetTime - Date.now();
                if (remainingTime > 0) {
                    const hours = Math.ceil(remainingTime / (1000 * 60 * 60));
                    const days = Math.ceil(hours / 24);
                    let timeDisplay = days > 1 ? `${days} days` : hours > 1 ? `${hours} hours` : 'Less than 1 hour';
                    showLockScreenMessage('info', `Recovery timer active. Time remaining: ${timeDisplay}. Press "Forgot PIN?" again when timer expires to unlock.`);
                } else {
                    removeResetTime();
                    removePinHash();
                    isUnlocked = true;
                    isAppLocked = false;
                    switchAppTab(preLockActiveTab);
                    updateSecurityControls();
                }
                return;
            }
            
            const dreams = await loadDreams();
            const validDreams = dreams.filter(d => d.title !== 'Untitled Dream');
            const lockCard = document.querySelector('#lockTab > div > div');

            if (lockCard) {
                renderPinScreen(lockCard, {
                    title: 'PIN Recovery',
                    icon: '🔑',
                    message: `
                        <strong>Choose a recovery method to regain access:</strong>
                        <div class="card-sm mb-md text-left mt-lg">
                            <h4 class="text-primary mb-sm">📝 Dream Title Verification</h4>
                            <p class="text-secondary text-sm mb-sm">Enter 3 of your dream titles exactly as written (case-sensitive)</p>
                            <button data-action="start-lock-screen-title-recovery" class="btn btn-primary btn-small" ${validDreams.length < 3 ? 'disabled' : ''}>Verify Dream Titles</button>
                            ${validDreams.length < 3 ? `<p class="text-xs text-warning mt-sm">You need at least 3 dreams with custom titles to use this method. You have ${validDreams.length}.</p>` : ''}
                        </div>
                        <div class="card-sm mb-lg text-left">
                            <h4 class="text-warning mb-sm">⏰ 72-Hour Timer Reset</h4>
                            <p class="text-secondary text-sm mb-sm">Start a timer that will automatically remove your PIN after 72 hours</p>
                            <button data-action="start-lock-screen-timer-recovery" class="btn btn-primary btn-small">Start Timer Reset</button>
                        </div>
                    `,
                    buttons: [
                        { text: '← Back to PIN Entry', action: 'return-to-lock-screen', class: 'btn-secondary' }
                    ],
                    feedbackContainer: true
                });
            } else {
                showLockScreenMessage('error', 'Error accessing recovery options');
            }
        }
        
        // Show message on lock screen
        function showLockScreenMessage(type, message) {
            const feedbackDiv = document.getElementById('lockScreenFeedback') || document.getElementById('pinFeedback');
            if (!feedbackDiv) return;
            
            feedbackDiv.textContent = message;
            feedbackDiv.style.display = 'block';
            feedbackDiv.className = `notification-message ${type}`;
            
            if (type === 'success') {
                setTimeout(() => { if (feedbackDiv) feedbackDiv.style.display = 'none'; }, CONSTANTS.MESSAGE_DURATION_MEDIUM);
            }
        }
        
        // Return to main lock screen
        function returnToLockScreen() {
            const lockTab = document.getElementById('lockTab');
            if (!lockTab) {
                // Fallback in case tab doesn't exist, though it should
                switchAppTab('lock');
                return;
            }

            // Check if there's an active timer to show instructional text
            const resetTime = getResetTime();
            let timerInstructions = '';

            if (resetTime) {
                const remainingTime = resetTime - Date.now();
                if (remainingTime > 0) {
                    const hours = Math.ceil(remainingTime / (1000 * 60 * 60));
                    const days = Math.ceil(hours / 24);

                    let timeDisplay = '';
                    if (days > 1) {
                        timeDisplay = `${days} days`;
                    } else if (hours > 1) {
                        timeDisplay = `${hours} hours`;
                    } else {
                        timeDisplay = 'Less than 1 hour';
                    }

                    timerInstructions = `
                        <div class="message-base message-info mb-md text-sm">
                            ⏰ Recovery timer active (${timeDisplay} remaining)<br>
                            <span class="text-sm font-normal">Press "Forgot PIN?" again when timer expires to unlock</span>
                        </div>
                    `;
                }
            }

            lockTab.innerHTML = `
                <div class="flex-center" style="min-height: 400px;">
                    <div class="card-elevated card-lg text-center max-w-sm w-full shadow-lg">
                        <div class="text-4xl mb-lg">🔒</div>
                        <h2 class="text-primary mb-md text-xl">Journal Locked</h2>
                        <p class="text-secondary mb-lg line-height-relaxed">
                            Your dream journal is protected with a PIN. Enter your PIN to access your dreams and all app features.
                        </p>
                        ${timerInstructions}
                        <input type="password" id="lockScreenPinInput" placeholder="Enter PIN" maxlength="6" class="input-pin w-full mb-lg">
                        <div class="flex-center gap-sm flex-wrap">
                            <button data-action="verify-lock-screen-pin" class="btn btn-primary">🔓 Unlock Journal</button>
                            <button data-action="show-lock-screen-forgot-pin" class="btn btn-secondary">Forgot PIN?</button>
                        </div>
                        <div id="lockScreenFeedback" class="mt-md p-sm feedback-container"></div>
                    </div>
                </div>
            `;

            // Ensure the tab is active and focus is set
            switchAppTab('lock');
        }
        
        // Start dream title recovery on lock screen
        async function startLockScreenTitleRecovery() {
            const lockCard = document.querySelector('#lockTab > div > div');
            renderPinScreen(lockCard, {
                title: 'Verify Dream Titles',
                icon: '📝',
                message: 'Enter exactly 3 of your dream titles as they appear in your journal.<br><em class="text-sm">Must match exactly, including capitalization</em>',
                inputs: [
                    { id: 'recovery1', type: 'text', placeholder: 'Dream title 1', class: 'form-control' },
                    { id: 'recovery2', type: 'text', placeholder: 'Dream title 2', class: 'form-control' },
                    { id: 'recovery3', type: 'text', placeholder: 'Dream title 3', class: 'form-control' }
                ],
                buttons: [
                    { text: 'Verify Titles', action: 'verify-lock-screen-dream-titles', class: 'btn-primary' },
                    { text: '← Back', action: 'show-lock-screen-forgot-pin', class: 'btn-secondary' }
                ],
                feedbackContainer: true
            });
        }
        
        // Verify dream titles on lock screen
        async function verifyLockScreenDreamTitles() {
            const title1 = document.getElementById('recovery1')?.value.trim();
            const title2 = document.getElementById('recovery2')?.value.trim();
            const title3 = document.getElementById('recovery3')?.value.trim();
            
            if (!title1 || !title2 || !title3) {
                showLockScreenMessage('error', 'Please enter all 3 dream titles');
                return;
            }
            
            const dreams = await loadDreams();
            const dreamTitles = dreams.filter(d => d.title !== 'Untitled Dream').map(d => d.title);
            
            const titles = [title1, title2, title3];
            const uniqueTitles = [...new Set(titles)];
            
            if (uniqueTitles.length !== 3) {
                showLockScreenMessage('error', 'Please enter 3 DIFFERENT dream titles. Each title must be unique.');
                return;
            }
            
            if (titles.every(t => dreamTitles.includes(t))) {
                removePinHash();
                removeResetTime();
                showLockScreenMessage('success', 'Recovery successful! Your PIN has been removed. Unlocking journal...');
                isUnlocked = true;
                isAppLocked = false;
                failedPinAttempts = 0;
                updateTimerWarning();
                
                setTimeout(() => {
                    showAllTabButtons();
                    const targetTab = (preLockActiveTab === 'lock') ? 'journal' : preLockActiveTab;
                    switchAppTab(targetTab);
                    updateSecurityControls();
                }, 2000);
            } else {
                showLockScreenMessage('error', 'One or more titles did not match. Please try again.');
                document.getElementById('recovery1').value = '';
                document.getElementById('recovery2').value = '';
                document.getElementById('recovery3').value = '';
                document.getElementById('recovery1').focus();
            }
        }
        
        // Start timer recovery on lock screen
        function startLockScreenTimerRecovery() {
            const lockCard = document.querySelector('#lockTab > div > div');
            renderPinScreen(lockCard, {
                title: '72-Hour Timer Reset',
                icon: '⏰',
                message: `
                    <div class="message-base message-warning mb-lg text-left">
                        <h4 class="mb-sm">⚠️ Important Warning</h4>
                        <p class="mb-sm line-height-relaxed">This will start a 72-hour countdown. After the timer expires, your PIN will be automatically removed.</p>
                        <p class="font-semibold" style="margin: 0;">Your dreams will remain safe and will not be deleted.</p>
                    </div>
                    <p class="text-secondary mb-lg line-height-relaxed">Do you want to start the 72-hour recovery timer?</p>`,
                buttons: [
                    { text: 'Start Timer', action: 'confirm-lock-screen-timer', class: 'btn-primary' },
                    { text: '← Cancel', action: 'show-lock-screen-forgot-pin', class: 'btn-secondary' }
                ],
                feedbackContainer: true
            });
        }
        
        // Confirm timer recovery on lock screen
        function confirmLockScreenTimer() {
            const resetTime = Date.now() + (CONSTANTS.PIN_RESET_HOURS * 60 * 60 * 1000);
            storeResetTime(resetTime);
            updateTimerWarning();
            showLockScreenMessage('success', '72-hour recovery timer started! You can check back later or use dream title recovery.');
            setTimeout(returnToLockScreen, 3000);
        }

        // Show PIN overlay
        function showPinOverlay() {
            if (isUnlocked && isPinSetup()) return;
            
            failedPinAttempts = 0;
            resetPinOverlay(); // Reset to default state
            document.getElementById('pinOverlay').style.display = 'flex';
            setTimeout(() => {
                const pinInput = document.getElementById('pinInput');
                if (pinInput) pinInput.focus();
            }, CONSTANTS.FOCUS_DELAY_MS);
        }

        // Hide PIN overlay
        function hidePinOverlay() {
            document.getElementById('pinOverlay').style.display = 'none';
            resetPinOverlay();
        }

        // Show PIN setup
        function showPinSetup() {
            const pinContainer = document.querySelector('#pinOverlay .pin-container');
            const isChangingPin = isPinSetup();

            renderPinScreen(pinContainer, {
                title: isChangingPin ? 'Change/Remove PIN' : 'Setup PIN',
                icon: '⚙️',
                message: isChangingPin ? 'Enter your current PIN to change it.' : 'Create a 4-6 digit PIN to protect your dreams.',
                inputs: [
                    { id: 'pinInput', type: 'password', placeholder: isChangingPin ? 'Current PIN' : 'New PIN (4-6 digits)', class: 'pin-input', maxLength: 6 }
                ],
                buttons: [
                    { text: isChangingPin ? 'Verify Current PIN' : 'Continue', action: 'process-pin-setup', class: 'btn-primary' },
                    { text: 'Cancel', action: 'hide-pin-overlay', class: 'btn-secondary' }
                ],
                feedbackContainer: true
            });
            document.getElementById('pinOverlay').style.display = 'flex';
        }

        // Setup new PIN (multi-step process) - UPDATED for secure hashing
        // MOVE TO: SECTION 5.6 - PIN setup functionality
        async function setupPin() {
            const enteredPin = document.getElementById('pinInput').value;
            const pinContainer = document.querySelector('#pinOverlay .pin-container');
            
            if (!enteredPin || enteredPin.length < CONSTANTS.PIN_MIN_LENGTH || enteredPin.length > CONSTANTS.PIN_MAX_LENGTH || !/^\d+$/.test(enteredPin)) {
                showMessage('error', `PIN must be ${CONSTANTS.PIN_MIN_LENGTH}-${CONSTANTS.PIN_MAX_LENGTH} digits.`);
                document.getElementById('pinInput').value = '';
                return;
            }
            
            if (isPinSetup()) {
                const storedData = getStoredPinData();
                const isValid = await verifyPinHash(enteredPin, storedData);
                if (!isValid) {
                    showMessage('error', 'Current PIN is incorrect. Please try again.');
                    document.getElementById('pinInput').value = '';
                    return;
                }
                renderPinScreen(pinContainer, {
                    title: 'Change or Remove PIN',
                    icon: '⚙️',
                    message: 'Your current PIN is correct. What would you like to do?',
                    buttons: [
                        { text: 'Set New PIN', action: 'show-set-new-pin-screen', class: 'btn-primary' },
                        { text: 'Remove PIN', action: 'execute-pin-removal', class: 'btn-delete' },
                        { text: 'Cancel', action: 'hide-pin-overlay', class: 'btn-secondary' }
                    ],
                    feedbackContainer: false
                });
            } else {
                window.tempNewPin = enteredPin;
                renderPinScreen(pinContainer, {
                    title: 'Confirm PIN',
                    icon: '⚙️',
                    message: 'Enter the same PIN again to confirm.',
                    inputs: [ { id: 'pinInput', type: 'password', placeholder: 'Confirm PIN', class: 'pin-input', maxLength: 6 } ],
                    buttons: [
                        { text: 'Setup PIN', action: 'confirm-new-pin', class: 'btn-primary' },
                        { text: 'Cancel', action: 'hide-pin-overlay', class: 'btn-secondary' }
                    ],
                    feedbackContainer: true
                });
            }
        }

        // Step 2 of change PIN: Enter new PIN
        function showSetNewPinScreen() {
            const pinContainer = document.querySelector('#pinOverlay .pin-container');
            renderPinScreen(pinContainer, {
                title: 'Enter New PIN',
                icon: '⚙️',
                message: 'Enter your new 4-6 digit PIN.',
                inputs: [ { id: 'pinInput', type: 'password', placeholder: 'New PIN (4-6 digits)', class: 'pin-input', maxLength: 6 } ],
                buttons: [
                    { text: 'Continue', action: 'setup-new-pin', class: 'btn-primary' },
                    { text: 'Cancel', action: 'hide-pin-overlay', class: 'btn-secondary' }
                ],
                feedbackContainer: true
            });
        }

        function setupNewPin() {
            const enteredPin = document.getElementById('pinInput').value;
            if (!enteredPin || enteredPin.length < CONSTANTS.PIN_MIN_LENGTH || enteredPin.length > CONSTANTS.PIN_MAX_LENGTH || !/^\d+$/.test(enteredPin)) {
                showMessage('error', `PIN must be ${CONSTANTS.PIN_MIN_LENGTH}-${CONSTANTS.PIN_MAX_LENGTH} digits.`);
                document.getElementById('pinInput').value = '';
                return;
            }
            
            window.tempNewPin = enteredPin;
            const pinContainer = document.querySelector('#pinOverlay .pin-container');
            renderPinScreen(pinContainer, {
                title: 'Confirm New PIN',
                icon: '⚙️',
                message: 'Enter the same PIN again to confirm.',
                inputs: [ { id: 'pinInput', type: 'password', placeholder: 'Confirm new PIN', class: 'pin-input', maxLength: 6 } ],
                buttons: [
                    { text: 'Change PIN', action: 'confirm-new-pin', class: 'btn-primary' },
                    { text: 'Cancel', action: 'hide-pin-overlay', class: 'btn-secondary' }
                ],
                feedbackContainer: true
            });
        }

        // Final step: Confirm the new PIN - UPDATED for secure hashing
        async function confirmNewPin() {
            const enteredPin = document.getElementById('pinInput').value;
            if (enteredPin !== window.tempNewPin) {
                showMessage('error', 'PINs do not match. Please start over.');
                setTimeout(() => {
                    resetPinOverlay();
                    showPinSetup();
                }, 2000);
                return;
            }
            
            try {
                const success = await storePinHash(window.tempNewPin);
                if (success) {
                    const pinContainer = document.querySelector('#pinOverlay .pin-container');
                    renderPinScreen(pinContainer, {
                        title: 'PIN Setup Complete',
                        icon: '✅',
                        message: `Secure PIN has been set successfully! Your dreams are now protected${isLocalStorageAvailable() ? ' with advanced encryption' : ' using memory storage (PIN will reset on refresh)'}.`,
                        buttons: [
                            { text: 'Close', action: 'complete-pin-setup', class: 'btn-primary' }
                        ]
                    });
                    delete window.tempNewPin;
                    isUnlocked = true;
                } else {
                    showMessage('error', 'Error: Failed to save secure PIN. Please try again.');
                }
            } catch (error) {
                console.error('Error setting up secure PIN:', error);
                showMessage('error', 'Error: Failed to setup secure PIN. Please try again.');
            }
        }

        // Complete PIN setup and close overlay
        async function completePinSetup() {
            resetPinOverlay();
            hidePinOverlay();
            failedPinAttempts = 0;
            isUnlocked = true;
            isAppLocked = false;
            console.log('PIN setup complete - ensuring tabs are visible');
            showAllTabButtons();
            updateSecurityControls();
            await displayDreams();
        }

        // Reset PIN overlay to default state
        function resetPinOverlay() {
            const pinContainer = document.querySelector('#pinOverlay .pin-container');
            if (!pinContainer) return;
            
            failedPinAttempts = 0;
            
            renderPinScreen(pinContainer, {
                title: 'Enter PIN',
                icon: '🔒',
                message: 'Your dreams are protected. Enter your PIN to access them.',
                inputs: [ { id: 'pinInput', type: 'password', placeholder: 'Enter PIN', class: 'pin-input', maxLength: 6 } ],
                buttons: [
                    { text: 'Unlock', action: 'verify-pin', class: 'btn-primary', id: 'pinMainBtn' },
                    { text: 'Cancel', action: 'hide-pin-overlay', class: 'btn-secondary', id: 'cancelPinBtn' }
                ],
                links: [
                    { text: 'Setup new PIN', action: 'show-pin-setup', id: 'pinSetupLink', style: isPinSetup() ? 'display:none' : '' },
                    { text: 'Remove PIN protection', action: 'show-remove-pin', id: 'removePinLink', style: !isPinSetup() || !isUnlocked ? 'display:none' : '' },
                    { text: 'Forgot PIN?', action: 'show-forgot-pin', id: 'forgotPinLink', style: 'display:none' }
                ],
                feedbackContainer: true
            });
        }

        // Toggle lock state
        async function toggleLock() {
            if (!isPinSetup()) {
                const container = document.querySelector('.main-content');
                if (container) {
                    createInlineMessage('info', 'First, set up a PIN to protect your dreams, then you can lock your journal.', {
                        container: container,
                        position: 'top',
                        duration: 4000
                    });
                }
                showPinSetup();
                return;
            }
            
            if (isUnlocked && !isAppLocked) {
                isUnlocked = false;
                isAppLocked = true;
                preLockActiveTab = activeAppTab;
                console.log('Locking app - hiding other tabs');
                hideAllTabButtons();
                switchAppTab('lock');
                updateSecurityControls();
            } else {
                showPinOverlay();
            }
        }

        // DREAM CRUD OPERATIONS (CREATE, READ, UPDATE, DELETE)

        async function learnAutocompleteItems(inputArray, type) {
            if (!inputArray || inputArray.length === 0) return;

            const storeId = type; // 'tags' or 'dreamSigns'
            let autocompleteData = await loadItemFromStore('autocomplete', storeId);

            // If the store doesn't exist yet, initialize it.
            if (!autocompleteData) {
                autocompleteData = { id: storeId, items: [] };
            }

            const currentItemsLower = new Set(autocompleteData.items.map(item => item.toLowerCase()));
            let newItemsFound = false;

            inputArray.forEach(newItemValue => {
                if (!currentItemsLower.has(newItemValue.toLowerCase())) {
                    autocompleteData.items.push(newItemValue);
                    currentItemsLower.add(newItemValue.toLowerCase()); // Add to set to handle duplicates within the same input
                    newItemsFound = true;
                }
            });

            if (newItemsFound) {
                await saveItemToStore('autocomplete', autocompleteData);
                // Also update the autocomplete suggestions in the UI
                await initializeAutocomplete();
            }
        }
        
        // saveDream function moved to SECTION 5.1

        // displayDreams, displayDreamsInternal, getFilterValues, showLoadingMessage, showNoResultsMessage, clearPagination functions moved to SECTION 5.1

        // Render pagination controls (Updated for Event Delegation)
        function renderPagination(page, totalPages, totalItems, currentItems) {
            const limitSelect = document.getElementById('limitSelect');
            const limitValue = limitSelect ? limitSelect.value : '10';
            const itemsPerPage = Math.max(1, parseInt(limitValue) || 10);
            
            const startItem = (page - 1) * itemsPerPage + 1;
            const endItem = startItem + currentItems - 1;
            
            let paginationHTML = `
                <div class="pagination">
                    <button class="pagination-btn" data-action="go-to-page" data-page="${page - 1}" ${page <= 1 ? 'disabled' : ''}>
                        ← Previous
                    </button>
                    
                    <div class="page-numbers">
            `;
            
            // Generate page numbers with ellipsis
            const pageNumbers = generatePageNumbers(page, totalPages);
            pageNumbers.forEach(item => {
                if (item === '...') {
                    paginationHTML += `<span class="page-ellipsis">...</span>`;
                } else {
                    const isActive = item === page ? 'active' : '';
                    paginationHTML += `<button class="page-btn ${isActive}" data-action="go-to-page" data-page="${item}">${item}</button>`;
                }
            });
            
            paginationHTML += `
                    </div>
                    
                    <button class="pagination-btn" data-action="go-to-page" data-page="${page + 1}" ${page >= totalPages ? 'disabled' : ''}>
                        Next →
                    </button>
                </div>
                
                <div class="pagination-info" style="text-align: center; margin-top: 10px;">
                    Showing ${startItem}-${endItem} of ${totalItems} dreams
                </div>
            `;
            
            return paginationHTML;
        }

        // Generate smart page numbers with ellipsis
        function generatePageNumbers(currentPage, totalPages) {
            const pages = [];
            
            // Validate inputs
            if (!currentPage || !totalPages || currentPage < 1 || totalPages < 1) {
                return [1];
            }
            
            if (totalPages <= CONSTANTS.PAGINATION_MAX_VISIBLE_PAGES) {
                // Show all pages if 7 or fewer
                for (let i = 1; i <= totalPages; i++) {
                    pages.push(i);
                }
            } else {
                // Always show first page
                pages.push(1);
                
                if (currentPage > CONSTANTS.PAGINATION_CURRENT_PAGE_PROXIMITY) {
                    pages.push('...');
                }
                
                // Show pages around current page
                const start = Math.max(2, currentPage - 1);
                const end = Math.min(totalPages - 1, currentPage + 1);
                
                for (let i = start; i <= end; i++) {
                    if (!pages.includes(i)) {
                        pages.push(i);
                    }
                }
                
                if (currentPage < totalPages - CONSTANTS.PAGINATION_ELLIPSIS_THRESHOLD) {
                    pages.push('...');
                }
                
                // Always show last page
                if (!pages.includes(totalPages)) {
                    pages.push(totalPages);
                }
            }
            
            return pages;
        }

        // Navigate to specific page
        async function goToPage(page) {
            const limitSelect = document.getElementById('limitSelect');
            const limitValue = limitSelect ? limitSelect.value : '10';
            
            if (limitValue === 'all' || limitValue === 'endless') return; // No pagination when showing all or endless
            
            try {
                const totalDreamsCount = await getFilteredDreamsCount();
                const itemsPerPage = Math.max(1, parseInt(limitValue) || 10);
                const totalPages = Math.max(1, Math.ceil(totalDreamsCount / itemsPerPage));
                
                // Validate page number
                const pageNum = parseInt(page);
                if (isNaN(pageNum) || pageNum < 1 || pageNum > totalPages) return;
                
                currentPage = pageNum;
                await displayDreams();
            } catch (error) {
                console.error('Error navigating to page:', error);
                // Don't update page on error to prevent broken state
            }
        }

        // Get count of filtered dreams
        async function getFilteredDreamsCount() {
            try {
                const { searchTerm, filterType, startDate, endDate } = getFilterValues();
                const dreams = await loadDreams();
                if (!Array.isArray(dreams)) return 0;

                const filtered = filterDreams(dreams, searchTerm, filterType, startDate, endDate);
                return filtered.length;
            } catch (error) {
                console.error('Error counting filtered dreams:', error);
                return 0;
            }
        }

        // Reset to page 1 when filters change
        async function resetToPageOne() {
            currentPage = 1;
            
            // Reset endless scroll when filters change
            if (endlessScrollState.enabled) {
                endlessScrollState.loaded = 5;
                endlessScrollState.loading = false;
            }
            
            await displayDreams();
        }

        // editDream function moved to SECTION 5.1

        // saveDreamEdit and cancelDreamEdit functions moved to SECTION 5.1

        // deleteDream, confirmDelete, and cancelDelete functions moved to SECTION 5.1

        // IMPORT & EXPORT FUNCTIONALITY
        
        // Function moved to SECTION 5.5 - exportEntries()

        // Update localStorage backup after successful IndexedDB operations
        async function updateLocalStorageBackup() {
            if (!isLocalStorageAvailable()) return;
            
            try {
                // Load current state from IndexedDB and sync to localStorage
                const dreams = await loadFromIndexedDB();
                if (dreams !== null) {
                    localStorage.setItem('dreamJournalEntries', JSON.stringify(dreams));
                }
            } catch (error) {
                // Ignore backup errors - IndexedDB is the primary storage
            }
        }

        // Validate dream data before saving
        function validateDreamData(dream) {
            if (!dream || typeof dream !== 'object') {
                console.error('Invalid dream data: not an object');
                return false;
            }
            
            if (!dream.id || typeof dream.id !== 'string') {
                console.error('Invalid dream data: missing or invalid id');
                return false;
            }
            
            if (!dream.content || typeof dream.content !== 'string' || dream.content.trim() === '') {
                console.error('Invalid dream data: missing or empty content');
                return false;
            }
            
            if (!dream.timestamp || typeof dream.timestamp !== 'string') {
                console.error('Invalid dream data: missing or invalid timestamp');
                return false;
            }
            
            // Validate timestamp is a valid date
            const date = new Date(dream.timestamp);
            if (isNaN(date.getTime())) {
                console.error('Invalid dream data: timestamp is not a valid date');
                return false;
            }
            
            if (!dream.title || typeof dream.title !== 'string') {
                console.error('Invalid dream data: missing or invalid title');
                return false;
            }
            
            if (typeof dream.isLucid !== 'boolean') {
                console.error('Invalid dream data: isLucid must be boolean');
                return false;
            }
            
            if (!dream.dateString || typeof dream.dateString !== 'string') {
                console.error('Invalid dream data: missing or invalid dateString');
                return false;
            }
            
            return true;
        }

        // Check if a dream is a duplicate based on title and content
        function isDreamDuplicate(existingDreams, newDream) {
            if (!Array.isArray(existingDreams) || !newDream || typeof newDream !== 'object') {
                return false;
            }
            
            return existingDreams.some(existing => 
                existing && 
                existing.title === newDream.title && 
                existing.content === newDream.content &&
                existing.timestamp === newDream.timestamp
            );
        }

        // TAG & DREAM SIGN MANAGEMENT FUNCTIONS

        // Generic function to load a single item from a given store by ID
        async function loadItemFromStore(storeName, id) {
            if (!isIndexedDBAvailable()) return null;

            return new Promise((resolve) => {
                try {
                    if (!db.objectStoreNames.contains(storeName)) {
                        console.warn(`Store '${storeName}' not found in database.`);
                        resolve(null);
                        return;
                    }

                    const transaction = db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(id);

                    request.onsuccess = () => {
                        resolve(request.result || null);
                    };

                    request.onerror = () => {
                        console.error(`Error loading item with id '${id}' from store '${storeName}':`, request.error);
                        resolve(null);
                    };
                } catch (error) {
                    console.error(`Error creating transaction for store '${storeName}':`, error);
                    resolve(null);
                }
            });
        }

        // Generic function to load all items from a given store
        async function loadFromStore(storeName) {
            if (!isIndexedDBAvailable()) return [];
            
            return new Promise((resolve) => {
                try {
                    if (!db.objectStoreNames.contains(storeName)) {
                        console.warn(`Store '${storeName}' not found in database.`);
                        resolve([]);
                        return;
                    }
                    
                    const transaction = db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        resolve(request.result || []);
                    };
                    
                    request.onerror = () => {
                        console.error(`Error loading from store '${storeName}':`, request.error);
                        resolve([]);
                    };
                } catch (error) {
                    console.error(`Error creating transaction for store '${storeName}':`, error);
                    resolve([]);
                }
            });
        }

        // Generic function to save/update a single item in a store
        async function saveItemToStore(storeName, item) {
            if (!isIndexedDBAvailable()) return false;

            return new Promise((resolve) => {
                try {
                    if (!db.objectStoreNames.contains(storeName)) {
                        console.error(`Store '${storeName}' not found for saving.`);
                        resolve(false);
                        return;
                    }

                    const transaction = db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(item);

                    request.onsuccess = () => {
                        resolve(true);
                    };

                    request.onerror = (event) => {
                        console.error(`Error saving item to store '${storeName}':`, event.target.error);
                        resolve(false);
                    };

                    transaction.onabort = (event) => {
                        console.error(`Transaction aborted for store '${storeName}':`, event.target.error);
                        resolve(false);
                    };
                } catch (error) {
                    console.error(`Error creating save transaction for store '${storeName}':`, error);
                    resolve(false);
                }
            });
        }

        // Generic function to overwrite a store with new data
        async function saveToStore(storeName, data) {
            if (!isIndexedDBAvailable()) return false;
            
            return new Promise((resolve) => {
                try {
                    if (!db.objectStoreNames.contains(storeName)) {
                        console.error(`Store '${storeName}' not found for saving.`);
                        resolve(false);
                        return;
                    }
                    
                    const transaction = db.transaction([storeName], 'readwrite');
                    
                    // --- ADD THIS HANDLER ---
                    transaction.onabort = (event) => {
                        console.error(`Transaction aborted for store '${storeName}':`, event.target.error);
                        resolve(false);
                    };
                    // ------------------------
                    
                    const store = transaction.objectStore(storeName);
                    
                    const clearRequest = store.clear();
                    
                    clearRequest.onsuccess = () => {
                        data.forEach(item => {
                            store.put(item);
                        });
                    };
                    
                    clearRequest.onerror = (event) => {
                        console.error(`Error clearing store '${storeName}':`, event.target.error);
                        transaction.abort();
                    };
                    
                    transaction.oncomplete = () => {
                        resolve(true);
                    };
                    
                    transaction.onerror = (event) => {
                        console.error(`Error saving to store '${storeName}':`, event.target.error);
                        resolve(false);
                    };
                } catch (error) {
                    console.error(`Error creating save transaction for store '${storeName}':`, error);
                    resolve(false);
                }
            });
        }

        // Load user-defined tags from IndexedDB
        async function loadUserTags() {
            const tags = await loadFromStore('userTags');
            return tags.map(t => t.value);
        }

        // Load user-defined dream signs from IndexedDB
        async function loadUserDreamSigns() {
            const signs = await loadFromStore('userDreamSigns');
            return signs.map(s => s.value);
        }

        // Load deleted default tags/signs from IndexedDB
        async function loadDeletedDefaults() {
            const deleted = await loadFromStore('deletedDefaults');
            return deleted.map(d => d.id);
        }

        // Save a list of user tags
        async function saveUserTags(tags) {
            const dataToStore = tags.map(tag => ({ id: tag.toLowerCase(), value: tag }));
            return await saveToStore('userTags', dataToStore);
        }

        // Save a list of user dream signs
        async function saveUserDreamSigns(signs) {
            const dataToStore = signs.map(sign => ({ id: sign.toLowerCase(), value: sign }));
            return await saveToStore('userDreamSigns', dataToStore);
        }

        // Save a list of deleted default items
        async function saveDeletedDefaults(deletedItems) {
            const dataToStore = deletedItems.map(item => ({ id: item.toLowerCase() }));
            return await saveToStore('deletedDefaults', dataToStore);
        }
        
        // Get combined list of suggestions for autocomplete
        async function getAutocompleteSuggestions(type) {
            const storeId = type === 'tags' ? 'tags' : 'dreamSigns';

            // For new users or migrated users, use the new unified 'autocomplete' store
            if (isIndexedDBAvailable() && db.objectStoreNames.contains('autocomplete')) {
                const autocompleteData = await loadItemFromStore('autocomplete', storeId);
                if (autocompleteData && autocompleteData.items) {
                    // Sort alphabetically for consistent display
                    return autocompleteData.items.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
                }
            }

            // Fallback logic for users who have not yet run the v5 migration
            console.warn(`Falling back to legacy autocomplete logic for ${type}. This is expected if you haven't updated yet.`);
            const isTags = type === 'tags';
            const defaultList = isTags ? commonTags : commonDreamSigns;
            
            const [userItems, deletedItems] = await Promise.all([
                loadFromStore(isTags ? 'userTags' : 'userDreamSigns'),
                loadFromStore('deletedDefaults')
            ]);

            const userList = userItems.map(item => item.value);
            const deletedList = new Set(deletedItems.map(item => item.id));

            const combined = new Map();

            defaultList.forEach(item => {
                if (!deletedList.has(item.toLowerCase())) {
                    combined.set(item.toLowerCase(), item);
                }
            });

            userList.forEach(item => {
                combined.set(item.toLowerCase(), item);
            });

            return Array.from(combined.values()).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
        }

        async function renderAutocompleteManagementList(type) {
            const containerId = type === 'tags' ? 'tagsManagementList' : 'dreamSignsManagementList';
            const container = document.getElementById(containerId);
            if (!container) return;

            container.innerHTML = '<div class="loading-state">Loading...</div>';

            try {
                // Get the unified list of suggestions. This now correctly reads from the new store.
                const suggestions = await getAutocompleteSuggestions(type);

                if (suggestions.length === 0) {
                    container.innerHTML = `<div class="no-entries" style="padding: 15px;">No custom items added yet.</div>`;
                    return;
                }

                // All items are now treated the same. No more 'default' vs 'user' distinction.
                const listHtml = suggestions.map(item => {
                    return `
                        <div class="autocomplete-list-item">
                            <span class="item-value">${escapeHtml(item)}</span>
                            <div class="flex-center gap-sm">
                                <button data-action="delete-autocomplete-item" data-item-type="${type}" data-item-id="${escapeAttr(item)}" class="btn btn-delete btn-small">Delete</button>
                            </div>
                        </div>
                    `;
                }).join('');

                container.innerHTML = listHtml;
            } catch (error) {
                console.error(`Error rendering ${type} list:`, error);
                container.innerHTML = `<div class="message-error">Failed to load ${type} list.</div>`;
            }
        }

        async function addCustomAutocompleteItem(type) {
            const storeId = type === 'tags' ? 'tags' : 'dreamSigns';
            const inputId = type === 'tags' ? 'newTagInput' : 'newDreamSignInput';
            const input = document.getElementById(inputId);
            if (!input) return;

            const value = input.value.trim();
            if (!value) return;

            // Load the entire autocomplete object for this type
            let autocompleteData = await loadItemFromStore('autocomplete', storeId);

            // It's possible the store is empty on first use. Let's create it.
            if (!autocompleteData) {
                autocompleteData = { id: storeId, items: [] };
            }

            const currentItems = autocompleteData.items || [];
            const currentItemsLower = new Set(currentItems.map(item => item.toLowerCase()));

            // Prevent adding duplicates
            if (currentItemsLower.has(value.toLowerCase())) {
                input.value = '';
                return;
            }

            // Add the new item
            currentItems.push(value);
            autocompleteData.items = currentItems;

            // Save the updated object back to the store
            await saveItemToStore('autocomplete', autocompleteData);

            input.value = '';
            await renderAutocompleteManagementList(type);
            await initializeAutocomplete();
        }

        async function deleteAutocompleteItem(type, itemValue) {
            const storeId = type === 'tags' ? 'tags' : 'dreamSigns';
            
            const autocompleteData = await loadItemFromStore('autocomplete', storeId);
            if (!autocompleteData || !autocompleteData.items) {
                console.error(`Could not load autocomplete data for ${type}`);
                return;
            }

            const itemToDelete = itemValue.toLowerCase();
            const updatedItems = autocompleteData.items.filter(item => item.toLowerCase() !== itemToDelete);

            // If nothing was deleted, no need to save
            if (updatedItems.length === autocompleteData.items.length) {
                console.warn(`Item "${itemValue}" not found in ${type} list for deletion.`);
                return;
            }

            autocompleteData.items = updatedItems;

            await saveItemToStore('autocomplete', autocompleteData);

            await renderAutocompleteManagementList(type);
            await initializeAutocomplete();
        }

        // Function moved to SECTION 5.5 - importEntries()

        // === COMPREHENSIVE DATA MANAGEMENT FUNCTIONS ===
        
        // Function moved to SECTION 5.5 - exportAllData()
        
        // Function moved to SECTION 5.5 - importAllData()

        async function importAllData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                // Check if encryption is enabled
                const encryptionEnabled = document.getElementById('fullDataEncryption').checked;
                const isEncryptedFile = file.name.endsWith('.enc');
                
                // Read file
                const fileData = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    
                    if (encryptionEnabled || isEncryptedFile) {
                        reader.readAsArrayBuffer(file);
                    } else {
                        reader.readAsText(file);
                    }
                });
                
                let jsonText = '';
                
                // Handle encrypted files
                if (encryptionEnabled || isEncryptedFile) {
                    if (typeof fileData === 'string') {
                        throw new Error('Selected file appears to be unencrypted. Uncheck encryption or select an encrypted (.enc) file.');
                    }
                    
                    const password = await showPasswordDialog({
                        type: 'import',
                        title: '🔓 Enter Complete Import Password',
                        description: 'Enter the password used to encrypt this complete data export file.',
                        requireConfirm: false,
                        primaryButtonText: 'Decrypt & Import'
                    });
                    
                    if (!password) {
                        event.target.value = '';
                        return;
                    }
                    
                    try {
                        jsonText = await decryptData(new Uint8Array(fileData), password);
                    } catch (decryptError) {
                        throw new Error('Failed to decrypt file. Please check your password and try again.');
                    }
                } else {
                    if (typeof fileData !== 'string') {
                        throw new Error('Selected file appears to be encrypted. Check encryption option or select a JSON (.json) file.');
                    }
                    jsonText = fileData;
                }
                
                // Parse JSON data
                let importData;
                try {
                    importData = JSON.parse(jsonText);
                } catch (parseError) {
                    throw new Error('Invalid JSON file format. Please select a valid Dream Journal export file.');
                }
                
                // Validate export format
                if (!importData.data || !importData.exportType) {
                    throw new Error('Invalid export file format. This does not appear to be a complete Dream Journal export.');
                }
                
                // Show import options dialog
                const importMode = await showImportOptionsDialog(importData);
                if (!importMode) {
                    event.target.value = '';
                    return; // User cancelled
                }
                
                // Process import based on selected mode
                await processCompleteImport(importData, importMode);
                
                // Show success message
                const stats = importData.data.metadata || {};
                const successMessage = `Complete import ${importMode === 'merge' ? 'merged' : 'completed'}! ` +
                    `(${stats.totalDreams || 0} dreams, ${stats.totalGoals || 0} goals)`;
                    
                createInlineMessage('success', successMessage, {
                    container: document.querySelector('.main-content'),
                    position: 'top',
                    duration: 4000
                });
                
            } catch (error) {
                console.error('Complete import error:', error);
                createInlineMessage('error', 'Complete import failed: ' + error.message, {
                    container: document.querySelector('.main-content'),
                    position: 'top',
                    duration: 5000
                });
            } finally {
                event.target.value = '';
            }
        }
        
        // Show import options dialog (merge vs overwrite)
        async function showImportOptionsDialog(importData) {
            return new Promise((resolve) => {
                // Create import options overlay
                const overlay = document.createElement('div');
                overlay.className = 'password-overlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.7);
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                
                const stats = importData.data.metadata || {};
                const currentDreamsData = JSON.parse(localStorage.getItem('dreamJournalEntries') || '[]');
                const currentDreams = currentDreamsData.length;
                const currentLucidDreams = currentDreamsData.filter(d => d.isLucid).length;
                const currentGoals = JSON.parse(localStorage.getItem('dreamJournalGoals') || '[]').length;
                
                overlay.innerHTML = `
                    <div class="password-dialog" style="max-width: 600px; width: 90%; background: var(--bg-elevated); border: 2px solid var(--border-color); border-radius: var(--border-radius-lg); padding: 30px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);">
                        <h3 style="margin-bottom: 20px; color: var(--text-primary); font-size: 20px; font-weight: 600;">📥 Import Options</h3>
                        
                        <div style="background: var(--bg-subtle); border: 1px solid var(--border-light); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                            <h4 style="margin-bottom: 10px; color: var(--text-primary); font-size: 16px; font-weight: 600;">Import Data Preview:</h4>
                            <div style="color: var(--text-secondary); font-size: 14px; line-height: 1.5;">
                                • Dreams: ${stats.totalDreams || 0} (${stats.lucidDreams || 0} lucid)<br>
                                • Goals: ${stats.totalGoals || 0}<br>
                                • Voice Notes: ${stats.totalVoiceNotes || 0} (metadata only)<br>
                                • Export Date: ${importData.exportDate ? new Date(importData.exportDate).toLocaleDateString() : 'Unknown'}
                            </div>
                        </div>
                        
                        <div style="background: var(--bg-light); border: 1px solid var(--border-light); border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                            <h4 style="margin-bottom: 10px; color: var(--text-primary); font-size: 16px; font-weight: 600;">Current Data:</h4>
                            <div style="color: var(--text-secondary); font-size: 14px; line-height: 1.5;">
                                • Dreams: ${currentDreams} (${currentLucidDreams} lucid)<br>
                                • Goals: ${currentGoals}
                            </div>
                        </div>
                        
                        <p style="margin-bottom: 20px; color: var(--text-primary); line-height: 1.5; font-weight: 500;">
                            Choose how to handle this import:
                        </p>
                        
                        <div class="import-options" style="margin-bottom: 25px;">
                            <div style="background: var(--bg-secondary); border: 2px solid var(--primary-color); border-radius: 8px; padding: 15px; margin-bottom: 10px; cursor: pointer; transition: border-color 0.2s;" onclick="this.querySelector('input').checked = true; document.querySelectorAll('.import-option-card').forEach(c => c.style.borderColor = 'var(--border-color)'); this.style.borderColor = 'var(--primary-color)';" class="import-option-card">
                                <label style="cursor: pointer; display: flex; align-items: flex-start; gap: 12px;">
                                    <input type="radio" name="importMode" value="merge" checked style="margin-top: 3px; accent-color: var(--primary-color);">
                                    <div>
                                        <strong style="color: var(--primary-color); font-size: 15px;">🔀 Smart Merge (Recommended)</strong>
                                        <div style="color: var(--text-secondary); font-size: 13px; margin-top: 6px; line-height: 1.4;">
                                            Add new items and update existing ones. Keeps all your current data safe.
                                        </div>
                                    </div>
                                </label>
                            </div>
                            
                            <div style="background: var(--bg-secondary); border: 2px solid var(--border-color); border-radius: 8px; padding: 15px; cursor: pointer; transition: border-color 0.2s;" onclick="this.querySelector('input').checked = true; document.querySelectorAll('.import-option-card').forEach(c => c.style.borderColor = 'var(--border-color)'); this.style.borderColor = 'var(--error-color)';" class="import-option-card">
                                <label style="cursor: pointer; display: flex; align-items: flex-start; gap: 12px;">
                                    <input type="radio" name="importMode" value="overwrite" style="margin-top: 3px; accent-color: var(--error-color);">
                                    <div>
                                        <strong style="color: var(--error-color); font-size: 15px;">⚠️ Complete Overwrite</strong>
                                        <div style="color: var(--text-secondary); font-size: 13px; margin-top: 6px; line-height: 1.4;">
                                            Replace ALL current data with imported data. Cannot be undone!
                                        </div>
                                    </div>
                                </label>
                            </div>
                        </div>
                        
                        <div class="password-buttons" style="display: flex; gap: 12px; justify-content: flex-end;">
                            <button onclick="window.completeImportResolve(document.querySelector('input[name=importMode]:checked').value)" 
                                    class="btn btn-primary" style="font-weight: 600;">Continue Import</button>
                            <button onclick="window.completeImportResolve(null)" 
                                    class="btn btn-secondary">Cancel</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(overlay);
                
                // Set up global resolver function
                window.completeImportResolve = (mode) => {
                    document.body.removeChild(overlay);
                    delete window.completeImportResolve;
                    resolve(mode);
                };
                
                // Handle radio button visual feedback
                overlay.querySelectorAll('.import-option-card').forEach(card => {
                    card.addEventListener('click', () => {
                        // Reset all borders
                        overlay.querySelectorAll('.import-option-card').forEach(c => {
                            c.style.borderColor = 'var(--border-color)';
                        });
                        // Highlight selected
                        const input = card.querySelector('input');
                        if (input) {
                            input.checked = true;
                            if (input.value === 'overwrite') {
                                card.style.borderColor = 'var(--error-color)';
                            } else {
                                card.style.borderColor = 'var(--primary-color)';
                            }
                        }
                    });
                });
                
                // Set initial selection highlight - merge is already highlighted by default in HTML
            });
        }
        
        // Process complete data import based on selected mode
        async function processCompleteImport(importData, mode) {
            const { dreams: importDreams = [], goals: importGoals = [], settings: importSettings = {} } = importData.data;
            
            if (mode === 'overwrite') {
                // Complete replacement - clear everything first
                await saveDreams(importDreams);
                await saveGoals(importGoals);
                
                // Apply settings (theme only for now)
                if (importSettings.theme) {
                    switchTheme(importSettings.theme);
                }
                
            } else if (mode === 'merge') {
                // Smart merge - combine with existing data
                
                // Merge dreams (avoid duplicates by ID and content)
                const currentDreams = await loadDreams();
                const existingIds = new Set(currentDreams.map(d => d.id));
                const existingContentHashes = new Set(currentDreams.map(d => `${d.title}_${d.content}_${d.timestamp}`));
                
                const newDreams = importDreams.filter(dream => {
                    const contentHash = `${dream.title}_${dream.content}_${dream.timestamp}`;
                    return !existingIds.has(dream.id) && !existingContentHashes.has(contentHash);
                });
                
                // Add new dreams
                if (newDreams.length > 0) {
                    const mergedDreams = [...currentDreams, ...newDreams];
                    await saveDreams(mergedDreams);
                }
                
                // Merge goals (avoid duplicates by title and description)
                const currentGoals = await loadGoals();
                const existingGoalKeys = new Set(currentGoals.map(g => `${g.title}_${g.description}`));
                
                const newGoals = importGoals.filter(goal => {
                    const goalKey = `${goal.title}_${goal.description}`;
                    return !existingGoalKeys.has(goalKey);
                });
                
                // Add new goals
                if (newGoals.length > 0) {
                    const mergedGoals = [...currentGoals, ...newGoals];
                    await saveGoals(mergedGoals);
                }
            }
            
            // Refresh all displays
            await Promise.all([
                displayDreams(),
                displayGoals()
            ]);
        }

        // Function moved to SECTION 5.5 - exportForAIAnalysis()

        async function exportForAIAnalysis() {
            // Check if app is locked
            if (isAppLocked || (isPinSetup() && !isUnlocked)) {
                switchAppTab('lock');
                setTimeout(() => {
                    showLockScreenMessage('error', 'Please unlock your journal first to export for analysis.');
                }, 500);
                return;
            }
            
            const { searchTerm, filterType, sortType, startDate, endDate } = getFilterValues();
            const allDreams = await loadDreams();
            
            // Apply same filtering as display
            let dreams = filterDreams(allDreams, searchTerm, filterType, startDate, endDate);
            
            // Apply same sorting as display for consistency
            dreams.sort((a, b) => {
                switch (sortType) {
                    case 'oldest':
                        return new Date(a.timestamp) - new Date(b.timestamp);
                    
                    case 'lucid-first':
                        if (a.isLucid && !b.isLucid) return -1;
                        if (!a.isLucid && b.isLucid) return 1;
                        return new Date(b.timestamp) - new Date(a.timestamp);
                    
                    case 'longest':
                        return b.content.length - a.content.length;
                    
                    case 'newest':
                    default:
                        return new Date(b.timestamp) - new Date(a.timestamp);
                }
            });
            
            if (dreams.length === 0) {
                const filterText = filterType === 'all' ? '' : 
                    filterType === 'lucid' ? ' lucid' : ' non-lucid';
                
                const noResultsMessage = `No${filterText} dreams to export for analysis${searchTerm ? ' matching your search' : ''}. ${filterType === 'lucid' ? 'Try recording some lucid dreams first!' : 'Record some dreams first!'}`;
                
                createInlineMessage('error', noResultsMessage, {
                    container: document.querySelector('.main-content'),
                    position: 'top',
                    duration: 5000
                });
                return;
            }
            
            try {
                // Performance optimization: Limit analysis to most recent dreams based on size
                const maxDreams = dreams.length > CONSTANTS.AI_ANALYSIS_THRESHOLD ? CONSTANTS.AI_ANALYSIS_RECENT_LIMIT : CONSTANTS.AI_ANALYSIS_TOTAL_LIMIT;
                const recentDreams = dreams.slice(0, maxDreams);
                
                // Format dreams for AI analysis
                const dreamTexts = recentDreams.map(dream => {
                    const lucidStatus = dream.isLucid ? '[LUCID DREAM]' : '[REGULAR DREAM]';
                    const date = new Date(dream.timestamp).toLocaleDateString();
                    const emotions = dream.emotions ? ` [EMOTIONS: ${dream.emotions}]` : '';
                    const tags = Array.isArray(dream.tags) && dream.tags.length > 0 ? ` [TAGS: ${dream.tags.join(', ')}]` : '';
                    const dreamSigns = Array.isArray(dream.dreamSigns) && dream.dreamSigns.length > 0 ? ` [DREAM SIGNS: ${dream.dreamSigns.join(', ')}]` : '';
                    return `${lucidStatus}${emotions}${tags}${dreamSigns} ${date} - ${dream.title}: ${dream.content}`;
                }).join('\n\n');
                
                const totalDreams = dreams.length;
                const lucidCount = dreams.filter(d => d.isLucid).length;
                const lucidPercentage = totalDreams > 0 ? ((lucidCount / totalDreams) * 100).toFixed(1) : 0;
                
                // Create the full AI analysis prompt
                const aiAnalysisPrompt = `Analyze these dream journal entries for patterns, themes, and insights. The user has ${totalDreams} total dreams with ${lucidCount} lucid dreams (${lucidPercentage}% lucid rate). Each entry includes emotions, general tags/themes, and dream signs (specific lucidity triggers) when available.

${dreamTexts}

Please provide a comprehensive analysis including:

1. **Dream Patterns & Themes**: What recurring elements, settings, characters, or situations appear across dreams? How do the user's tags reveal their most common dream themes?

2. **Dream Signs Analysis**: What specific dream signs appear most frequently? Which dream signs correlate with lucid dreams vs regular dreams? What are the user's strongest personal lucidity triggers?

3. **Emotional Patterns**: What emotional themes emerge across dreams? How do emotions correlate with dream content, lucidity, or timing? Are there emotional triggers or patterns?

4. **Tag-Based Insights**: What do the user's tags reveal about their dream world? Are there tag patterns that correlate with lucidity, emotions, or specific time periods?

5. **Lucid Dream Analysis**: What triggers or signs indicate increased lucidity? How do tagged elements, emotions, and dream signs work together to create lucid experiences?

6. **Symbolic Interpretation**: What symbols or metaphors appear frequently and what might they represent? How do emotions and tags connect to symbolic content?

7. **Practical Recommendations**: Specific techniques to improve dream recall, increase lucidity recognition, or work with recurring themes. How can the user leverage their personal dream signs for better lucidity?

8. **Sleep & Dream Quality**: Any observations about dream complexity, vividness, timing patterns, and emotional intensity based on the available data?

Make the analysis personal, insightful, and actionable. Focus on helping the user understand their unique dream patterns, recurring dream signs, emotional landscapes, and how to enhance their lucid dreaming practice using their personal data.

${recentDreams.length < totalDreams ? `\n(Note: Analysis based on ${recentDreams.length} most recent dreams of ${totalDreams} total)` : ''}`;
                
                // Create and download the analysis prompt file
                const blob = new Blob([aiAnalysisPrompt], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dream-analysis-prompt-${new Date().toISOString().split('T')[0]}.txt`;
                a.style.display = 'none';
                
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                setTimeout(() => {
                    if (document.body.contains(a)) {
                        document.body.removeChild(a);
                    }
                    URL.revokeObjectURL(url);
                }, 3000);
                
                // Show success message
                createInlineMessage('success', 'AI analysis prompt exported! Copy the text and paste it into your preferred AI for dream analysis.', {
                    container: document.querySelector('.main-content'),
                    position: 'top',
                    duration: 5000
                });
                
            } catch (error) {
                console.error('Export for AI analysis error:', error);
                
                createInlineMessage('error', 'Error creating AI analysis export: ' + error.message, {
                    container: document.querySelector('.main-content'),
                    position: 'top',
                    duration: 5000
                });
            }
        }

        // MOVE TO: SECTION 7 - Autocomplete system initialization
        async function initializeAutocomplete() {
            try {
                const [tags, signs] = await Promise.all([
                    getAutocompleteSuggestions('tags'),
                    getAutocompleteSuggestions('dreamSigns')
                ]);
                setupTagAutocomplete('dreamTags', tags);
                setupTagAutocomplete('dreamSigns', signs);
            } catch (error) {
                console.error("Failed to initialize autocomplete:", error);
                // Fallback to defaults on error
                setupTagAutocomplete('dreamTags', commonTags);
                setupTagAutocomplete('dreamSigns', commonDreamSigns);
            }
        }

        // MOVE TO: SECTION 7 - Application initialization and event setup
        // APPLICATION INITIALIZATION & EVENT SETUP
        
        // MOVE TO: SECTION 7 - Browser compatibility check
        // Check browser compatibility for HSL custom properties
        function checkBrowserCompatibility() {
            if (!CSS.supports('color', 'hsl(var(--test))')) {
                // Show upgrade notice for very old browsers
                const body = document.body;
                const notice = document.createElement('div');
                notice.className = 'message-error';
                notice.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    z-index: 9999;
                `;
                notice.innerHTML = '⚠️ Your browser is outdated and may not display themes correctly. Please update to a modern browser.';
                body.insertBefore(notice, body.firstChild);
            }
        }
        
        // MOVE TO: SECTION 7 - Main application initialization
        // Initialize app
        
        document.addEventListener('DOMContentLoaded', async function() {
            // =============================================================
            // PART 1: IMMEDIATE ACTIONS (Fast setup to prevent content flashing)
            // =============================================================
            
            // Perform fast, synchronous checks first
            checkBrowserCompatibility();
            initializeTheme();
            
            // Immediately check PIN and timer status to decide the initial view
            const resetTime = getResetTime();
            let timerExpiredAndRemovedPin = false;
            if (resetTime && (resetTime - Date.now() <= 0)) {
                removeResetTime();
                removePinHash();
                isUnlocked = true;
                isAppLocked = false;
                failedPinAttempts = 0;
                timerExpiredAndRemovedPin = true;
            }
            const pinIsSetUp = isPinSetup();

            // Prepare the correct initial screen (lock or journal)
            if (pinIsSetUp && !timerExpiredAndRemovedPin) {
                // PIN EXISTS: Start locked.
                isUnlocked = false;
                isAppLocked = true;
                preLockActiveTab = 'journal';
                // This will create and display the lock screen content.
                switchAppTab('lock'); 
                hideAllTabButtons();
            } else {
                // NO PIN: Start unlocked on the journal tab.
                isUnlocked = true;
                isAppLocked = false;
                switchAppTab('journal');
                showAllTabButtons();
            }

            // Now that the correct content is ready to be displayed, make the container visible.
            document.querySelector('.container').style.visibility = 'visible';
            
            // =================================================================
            // PART 2: SLOWER SETUP TASKS (The rest of your code now runs)
            // =================================================================

            // Setup event delegation system
            setupEventDelegation();
            
            // Initialize Database (slower)
            await initDB();
            
            // Initialize Goals (slower)
            await initGoals();
            
            // CRITICAL FIX: Ensure tab container exists before any tab switching
            let tabContainer = document.querySelector('.tab-content-container');
            if (!tabContainer) {
                console.log('Creating tab container on initialization');
                const containerDiv = document.querySelector('.container');
                const appTabs = document.querySelector('.app-tabs');
                if (containerDiv && appTabs) {
                    tabContainer = document.createElement('div');
                    tabContainer.className = 'tab-content-container';
                    tabContainer.style.cssText = `
                        background: var(--bg-primary);
                        min-height: 400px;
                        overflow-x: hidden;
                    `;
                    appTabs.parentNode.insertBefore(tabContainer, appTabs.nextSibling);
                    console.log('Tab container created successfully');
                } else {
                    console.error('Could not find container or app-tabs elements');
                }
            }
            
            // Perform migration if needed
            if (isIndexedDBAvailable() && isLocalStorageAvailable()) {
                await migrateFromLocalStorage();
            }
            
            // Set current date/time as default for new dreams
            const dreamDateInput = document.getElementById('dreamDate');
            if (dreamDateInput) {
                const now = new Date();
                
                // Get local date components and pad with leading zeros if needed
                const year = now.getFullYear();
                const month = (now.getMonth() + 1).toString().padStart(2, '0');
                const day = now.getDate().toString().padStart(2, '0');
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');

                // Assemble the string in the correct format for datetime-local
                const localDatetimeString = `${year}-${month}-${day}T${hours}:${minutes}`;
                
                dreamDateInput.value = localDatetimeString;
            }
            
            // Update timer warning if active
            updateTimerWarning();
            const timerWarningInterval = setInterval(updateTimerWarning, 60000);
            
            // Setup security controls
            updateSecurityControls();
            
            // Cleanup timers on page unload to prevent memory leaks
            window.addEventListener('beforeunload', function() {
                try {
                    Object.keys(deleteTimeouts).forEach(dreamId => clearTimeout(deleteTimeouts[dreamId]));
                    Object.keys(voiceDeleteTimeouts).forEach(voiceNoteId => clearTimeout(voiceDeleteTimeouts[voiceNoteId]));
                    if (timerWarningInterval) clearInterval(timerWarningInterval);
                    if (searchDebounceTimer) clearTimeout(searchDebounceTimer);
                    if (filterDebounceTimer) clearTimeout(filterDebounceTimer);
                    if (scrollDebounceTimer) clearTimeout(scrollDebounceTimer);
                    if (recordingTimer) clearInterval(recordingTimer);
                    if (currentPlayingAudio) currentPlayingAudio.pause();
                    if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
                    removeEndlessScroll();
                } catch (error) {
                    console.log('Cleanup error during page unload:', error);
                }
            });
            
            // Setup event listeners for non-click interactions
            const searchBox = document.getElementById('searchBox');
            const filterSelect = document.getElementById('filterSelect');
            const sortSelect = document.getElementById('sortSelect');
            const limitSelect = document.getElementById('limitSelect');
            const dreamContent = document.getElementById('dreamContent');
            const pinInput = document.getElementById('pinInput');
            
            if (searchBox) searchBox.addEventListener('input', () => debouncedSearch(CONSTANTS.DEBOUNCE_SEARCH_MS));
            if (filterSelect) filterSelect.addEventListener('change', () => debouncedFilter(CONSTANTS.DEBOUNCE_FILTER_MS));
            if (sortSelect) sortSelect.addEventListener('change', () => debouncedFilter(CONSTANTS.DEBOUNCE_FILTER_MS));
            if (limitSelect) limitSelect.addEventListener('change', () => debouncedFilter(CONSTANTS.DEBOUNCE_FILTER_MS));

            const startDateInput = document.getElementById('startDateFilter');
            const endDateInput = document.getElementById('endDateFilter');
            if (startDateInput) startDateInput.addEventListener('change', () => debouncedFilter(CONSTANTS.DEBOUNCE_FILTER_MS));
            if (endDateInput) endDateInput.addEventListener('change', () => debouncedFilter(CONSTANTS.DEBOUNCE_FILTER_MS));
            
            initializeAutocomplete();
            
            if (dreamContent) dreamContent.addEventListener('keydown', e => { if (e.ctrlKey && e.key === 'Enter') saveDream(); });
            if (pinInput) pinInput.addEventListener('keypress', e => { if (e.key === 'Enter') document.getElementById('pinMainBtn')?.click(); });
            
            document.addEventListener('keypress', e => {
                if (e.key === 'Enter') {
                    const lockScreenPinInput = document.getElementById('lockScreenPinInput');
                    if (lockScreenPinInput && document.activeElement === lockScreenPinInput) {
                        verifyLockScreenPin();
                    }
                }
            });
            
            // Display initial data
            try {
                await displayDreams();
                await updateRecordButtonState();
                await displayVoiceNotes();
                updateSecurityControls();
                
                setTimeout(() => updateRecordButtonState(), 100);

                if (timerExpiredAndRemovedPin) {
                    // Show a message if the timer just expired on this page load
                    const container = document.querySelector('.main-content');
                    if (container) {
                        createInlineMessage('info', 'PIN reset timer has expired. Your PIN has been removed. You can set a new one if desired.', {
                            container: container, position: 'top', duration: 8000
                        });
                    }
                }
            } catch (error) {
                console.error('Error displaying dreams on page load:', error);
                const container = document.getElementById('entriesContainer');
                if (container) {
                    container.innerHTML = `<div class="no-entries"><h3>⚠️ Error Loading Dreams</h3><p>There was a problem loading your dreams. Please refresh the page.</p><button onclick="location.reload()" class="btn btn-primary" style="margin-top: 15px;">🔄 Refresh Page</button></div>`;
                }
            }
            
            // Check voice recording support
            const voiceCapabilities = getVoiceCapabilities();
            // ... (Your voice capabilities check code remains here) ...
            // ...
            
            // Restore dream form collapse state
            try {
                if (localStorage.getItem(DREAM_FORM_COLLAPSE_KEY) === 'true') {
                    isDreamFormCollapsed = false; // will be toggled to true below
                    toggleDreamForm();
                }
            } catch (e) {}
        });
    })();
    </script>
</body>
</html>
